# Generated by generate_sdk_wrappers.py. DO NOT EDIT

from abc import ABCMeta, abstractmethod
from dataclasses import dataclass, field
from typing import Any, Optional, Self, TypeVar, Generic
from uuid import uuid4

from luminarycloud.tables import RectilinearTable
from luminarycloud.vector3 import Vector3
from luminarycloud._proto.client import simulation_pb2 as clientpb
from luminarycloud._proto.client.entity_pb2 import EntityIdentifier
import luminarycloud.params.enum._enum_wrappers as enum


def create_unique_id():
    return str(uuid4())


T = TypeVar("T")


class ParamGroupWrapper(Generic[T], metaclass=ABCMeta):
    """Base class for all parameter group wrappers."""

    @abstractmethod
    def _to_proto(self) -> T:
        pass

    @abstractmethod
    def _from_proto(self, proto: T):
        pass

    @classmethod
    def from_proto(cls, proto: T) -> Self:
        _wrapper = cls()
        _wrapper._from_proto(proto)
        return _wrapper


@dataclass(kw_only=True)
class LaminarViscosityModel(metaclass=ABCMeta):
    """Laminar viscosity model."""

    pass


@dataclass(kw_only=True)
class Sutherland(LaminarViscosityModel):
    """Sutherland viscosity model."""

    viscosity_ref: float = 1.716e-05
    "Dynamic viscosity at the reference temperature."
    viscosity_temp_ref: float = 273.15
    "Reference temperature."
    sutherland_constant: float = 110.4
    "Sutherland Constant."


@dataclass(kw_only=True)
class ConstantViscosity(LaminarViscosityModel):
    """Constant dynamic viscosity."""

    constant: float = 1.7894e-05
    "Value or table for dynamic viscosity."


@dataclass(kw_only=True)
class TemperatureDependentViscosity(LaminarViscosityModel):
    """Tabulated dynamic viscosity values vs temperature."""

    table_data: Optional[RectilinearTable] = None
    "Correlation between dynamic viscosity and temperature."


@dataclass(kw_only=True)
class MaterialFluid(ParamGroupWrapper[clientpb.MaterialFluid]):
    """Configuration for Fluid materials"""

    reference_pressure: float = 0.0
    "Reference pressure for the simulation. Unless otherwise stated, all pressure values are relative to this field (i.e. gauge pressures)."
    density_relationship: enum.DensityRelationship = enum.DensityRelationship.IDEAL_GAS
    "Relationship for computing the density of the fluid."
    constant_density_value: float = 1.225
    "Constant density value."
    molecular_weight: float = 28.96
    "Molecular weight of the gas used to compute its specific gas constant. Air is 28.96 g/mol."
    specific_heat_cp: float = 1004.703
    "Specific heat at constant pressure. Air is 1004.703 J/kg/K."
    laminar_thermal_conductivity: enum.LaminarThermalConductivity = (
        enum.LaminarThermalConductivity.LAMINAR_CONSTANT_THERMAL_PRANDTL
    )
    "Model for the laminar thermal conductivity of a fluid."
    laminar_constant_thermal_conductivity_constant: float = 0.0257
    "Value or table for laminar thermal conductivity."
    laminar_constant_thermal_prandtl_constant: float = 0.72
    "The laminar Prandtl number."
    thermal_conductivity_table_data: Optional[RectilinearTable] = None
    "Correlation between thermal conductivity and temperature."
    boussinesq_approximation: enum.BoussinesqApproximation = (
        enum.BoussinesqApproximation.BOUSSINESQ_ON
    )
    "Introduce a body force due to thermal expansion without modifying the material density."
    boussinesq_temp_ref: float = 288.15
    "Temperature at which there is no effect from the Boussinesq approximation (i.e. no change in density)."
    thermal_expansion_coefficient: float = 0.0035
    "Volumetric expansion due to temperature."
    laminar_viscosity_model: Optional[LaminarViscosityModel] = field(
        default_factory=LaminarViscosityModel
    )
    "Laminar viscosity model."

    def _to_proto(self) -> clientpb.MaterialFluid:
        _proto = clientpb.MaterialFluid()
        _proto.reference_pressure.value = self.reference_pressure
        _proto.density_relationship = self.density_relationship
        _proto.constant_density_value.value = self.constant_density_value
        _proto.molecular_weight.value = self.molecular_weight
        _proto.specific_heat_cp.value = self.specific_heat_cp
        _proto.laminar_thermal_conductivity = self.laminar_thermal_conductivity
        _proto.laminar_constant_thermal_conductivity_constant.value = (
            self.laminar_constant_thermal_conductivity_constant
        )
        _proto.laminar_constant_thermal_prandtl_constant.value = (
            self.laminar_constant_thermal_prandtl_constant
        )
        if self.thermal_conductivity_table_data is not None:
            _proto.thermal_conductivity_table_data = self.thermal_conductivity_table_data
        _proto.boussinesq_approximation = self.boussinesq_approximation
        _proto.boussinesq_temp_ref.value = self.boussinesq_temp_ref
        _proto.thermal_expansion_coefficient.value = self.thermal_expansion_coefficient
        if isinstance(self.laminar_viscosity_model, Sutherland):
            _proto.laminar_viscosity_model_newtonian = clientpb.SUTHERLAND
            _proto.sutherland_viscosity_ref.value = self.laminar_viscosity_model.viscosity_ref
            _proto.sutherland_viscosity_temp_ref.value = (
                self.laminar_viscosity_model.viscosity_temp_ref
            )
            _proto.sutherland_constant.value = self.laminar_viscosity_model.sutherland_constant
        if isinstance(self.laminar_viscosity_model, ConstantViscosity):
            _proto.laminar_viscosity_model_newtonian = clientpb.LAMINAR_CONSTANT_VISCOSITY
            _proto.laminar_constant_viscosity_constant.value = self.laminar_viscosity_model.constant
        if isinstance(self.laminar_viscosity_model, TemperatureDependentViscosity):
            _proto.laminar_viscosity_model_newtonian = (
                clientpb.TEMPERATURE_DEPENDENT_LAMINAR_VISCOSITY
            )
            _proto.dynamic_viscosity_table_data.value = self.laminar_viscosity_model.table_data
        return _proto

    def _from_proto(self, proto: clientpb.MaterialFluid):
        self.reference_pressure = proto.reference_pressure.value
        self.density_relationship = enum.DensityRelationship(proto.density_relationship)
        self.constant_density_value = proto.constant_density_value.value
        self.molecular_weight = proto.molecular_weight.value
        self.specific_heat_cp = proto.specific_heat_cp.value
        self.laminar_thermal_conductivity = enum.LaminarThermalConductivity(
            proto.laminar_thermal_conductivity
        )
        self.laminar_constant_thermal_conductivity_constant = (
            proto.laminar_constant_thermal_conductivity_constant.value
        )
        self.laminar_constant_thermal_prandtl_constant = (
            proto.laminar_constant_thermal_prandtl_constant.value
        )
        self.thermal_conductivity_table_data = proto.thermal_conductivity_table_data
        self.boussinesq_approximation = enum.BoussinesqApproximation(proto.boussinesq_approximation)
        self.boussinesq_temp_ref = proto.boussinesq_temp_ref.value
        self.thermal_expansion_coefficient = proto.thermal_expansion_coefficient.value
        if (
            proto.laminar_viscosity_model_newtonian
            == clientpb.INVALID_LAMINAR_VISCOSITY_MODEL_NEWTONIAN
        ):
            raise ValueError("Invalid laminar_viscosity_model")
        elif proto.laminar_viscosity_model_newtonian == clientpb.SUTHERLAND:
            self.laminar_viscosity_model = Sutherland(
                viscosity_ref=proto.sutherland_viscosity_ref.value,
                viscosity_temp_ref=proto.sutherland_viscosity_temp_ref.value,
                sutherland_constant=proto.sutherland_constant.value,
            )
        elif proto.laminar_viscosity_model_newtonian == clientpb.LAMINAR_CONSTANT_VISCOSITY:
            self.laminar_viscosity_model = ConstantViscosity(
                constant=proto.laminar_constant_viscosity_constant.value,
            )
        elif (
            proto.laminar_viscosity_model_newtonian
            == clientpb.TEMPERATURE_DEPENDENT_LAMINAR_VISCOSITY
        ):
            self.laminar_viscosity_model = TemperatureDependentViscosity(
                table_data=proto.dynamic_viscosity_table_data.value,
            )


@dataclass(kw_only=True)
class MaterialSolid(ParamGroupWrapper[clientpb.MaterialSolid]):
    """Configuration for Solid materials"""

    constant_density_value_solid: float = 2700
    "Constant density value."
    specific_heat_cp_solid: float = 896
    "Specific heat at constant pressure."
    thermal_conductivity_constant_solid: float = 167
    "The thermal conductivity of the material."
    thermal_conductivity_table_data: Optional[RectilinearTable] = None
    "Correlation between thermal conductivity and temperature."

    def _to_proto(self) -> clientpb.MaterialSolid:
        _proto = clientpb.MaterialSolid()
        _proto.constant_density_value_solid.value = self.constant_density_value_solid
        _proto.specific_heat_cp_solid.value = self.specific_heat_cp_solid
        _proto.thermal_conductivity_constant_solid.value = self.thermal_conductivity_constant_solid
        if self.thermal_conductivity_table_data is not None:
            _proto.thermal_conductivity_table_data = self.thermal_conductivity_table_data
        return _proto

    def _from_proto(self, proto: clientpb.MaterialSolid):
        self.constant_density_value_solid = proto.constant_density_value_solid.value
        self.specific_heat_cp_solid = proto.specific_heat_cp_solid.value
        self.thermal_conductivity_constant_solid = proto.thermal_conductivity_constant_solid.value
        self.thermal_conductivity_table_data = proto.thermal_conductivity_table_data


@dataclass(kw_only=True)
class VolumeEntity(ParamGroupWrapper[clientpb.VolumeEntity]):
    """Volume entity."""

    volume_identifier: Optional[EntityIdentifier] = None
    "Unique identifier for a volume entity"

    def _to_proto(self) -> clientpb.VolumeEntity:
        _proto = clientpb.VolumeEntity()
        if self.volume_identifier is not None:
            _proto.volume_identifier.id = self.volume_identifier.id
            _proto.volume_identifier.name = self.volume_identifier.name
        return _proto

    def _from_proto(self, proto: clientpb.VolumeEntity):
        self.volume_identifier = proto.volume_identifier


@dataclass(kw_only=True)
class General(ParamGroupWrapper[clientpb.General]):
    """Basic parameters used by a solution."""

    float_type: enum.FloatType = enum.FloatType.DOUBLE
    "Type of equations solved for the physics."
    gravity: enum.Gravity = enum.Gravity.GRAVITY_OFF
    "Apply an acceleration due to gravity or other body force."
    acceleration: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, -9.81))
    "(x,y,z) components of the acceleration due to gravity or other body force."
    flow_behavior: enum.FlowBehavior = enum.FlowBehavior.STEADY
    "Importance of physical time for the current simulation."

    def _to_proto(self) -> clientpb.General:
        _proto = clientpb.General()
        _proto.float_type = self.float_type
        _proto.gravity = self.gravity
        _proto.acceleration.CopyFrom(self.acceleration._to_ad_proto())
        _proto.flow_behavior = self.flow_behavior
        return _proto

    def _from_proto(self, proto: clientpb.General):
        self.float_type = enum.FloatType(proto.float_type)
        self.gravity = enum.Gravity(proto.gravity)
        self.acceleration._from_ad_proto(proto.acceleration)
        self.flow_behavior = enum.FlowBehavior(proto.flow_behavior)


@dataclass(kw_only=True)
class Adjoint(ParamGroupWrapper[clientpb.Adjoint]):
    """Settings for adjoint sensitivity analysis."""

    adjoint_output: Optional[Any] = None
    "Function to differentiate."
    surfaces: list[str] = field(default_factory=list)
    ""
    primal_simulation_id: str = ""
    ""

    def _to_proto(self) -> clientpb.Adjoint:
        _proto = clientpb.Adjoint()
        if self.adjoint_output is not None:
            _proto.adjoint_output.CopyFrom(self.adjoint_output)
        if self.surfaces is not None:
            _proto.surfaces.extend(self.surfaces)
        if self.primal_simulation_id is not None:
            _proto.primal_simulation_id = self.primal_simulation_id
        return _proto

    def _from_proto(self, proto: clientpb.Adjoint):
        self.adjoint_output = proto.adjoint_output
        self.surfaces.extend(proto.surfaces)
        self.primal_simulation_id = proto.primal_simulation_id


@dataclass(kw_only=True)
class Time(ParamGroupWrapper[clientpb.Time]):
    """Time parameters used by a transient solution (required if flow_behavior = transient)."""

    time_marching: enum.TimeMarching = enum.TimeMarching.TIME_IMPLICIT
    "Scheme for time-accurate integration."
    time_implicit_order: enum.TimeImplicitOrder = enum.TimeImplicitOrder.TIME_SECOND
    "Temporal order of accuracy of the dual time stepping scheme for time-accurate integration."
    physical_time_step_method: enum.PhysicalTimeStepMethod = (
        enum.PhysicalTimeStepMethod.FIXED_TIME_STEP
    )
    "Method for obtaining the physical time step in a time-accurate simulation."
    time_step_val: float = 0.0001
    "The fixed physical time step."
    time_step_ramp: enum.TimeStepRamp = enum.TimeStepRamp.TIME_STEP_RAMP_OFF
    "Use a larger time step value during the initial transients of a simulation and then ramp linearly towards the target value, to accelerate statistical convergence. Only applicable to transient problems with time implicit integration (dual time stepping)."
    time_step_ramp_initial_val: float = 0.001
    "Initial physical time step for time step ramping. The physical time step is ramped toward the target for the duration of the ramp."
    time_step_ramp_iteration_begin: int = 500
    "Time step iteration to start the time step ramping process."
    time_step_ramp_iteration_end: int = 1000
    "Time step iteration to end the time step ramping process."
    compute_statistics: enum.ComputeStatistics = enum.ComputeStatistics.COMPUTE_STATISTICS_OFF
    "Compute time-averaged values of flow variables (e.g. Velocity)."
    statistics_start_iteration: int = 1
    "Time step iteration at which to start computing the statistics."
    statistics_update_interval: int = 1
    "Number of time steps in between updates of the statistics."

    def _to_proto(self) -> clientpb.Time:
        _proto = clientpb.Time()
        _proto.time_marching = self.time_marching
        _proto.time_implicit_order = self.time_implicit_order
        _proto.physical_time_step_method = self.physical_time_step_method
        _proto.time_step_val.value = self.time_step_val
        _proto.time_step_ramp = self.time_step_ramp
        _proto.time_step_ramp_initial_val.value = self.time_step_ramp_initial_val
        _proto.time_step_ramp_iteration_begin.value = self.time_step_ramp_iteration_begin
        _proto.time_step_ramp_iteration_end.value = self.time_step_ramp_iteration_end
        _proto.compute_statistics = self.compute_statistics
        _proto.statistics_start_iteration.value = self.statistics_start_iteration
        _proto.statistics_update_interval.value = self.statistics_update_interval
        return _proto

    def _from_proto(self, proto: clientpb.Time):
        self.time_marching = enum.TimeMarching(proto.time_marching)
        self.time_implicit_order = enum.TimeImplicitOrder(proto.time_implicit_order)
        self.physical_time_step_method = enum.PhysicalTimeStepMethod(
            proto.physical_time_step_method
        )
        self.time_step_val = proto.time_step_val.value
        self.time_step_ramp = enum.TimeStepRamp(proto.time_step_ramp)
        self.time_step_ramp_initial_val = proto.time_step_ramp_initial_val.value
        self.time_step_ramp_iteration_begin = proto.time_step_ramp_iteration_begin.value
        self.time_step_ramp_iteration_end = proto.time_step_ramp_iteration_end.value
        self.compute_statistics = enum.ComputeStatistics(proto.compute_statistics)
        self.statistics_start_iteration = proto.statistics_start_iteration.value
        self.statistics_update_interval = proto.statistics_update_interval.value


@dataclass(kw_only=True)
class FrameTransforms(ParamGroupWrapper[clientpb.FrameTransforms]):
    """"""

    transform_name: str = ""
    "Name of the transformation."
    transform_type: enum.TransformType = enum.TransformType.NO_TRANSFORM
    "Type of the Transformation."
    transform_translation: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    ""
    transform_rotation_angles: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    ""

    def _to_proto(self) -> clientpb.FrameTransforms:
        _proto = clientpb.FrameTransforms()
        if self.transform_name is not None:
            _proto.transform_name = self.transform_name
        _proto.transform_type = self.transform_type
        _proto.transform_translation.CopyFrom(self.transform_translation._to_ad_proto())
        _proto.transform_rotation_angles.CopyFrom(self.transform_rotation_angles._to_ad_proto())
        return _proto

    def _from_proto(self, proto: clientpb.FrameTransforms):
        self.transform_name = proto.transform_name
        self.transform_type = enum.TransformType(proto.transform_type)
        self.transform_translation._from_ad_proto(proto.transform_translation)
        self.transform_rotation_angles._from_ad_proto(proto.transform_rotation_angles)


@dataclass(kw_only=True)
class MotionData(ParamGroupWrapper[clientpb.MotionData]):
    """Motion data."""

    frame_id: str = ""
    "ID of the Coordinate Frame."
    frame_name: str = ""
    "Name of the Coordinate Frame."
    frame_parent: str = ""
    "ID of the parent frame."
    attached_domains: list[str] = field(default_factory=list)
    "Domains that are attached to this frame."
    attached_boundaries: list[str] = field(default_factory=list)
    "Surfaces that are attached to this frame."
    motion_type: enum.MotionType = enum.MotionType.NO_MOTION
    "Type of the Motion."
    motion_formulation: enum.MotionFormulation = enum.MotionFormulation.AUTOMATIC_MOTION_FORMULATION
    "Formulation used to model motion of volumes in transient simulations."
    motion_specification: enum.MotionSpecification = (
        enum.MotionSpecification.MOTION_SPECIFICATION_NORMAL
    )
    "Choice between repositioning volumes at simulation start, or specifying motion velocities"
    motion_translation_velocity: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant translation velocity of this frame"
    motion_angular_velocity: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant angular velocity of this frame"
    motion_translation: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant translation of this frame"
    motion_rotation_angles: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant Rotation of this frame"
    frame_transforms: list[FrameTransforms] = field(default_factory=list)
    ""

    def _to_proto(self) -> clientpb.MotionData:
        _proto = clientpb.MotionData()
        if self.frame_id is not None:
            _proto.frame_id = self.frame_id
        if self.frame_name is not None:
            _proto.frame_name = self.frame_name
        if self.frame_parent is not None:
            _proto.frame_parent = self.frame_parent
        if self.attached_domains is not None:
            _proto.attached_domains.extend(self.attached_domains)
        if self.attached_boundaries is not None:
            _proto.attached_boundaries.extend(self.attached_boundaries)
        _proto.motion_type = self.motion_type
        _proto.motion_formulation = self.motion_formulation
        _proto.motion_specification = self.motion_specification
        _proto.motion_translation_velocity.CopyFrom(self.motion_translation_velocity._to_ad_proto())
        _proto.motion_angular_velocity.CopyFrom(self.motion_angular_velocity._to_ad_proto())
        _proto.motion_translation.CopyFrom(self.motion_translation._to_ad_proto())
        _proto.motion_rotation_angles.CopyFrom(self.motion_rotation_angles._to_ad_proto())
        _proto.frame_transforms.extend(v._to_proto() for v in self.frame_transforms)
        return _proto

    def _from_proto(self, proto: clientpb.MotionData):
        self.frame_id = proto.frame_id
        self.frame_name = proto.frame_name
        self.frame_parent = proto.frame_parent
        self.attached_domains.extend(proto.attached_domains)
        self.attached_boundaries.extend(proto.attached_boundaries)
        self.motion_type = enum.MotionType(proto.motion_type)
        self.motion_formulation = enum.MotionFormulation(proto.motion_formulation)
        self.motion_specification = enum.MotionSpecification(proto.motion_specification)
        self.motion_translation_velocity._from_ad_proto(proto.motion_translation_velocity)
        self.motion_angular_velocity._from_ad_proto(proto.motion_angular_velocity)
        self.motion_translation._from_ad_proto(proto.motion_translation)
        self.motion_rotation_angles._from_ad_proto(proto.motion_rotation_angles)
        self.frame_transforms = [FrameTransforms.from_proto(v) for v in proto.frame_transforms]


@dataclass(kw_only=True)
class ParticleGroup(ParamGroupWrapper[clientpb.ParticleGroup]):
    """Particle groups."""

    particle_group_id: str = field(default_factory=create_unique_id, init=False)
    ""
    particle_group_name: str = ""
    ""
    particle_group_behavior_model_ref: str = ""
    ""
    particle_group_type: enum.ParticleGroupType = enum.ParticleGroupType.ACTUATOR_DISK
    "Defines the behavior of the particles."
    actuator_disk_inner_radius: float = 0.0
    "The inner radius of the actuator disk"
    actuator_disk_outer_radius: float = 1.0
    "The outer radius of the actuator disk"
    actuator_disk_center: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Hub location (x,y,z) for rotor/propeller"
    actuator_disk_orientation_selection: enum.ActuatorDiskOrientationSelection = (
        enum.ActuatorDiskOrientationSelection.ACTUATOR_DISK_SPECIFY_ROTATION_ANGLES
    )
    "Specify orientation via normal vector, or a series of x-, y-, z-rotational transformations"
    actuator_disk_rotation_angle: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "X-, Y-, Z-rotation angles for actuator disk"
    actuator_disk_normal_vector: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 1.0))
    "Vector normal to the actuator disk (thrust direction defined as negative-Z)"
    particle_positions_table: Optional[RectilinearTable] = None
    "Particle positions"
    source_particle_radius: float = 0.25
    "Sets the physical size of the source"
    search_radius_scale_factor: float = 2.5
    "Increasing this parameter widens the projection search radius"
    isotropic_gaussian_scale_factor: float = 1.0
    "Increasing this parameter widens the projection kernel"

    def _to_proto(self) -> clientpb.ParticleGroup:
        _proto = clientpb.ParticleGroup()
        if self.particle_group_id is not None:
            _proto.particle_group_id = self.particle_group_id
        if self.particle_group_name is not None:
            _proto.particle_group_name = self.particle_group_name
        if self.particle_group_behavior_model_ref is not None:
            _proto.particle_group_behavior_model_ref = self.particle_group_behavior_model_ref
        _proto.particle_group_type = self.particle_group_type
        _proto.actuator_disk_inner_radius.value = self.actuator_disk_inner_radius
        _proto.actuator_disk_outer_radius.value = self.actuator_disk_outer_radius
        _proto.actuator_disk_center.CopyFrom(self.actuator_disk_center._to_ad_proto())
        _proto.actuator_disk_orientation_selection = self.actuator_disk_orientation_selection
        _proto.actuator_disk_rotation_angle.CopyFrom(
            self.actuator_disk_rotation_angle._to_ad_proto()
        )
        _proto.actuator_disk_normal_vector.CopyFrom(self.actuator_disk_normal_vector._to_ad_proto())
        if self.particle_positions_table is not None:
            _proto.particle_positions_table = self.particle_positions_table
        _proto.source_particle_radius.value = self.source_particle_radius
        _proto.search_radius_scale_factor.value = self.search_radius_scale_factor
        _proto.isotropic_gaussian_scale_factor.value = self.isotropic_gaussian_scale_factor
        return _proto

    def _from_proto(self, proto: clientpb.ParticleGroup):
        self.particle_group_id = proto.particle_group_id
        self.particle_group_name = proto.particle_group_name
        self.particle_group_behavior_model_ref = proto.particle_group_behavior_model_ref
        self.particle_group_type = enum.ParticleGroupType(proto.particle_group_type)
        self.actuator_disk_inner_radius = proto.actuator_disk_inner_radius.value
        self.actuator_disk_outer_radius = proto.actuator_disk_outer_radius.value
        self.actuator_disk_center._from_ad_proto(proto.actuator_disk_center)
        self.actuator_disk_orientation_selection = enum.ActuatorDiskOrientationSelection(
            proto.actuator_disk_orientation_selection
        )
        self.actuator_disk_rotation_angle._from_ad_proto(proto.actuator_disk_rotation_angle)
        self.actuator_disk_normal_vector._from_ad_proto(proto.actuator_disk_normal_vector)
        self.particle_positions_table = proto.particle_positions_table
        self.source_particle_radius = proto.source_particle_radius.value
        self.search_radius_scale_factor = proto.search_radius_scale_factor.value
        self.isotropic_gaussian_scale_factor = proto.isotropic_gaussian_scale_factor.value


@dataclass(kw_only=True)
class MonitorPlane(ParamGroupWrapper[clientpb.MonitorPlane]):
    """Monitor plane."""

    monitor_plane_id: str = field(default_factory=create_unique_id, init=False)
    ""
    monitor_plane_name: str = ""
    ""
    monitor_plane_point: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "A point on the plane"
    monitor_plane_normal: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 1.0))
    "A vector normal to the plane"
    monitor_plane_box_clip: bool = False
    "Turn on or off the ability to clip a monitor plane using a box."
    monitor_plane_clip_center: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Center of the box used to clip the monitor plane."
    monitor_plane_clip_size: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Side lengths of the box used to clip the monitor plane."
    monitor_plane_clip_rotation: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Rotation vector of Euler angles (XYZ order) that transforms the box used to clip the monitor plane."
    monitor_plane_volume_clip: bool = False
    "Turn on or off the ability to constrain a monitor plane to specific volumes of the geometry."
    monitor_plane_volumes: list[EntityIdentifier] = field(default_factory=list)
    "List of volumes used to clip the monitor plane."

    def _to_proto(self) -> clientpb.MonitorPlane:
        _proto = clientpb.MonitorPlane()
        if self.monitor_plane_id is not None:
            _proto.monitor_plane_id = self.monitor_plane_id
        if self.monitor_plane_name is not None:
            _proto.monitor_plane_name = self.monitor_plane_name
        _proto.monitor_plane_point.CopyFrom(self.monitor_plane_point._to_ad_proto())
        _proto.monitor_plane_normal.CopyFrom(self.monitor_plane_normal._to_ad_proto())
        if self.monitor_plane_box_clip is not None:
            _proto.monitor_plane_box_clip = self.monitor_plane_box_clip
        _proto.monitor_plane_clip_center.CopyFrom(self.monitor_plane_clip_center._to_ad_proto())
        _proto.monitor_plane_clip_size.CopyFrom(self.monitor_plane_clip_size._to_ad_proto())
        _proto.monitor_plane_clip_rotation.CopyFrom(self.monitor_plane_clip_rotation._to_ad_proto())
        if self.monitor_plane_volume_clip is not None:
            _proto.monitor_plane_volume_clip = self.monitor_plane_volume_clip
        if self.monitor_plane_volumes is not None:
            _proto.monitor_plane_volumes.extend(self.monitor_plane_volumes)
        return _proto

    def _from_proto(self, proto: clientpb.MonitorPlane):
        self.monitor_plane_id = proto.monitor_plane_id
        self.monitor_plane_name = proto.monitor_plane_name
        self.monitor_plane_point._from_ad_proto(proto.monitor_plane_point)
        self.monitor_plane_normal._from_ad_proto(proto.monitor_plane_normal)
        self.monitor_plane_box_clip = proto.monitor_plane_box_clip
        self.monitor_plane_clip_center._from_ad_proto(proto.monitor_plane_clip_center)
        self.monitor_plane_clip_size._from_ad_proto(proto.monitor_plane_clip_size)
        self.monitor_plane_clip_rotation._from_ad_proto(proto.monitor_plane_clip_rotation)
        self.monitor_plane_volume_clip = proto.monitor_plane_volume_clip
        self.monitor_plane_volumes.extend(proto.monitor_plane_volumes)


@dataclass(kw_only=True)
class BodyFrame(ParamGroupWrapper[clientpb.BodyFrame]):
    """Body frame."""

    body_frame_id: str = ""
    ""

    def _to_proto(self) -> clientpb.BodyFrame:
        _proto = clientpb.BodyFrame()
        if self.body_frame_id is not None:
            _proto.body_frame_id = self.body_frame_id
        return _proto

    def _from_proto(self, proto: clientpb.BodyFrame):
        self.body_frame_id = proto.body_frame_id


@dataclass(kw_only=True)
class SurfaceName(ParamGroupWrapper[clientpb.SurfaceName]):
    """Surface name map."""

    surface_name: str = ""
    ""

    def _to_proto(self) -> clientpb.SurfaceName:
        _proto = clientpb.SurfaceName()
        if self.surface_name is not None:
            _proto.surface_name = self.surface_name
        return _proto

    def _from_proto(self, proto: clientpb.SurfaceName):
        self.surface_name = proto.surface_name


@dataclass(kw_only=True)
class Output(ParamGroupWrapper[clientpb.Output]):
    """Solution output settings."""

    iters_per_output: int = 1000
    "Number of (pseudo) timesteps between successive full solution output. If &le;0, only the final solution is written."
    debug_output: enum.DebugOutput = enum.DebugOutput.SOLN_DEBUG_OUTPUT_OFF
    "Output debug fields in solution files."
    debug_output_interior_surface_data: enum.DebugOutputInteriorSurfaceData = (
        enum.DebugOutputInteriorSurfaceData.SOLN_DEBUG_OUTPUT_INT_SURF_DATA_OFF
    )
    "Copy the interior volume data into the surface data."

    def _to_proto(self) -> clientpb.Output:
        _proto = clientpb.Output()
        _proto.iters_per_output.value = self.iters_per_output
        _proto.debug_output = self.debug_output
        _proto.debug_output_interior_surface_data = self.debug_output_interior_surface_data
        return _proto

    def _from_proto(self, proto: clientpb.Output):
        self.iters_per_output = proto.iters_per_output.value
        self.debug_output = enum.DebugOutput(proto.debug_output)
        self.debug_output_interior_surface_data = enum.DebugOutputInteriorSurfaceData(
            proto.debug_output_interior_surface_data
        )


@dataclass(kw_only=True)
class VolumeMaterialRelationship(ParamGroupWrapper[clientpb.VolumeMaterialRelationship]):
    """Tracks volume entity(1) -> material entity(1) relationship."""

    volume_identifier: Optional[EntityIdentifier] = None
    "Unique identifier for a volume entity"
    material_identifier: Optional[EntityIdentifier] = None
    "Unique identifier for a material entity"

    def _to_proto(self) -> clientpb.VolumeMaterialRelationship:
        _proto = clientpb.VolumeMaterialRelationship()
        if self.volume_identifier is not None:
            _proto.volume_identifier.id = self.volume_identifier.id
            _proto.volume_identifier.name = self.volume_identifier.name
        if self.material_identifier is not None:
            _proto.material_identifier.id = self.material_identifier.id
            _proto.material_identifier.name = self.material_identifier.name
        return _proto

    def _from_proto(self, proto: clientpb.VolumeMaterialRelationship):
        self.volume_identifier = proto.volume_identifier
        self.material_identifier = proto.material_identifier


@dataclass(kw_only=True)
class VolumePhysicsRelationship(ParamGroupWrapper[clientpb.VolumePhysicsRelationship]):
    """Tracks volume entity(1) -> physics entity(1) relationship."""

    volume_identifier: Optional[EntityIdentifier] = None
    "Unique identifier for a volume entity"
    physics_identifier: Optional[EntityIdentifier] = None
    "Unique identifier for a physics entity"

    def _to_proto(self) -> clientpb.VolumePhysicsRelationship:
        _proto = clientpb.VolumePhysicsRelationship()
        if self.volume_identifier is not None:
            _proto.volume_identifier.id = self.volume_identifier.id
            _proto.volume_identifier.name = self.volume_identifier.name
        if self.physics_identifier is not None:
            _proto.physics_identifier.id = self.physics_identifier.id
            _proto.physics_identifier.name = self.physics_identifier.name
        return _proto

    def _from_proto(self, proto: clientpb.VolumePhysicsRelationship):
        self.volume_identifier = proto.volume_identifier
        self.physics_identifier = proto.physics_identifier


@dataclass(kw_only=True)
class EntityRelationships(ParamGroupWrapper[clientpb.EntityRelationships]):
    """Relationships between different entities."""

    volume_material_relationship: list[VolumeMaterialRelationship] = field(default_factory=list)
    "Tracks volume entity(1) -> material entity(1) relationship."
    volume_physics_relationship: list[VolumePhysicsRelationship] = field(default_factory=list)
    "Tracks volume entity(1) -> physics entity(1) relationship."

    def _to_proto(self) -> clientpb.EntityRelationships:
        _proto = clientpb.EntityRelationships()
        _proto.volume_material_relationship.extend(
            v._to_proto() for v in self.volume_material_relationship
        )
        _proto.volume_physics_relationship.extend(
            v._to_proto() for v in self.volume_physics_relationship
        )
        return _proto

    def _from_proto(self, proto: clientpb.EntityRelationships):
        self.volume_material_relationship = [
            VolumeMaterialRelationship.from_proto(v) for v in proto.volume_material_relationship
        ]
        self.volume_physics_relationship = [
            VolumePhysicsRelationship.from_proto(v) for v in proto.volume_physics_relationship
        ]


@dataclass(kw_only=True)
class ReferenceValues(ParamGroupWrapper[clientpb.ReferenceValues]):
    """Define reference values needed for computing forces and moments."""

    area_ref: float = 1.0
    "Reference area for computing force and moment coefficients."
    length_ref: float = 1.0
    "Generic reference length for computing moment coefficients."
    use_aero_moment_ref_lengths: bool = False
    "Separate reference lengths for pitching, rolling and yawing moments."
    length_ref_pitch: float = 1.0
    "Reference length for computing pitching moment coefficients."
    length_ref_roll: float = 1.0
    "Reference length for computing rolling moment coefficients."
    length_ref_yaw: float = 1.0
    "Reference length for computing yawing moment coefficients."
    p_ref: float = 101325.0
    "Absolute static reference pressure, exclusively for computing force and moment coefficients. This value is independent of the material reference pressure and it does not interact with physics inputs such as boundary conditions."
    t_ref: float = 288.15
    "Reference temperature for computing force and moment coefficients."
    v_ref: float = 1.0
    "Reference velocity magnitude for computing force and moment coefficients."

    def _to_proto(self) -> clientpb.ReferenceValues:
        _proto = clientpb.ReferenceValues()
        _proto.area_ref.value = self.area_ref
        _proto.length_ref.value = self.length_ref
        if self.use_aero_moment_ref_lengths is not None:
            _proto.use_aero_moment_ref_lengths = self.use_aero_moment_ref_lengths
        _proto.length_ref_pitch.value = self.length_ref_pitch
        _proto.length_ref_roll.value = self.length_ref_roll
        _proto.length_ref_yaw.value = self.length_ref_yaw
        _proto.p_ref.value = self.p_ref
        _proto.t_ref.value = self.t_ref
        _proto.v_ref.value = self.v_ref
        return _proto

    def _from_proto(self, proto: clientpb.ReferenceValues):
        self.area_ref = proto.area_ref.value
        self.length_ref = proto.length_ref.value
        self.use_aero_moment_ref_lengths = proto.use_aero_moment_ref_lengths
        self.length_ref_pitch = proto.length_ref_pitch.value
        self.length_ref_roll = proto.length_ref_roll.value
        self.length_ref_yaw = proto.length_ref_yaw.value
        self.p_ref = proto.p_ref.value
        self.t_ref = proto.t_ref.value
        self.v_ref = proto.v_ref.value


@dataclass(kw_only=True)
class BoundaryLayerProfile(ParamGroupWrapper[clientpb.BoundaryLayerProfile]):
    """"""

    n_layers: int = 40
    "Maximum number of prism layers within a boundary layer mesh."
    initial_size: float = 1e-06
    "Size of the mesh layer nearest the boundary surface in meters."
    growth_rate: float = 1.2
    "Ratio of size between 2 successive boundary mesh layers."
    surfaces: list[str] = field(default_factory=list)
    ""

    def _to_proto(self) -> clientpb.BoundaryLayerProfile:
        _proto = clientpb.BoundaryLayerProfile()
        _proto.n_layers.value = self.n_layers
        _proto.initial_size.value = self.initial_size
        _proto.growth_rate.value = self.growth_rate
        if self.surfaces is not None:
            _proto.surfaces.extend(self.surfaces)
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryLayerProfile):
        self.n_layers = proto.n_layers.value
        self.initial_size = proto.initial_size.value
        self.growth_rate = proto.growth_rate.value
        self.surfaces.extend(proto.surfaces)


@dataclass(kw_only=True)
class AdaptiveMeshRefinement(ParamGroupWrapper[clientpb.AdaptiveMeshRefinement]):
    """Adaptive Mesh Refinement"""

    refinement_iterations: int = 0
    "Number of refinement iterations to perform."
    refinement_dispatch_interval: int = 0
    "Number of solver iterations to perform before dispatching refinement."
    max_refinement_interval: int = 0
    "Maximum number of solver iterations to perform before waiting for refinement to complete."
    initial_target_complexity: float = 0
    "Target Complexity on the first refinement iteration."
    final_target_complexity: float = 0
    "Target Complexity on the final refinement iteration."
    meshing_method: enum.MeshingMethod = enum.MeshingMethod.MESH_METHOD_MANUAL
    "The method to generate the computational mesh."
    target_cv_millions: int = 10
    "User-requested mesh size in millions of control volumes."
    user_scaling: float = 1.0
    "Scale factor between the geometry and the mesh."
    boundary_layer_profile: list[BoundaryLayerProfile] = field(default_factory=list)
    ""

    def _to_proto(self) -> clientpb.AdaptiveMeshRefinement:
        _proto = clientpb.AdaptiveMeshRefinement()
        _proto.refinement_iterations.value = self.refinement_iterations
        _proto.refinement_dispatch_interval.value = self.refinement_dispatch_interval
        _proto.max_refinement_interval.value = self.max_refinement_interval
        _proto.initial_target_complexity.value = self.initial_target_complexity
        _proto.final_target_complexity.value = self.final_target_complexity
        _proto.meshing_method = self.meshing_method
        _proto.target_cv_millions.value = self.target_cv_millions
        _proto.user_scaling.value = self.user_scaling
        _proto.boundary_layer_profile.extend(v._to_proto() for v in self.boundary_layer_profile)
        return _proto

    def _from_proto(self, proto: clientpb.AdaptiveMeshRefinement):
        self.refinement_iterations = proto.refinement_iterations.value
        self.refinement_dispatch_interval = proto.refinement_dispatch_interval.value
        self.max_refinement_interval = proto.max_refinement_interval.value
        self.initial_target_complexity = proto.initial_target_complexity.value
        self.final_target_complexity = proto.final_target_complexity.value
        self.meshing_method = enum.MeshingMethod(proto.meshing_method)
        self.target_cv_millions = proto.target_cv_millions.value
        self.user_scaling = proto.user_scaling.value
        self.boundary_layer_profile = [
            BoundaryLayerProfile.from_proto(v) for v in proto.boundary_layer_profile
        ]


@dataclass(kw_only=True)
class SolutionControlsHeat(ParamGroupWrapper[clientpb.SolutionControlsHeat]):
    """Solution controls for a heat transfer physics solver."""

    relaxation_method: enum.RelaxationMethod = enum.RelaxationMethod.IMPLICIT
    "Relaxation scheme for steady-state simulations or time implicit transient simulations."
    implicit_method: enum.ImplicitMethod = enum.ImplicitMethod.BACKWARD_EULER
    "Scheme for implicit relaxation of the governing equations."
    explicit_method: enum.ExplicitMethod = enum.ExplicitMethod.RK_4
    "Scheme for explicit relaxation or explicit time-accurate integration of the governing equations."
    linear_solver_type: enum.LinearSolverType = enum.LinearSolverType.GS
    "Type of linear solver used for implicit relaxation."
    linsol_iterations: int = 15
    "Maximum number of linear solver iterations per nonlinear solution update. The linear solver terminates if the maximum is reached."
    linsol_tolerance: float = 0.01
    "Relative reduction target in the linear solver residual from an initial value of 1.0 per nonlinear solution update. The linear solver terminates if the tolerance is met."
    linsol_amg_pre_sweeps: int = 1
    "Linear Solver AMG Pre-Sweeps"
    linsol_amg_post_sweeps: int = 1
    "Linear Solver AMG Post-Sweeps"
    linsol_amg_coarsening_size: int = 8
    "Linear Solver AMG Coarsening Sizing"
    linsol_amg_levels: int = 20
    "Linear Solver AMG Level"
    linsol_amg_relaxation: float = 0.75
    "Linear Solver AMG Relaxation applied to the smoother."
    linsol_amg_cycle_type: enum.LinsolAmgCycleType = enum.LinsolAmgCycleType.LINSOL_AMG_CYCLE_TYPE_V
    "AMG cycle type"
    linsol_amg_freeze_levels_threshold: int = 300
    "Iteration at which the AMG levels are freezed."
    linsol_amg_smoother: enum.LinsolAmgSmoother = enum.LinsolAmgSmoother.LINSOL_AMG_SMOOTHER_JACOBI
    "AMG cycle smoother"
    controls_preset_version: int = 0
    ""
    solution_controls_heat_preset: enum.SolutionControlsHeatPreset = (
        enum.SolutionControlsHeatPreset.DEFAULT_SOLUTION_CONTROLS_HEAT
    )
    "Select suggested control settings or allow a custom choice. In general, assume a trade-off between speed and robustness (i.e. the ability to converge)."

    def _to_proto(self) -> clientpb.SolutionControlsHeat:
        _proto = clientpb.SolutionControlsHeat()
        _proto.relaxation_method = self.relaxation_method
        _proto.implicit_method = self.implicit_method
        _proto.explicit_method = self.explicit_method
        _proto.linear_solver_type = self.linear_solver_type
        _proto.linsol_iterations.value = self.linsol_iterations
        _proto.linsol_tolerance.value = self.linsol_tolerance
        _proto.linsol_amg_pre_sweeps.value = self.linsol_amg_pre_sweeps
        _proto.linsol_amg_post_sweeps.value = self.linsol_amg_post_sweeps
        _proto.linsol_amg_coarsening_size.value = self.linsol_amg_coarsening_size
        _proto.linsol_amg_levels.value = self.linsol_amg_levels
        _proto.linsol_amg_relaxation.value = self.linsol_amg_relaxation
        _proto.linsol_amg_cycle_type = self.linsol_amg_cycle_type
        _proto.linsol_amg_freeze_levels_threshold.value = self.linsol_amg_freeze_levels_threshold
        _proto.linsol_amg_smoother = self.linsol_amg_smoother
        _proto.controls_preset_version.value = self.controls_preset_version
        _proto.solution_controls_heat_preset = self.solution_controls_heat_preset
        return _proto

    def _from_proto(self, proto: clientpb.SolutionControlsHeat):
        self.relaxation_method = enum.RelaxationMethod(proto.relaxation_method)
        self.implicit_method = enum.ImplicitMethod(proto.implicit_method)
        self.explicit_method = enum.ExplicitMethod(proto.explicit_method)
        self.linear_solver_type = enum.LinearSolverType(proto.linear_solver_type)
        self.linsol_iterations = proto.linsol_iterations.value
        self.linsol_tolerance = proto.linsol_tolerance.value
        self.linsol_amg_pre_sweeps = proto.linsol_amg_pre_sweeps.value
        self.linsol_amg_post_sweeps = proto.linsol_amg_post_sweeps.value
        self.linsol_amg_coarsening_size = proto.linsol_amg_coarsening_size.value
        self.linsol_amg_levels = proto.linsol_amg_levels.value
        self.linsol_amg_relaxation = proto.linsol_amg_relaxation.value
        self.linsol_amg_cycle_type = enum.LinsolAmgCycleType(proto.linsol_amg_cycle_type)
        self.linsol_amg_freeze_levels_threshold = proto.linsol_amg_freeze_levels_threshold.value
        self.linsol_amg_smoother = enum.LinsolAmgSmoother(proto.linsol_amg_smoother)
        self.controls_preset_version = proto.controls_preset_version.value
        self.solution_controls_heat_preset = enum.SolutionControlsHeatPreset(
            proto.solution_controls_heat_preset
        )


@dataclass(kw_only=True)
class AdjointControlsHeat(ParamGroupWrapper[clientpb.AdjointControlsHeat]):
    """"""

    adjoint_solution_method: enum.AdjointSolutionMethod = (
        enum.AdjointSolutionMethod.ADJOINT_METHOD_GMRES
    )
    "The method used to solve the discrete adjoint equations."
    adjoint_gmres_restart_iters: int = 50
    "Number of iterations between GMRES restarts. A larger period makes the method more effective for tougher problems (for example incompressible flows), but increases the computational cost."

    def _to_proto(self) -> clientpb.AdjointControlsHeat:
        _proto = clientpb.AdjointControlsHeat()
        _proto.adjoint_solution_method = self.adjoint_solution_method
        _proto.adjoint_gmres_restart_iters.value = self.adjoint_gmres_restart_iters
        return _proto

    def _from_proto(self, proto: clientpb.AdjointControlsHeat):
        self.adjoint_solution_method = enum.AdjointSolutionMethod(proto.adjoint_solution_method)
        self.adjoint_gmres_restart_iters = proto.adjoint_gmres_restart_iters.value


@dataclass(kw_only=True)
class SpatialDiscretizationHeat(ParamGroupWrapper[clientpb.SpatialDiscretizationHeat]):
    """Spatial discretization settings for a heat transfer physics solver."""

    gradient_method: enum.GradientMethod = enum.GradientMethod.HLSQ
    "Method for computing the spatial gradients of fluid variables."
    hlsq_blend: float = 1.7
    "Blending parameter in the hybrid least squares gradient methods in [1,2]."
    geometry_fixes: enum.GeometryFixes = enum.GeometryFixes.GEOMETRY_FIXES_ON
    "Strategies to cope with problematic mesh regions (e.g. high skewness angles)."
    geometry_fixes_mitigations: float = 0.25
    "Magnitude of the geometrical fixes mitigations. Expected value within [0,1]. The higher this value, the more numerical dissipation is added at control volumes with low-quality topological properties."
    discretization_preset_version: int = 0
    ""
    spatial_discretization_heat_preset: enum.SpatialDiscretizationHeatPreset = (
        enum.SpatialDiscretizationHeatPreset.DEFAULT_SPATIAL_DISCRETIZATION_HEAT
    )
    "Select suggested control settings or allow a custom choice. In general, assume a trade-off between accuracy and robustness (i.e. the ability to converge)."

    def _to_proto(self) -> clientpb.SpatialDiscretizationHeat:
        _proto = clientpb.SpatialDiscretizationHeat()
        _proto.gradient_method = self.gradient_method
        _proto.hlsq_blend.value = self.hlsq_blend
        _proto.geometry_fixes = self.geometry_fixes
        _proto.geometry_fixes_mitigations.value = self.geometry_fixes_mitigations
        _proto.discretization_preset_version.value = self.discretization_preset_version
        _proto.spatial_discretization_heat_preset = self.spatial_discretization_heat_preset
        return _proto

    def _from_proto(self, proto: clientpb.SpatialDiscretizationHeat):
        self.gradient_method = enum.GradientMethod(proto.gradient_method)
        self.hlsq_blend = proto.hlsq_blend.value
        self.geometry_fixes = enum.GeometryFixes(proto.geometry_fixes)
        self.geometry_fixes_mitigations = proto.geometry_fixes_mitigations.value
        self.discretization_preset_version = proto.discretization_preset_version.value
        self.spatial_discretization_heat_preset = enum.SpatialDiscretizationHeatPreset(
            proto.spatial_discretization_heat_preset
        )


@dataclass(kw_only=True)
class BoundaryConditionsHeat(ParamGroupWrapper[clientpb.BoundaryConditionsHeat]):
    """Boundary conditions for a heat transfer physics solver."""

    profile_bc_data: Optional[RectilinearTable] = None
    "Tabulated data for spatially varying boundary conditions"
    profile_bc: bool = False
    "Turn on or off the ability to use tabulated data to define spatially varying boundary conditions."
    profile_type: Optional[enum.ProfileType] = None
    "Types of boundary condition profile."
    heat_flux_col: int = 0
    "Index of the column of the table in profile_bc_data for heat flux."
    boundary_condition_name: str = ""
    ""
    boundary_condition_display_name: str = ""
    ""
    boundary_condition_interface_id: str = ""
    "ID of the multiphysics interface that manages this boundary condition."
    surfaces: list[str] = field(default_factory=list)
    ""
    heat_physical_boundary: enum.HeatPhysicalBoundary = enum.HeatPhysicalBoundary.HEAT_BC_ISOTHERMAL
    ""
    heat_transfer_coefficient: float = 0.0
    "Heat transfer coefficient for convective heat transfer. Allowed range [0, infinity)."
    fixed_heat_flux: float = 0.0
    "Heat flux per unit area at wall boundary surfaces. Negative values increase temperatures at the wall while positive values decrease it. Enter 0 for an adiabatic wall."
    fixed_integrated_heat_flux: float = 0.0
    "Total heat flux (power) at wall boundary surfaces. Negative values increase temperatures at the wall while positive values decrease it. Enter 0 for an adiabatic wall."
    fixed_temperature: float = 288.15
    "Temperature at the wall boundary surfaces."

    def _to_proto(self) -> clientpb.BoundaryConditionsHeat:
        _proto = clientpb.BoundaryConditionsHeat()
        if self.profile_bc_data is not None:
            _proto.profile_bc_data = self.profile_bc_data
        if self.profile_bc is not None:
            _proto.profile_bc = self.profile_bc
        if self.profile_type is not None:
            _proto.profile_type = self.profile_type
        _proto.heat_flux_col.value = self.heat_flux_col
        if self.boundary_condition_name is not None:
            _proto.boundary_condition_name = self.boundary_condition_name
        if self.boundary_condition_display_name is not None:
            _proto.boundary_condition_display_name = self.boundary_condition_display_name
        if self.boundary_condition_interface_id is not None:
            _proto.boundary_condition_interface_id = self.boundary_condition_interface_id
        if self.surfaces is not None:
            _proto.surfaces.extend(self.surfaces)
        _proto.heat_physical_boundary = self.heat_physical_boundary
        _proto.heat_transfer_coefficient.value = self.heat_transfer_coefficient
        _proto.fixed_heat_flux.value = self.fixed_heat_flux
        _proto.fixed_integrated_heat_flux.value = self.fixed_integrated_heat_flux
        _proto.fixed_temperature.value = self.fixed_temperature
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsHeat):
        self.profile_bc_data = proto.profile_bc_data
        self.profile_bc = proto.profile_bc
        self.profile_type = enum.ProfileType(proto.profile_type)
        self.heat_flux_col = proto.heat_flux_col.value
        self.boundary_condition_name = proto.boundary_condition_name
        self.boundary_condition_display_name = proto.boundary_condition_display_name
        self.boundary_condition_interface_id = proto.boundary_condition_interface_id
        self.surfaces.extend(proto.surfaces)
        self.heat_physical_boundary = enum.HeatPhysicalBoundary(proto.heat_physical_boundary)
        self.heat_transfer_coefficient = proto.heat_transfer_coefficient.value
        self.fixed_heat_flux = proto.fixed_heat_flux.value
        self.fixed_integrated_heat_flux = proto.fixed_integrated_heat_flux.value
        self.fixed_temperature = proto.fixed_temperature.value


@dataclass(kw_only=True)
class InitializationHeat(ParamGroupWrapper[clientpb.InitializationHeat]):
    """Initialization settings for a heat transfer physics solver."""

    initialization_type: enum.InitializationType = enum.InitializationType.UNIFORM_VALUES
    "Type of initial condition for the field variables."
    existing_solution_id: str = ""
    "ID for the existing solution to use for initialization."
    uniform_t: float = 288.15
    "Uniform initial condition for static temperature."

    def _to_proto(self) -> clientpb.InitializationHeat:
        _proto = clientpb.InitializationHeat()
        _proto.initialization_type = self.initialization_type
        if self.existing_solution_id is not None:
            _proto.existing_solution_id = self.existing_solution_id
        _proto.uniform_t.value = self.uniform_t
        return _proto

    def _from_proto(self, proto: clientpb.InitializationHeat):
        self.initialization_type = enum.InitializationType(proto.initialization_type)
        self.existing_solution_id = proto.existing_solution_id
        self.uniform_t = proto.uniform_t.value


@dataclass(kw_only=True)
class HeatSource(ParamGroupWrapper[clientpb.HeatSource]):
    """"""

    profile_source_data: Optional[RectilinearTable] = None
    "Tabulated data for time varying heat sources"
    profile_source: bool = False
    "Turn on or off the ability to use tabulated data to define time varying heat sources."
    profile_type: Optional[enum.ProfileType] = None
    "Types of boundary condition profile."
    heat_source_col: int = 0
    "Index of the column of the table for heat source."
    heat_source_id: str = field(default_factory=create_unique_id, init=False)
    ""
    heat_source_name: str = ""
    "Name of the heat source."
    heat_source_type: enum.HeatSourceType = enum.HeatSourceType.HEAT_SOURCE_TYPE_POWER
    "Heat source specification."
    heat_source_zone_ids: list[str] = field(default_factory=list)
    "Ids of the zones the heat source is applied to."
    heat_source_power: float = 0.0
    "Power of the heat source."
    heat_source_power_per_unit_volume: float = 0.0
    "Power per unit volume of the heat source"

    def _to_proto(self) -> clientpb.HeatSource:
        _proto = clientpb.HeatSource()
        if self.profile_source_data is not None:
            _proto.profile_source_data = self.profile_source_data
        if self.profile_source is not None:
            _proto.profile_source = self.profile_source
        if self.profile_type is not None:
            _proto.profile_type = self.profile_type
        _proto.heat_source_col.value = self.heat_source_col
        if self.heat_source_id is not None:
            _proto.heat_source_id = self.heat_source_id
        if self.heat_source_name is not None:
            _proto.heat_source_name = self.heat_source_name
        _proto.heat_source_type = self.heat_source_type
        if self.heat_source_zone_ids is not None:
            _proto.heat_source_zone_ids.extend(self.heat_source_zone_ids)
        if self.heat_source_power is not None:
            _proto.heat_source_power.value = self.heat_source_power
        if self.heat_source_power_per_unit_volume is not None:
            _proto.heat_source_power_per_unit_volume.value = self.heat_source_power_per_unit_volume
        return _proto

    def _from_proto(self, proto: clientpb.HeatSource):
        self.profile_source_data = proto.profile_source_data
        self.profile_source = proto.profile_source
        self.profile_type = enum.ProfileType(proto.profile_type)
        self.heat_source_col = proto.heat_source_col.value
        self.heat_source_id = proto.heat_source_id
        self.heat_source_name = proto.heat_source_name
        self.heat_source_type = enum.HeatSourceType(proto.heat_source_type)
        self.heat_source_zone_ids.extend(proto.heat_source_zone_ids)
        self.heat_source_power = proto.heat_source_power.value
        self.heat_source_power_per_unit_volume = proto.heat_source_power_per_unit_volume.value


@dataclass(kw_only=True)
class SlidingInterfaces(ParamGroupWrapper[clientpb.SlidingInterfaces]):
    """Defines the two sides that form a sliding interface. The two sides are abutting, possibly in combination with a periodic transformation, and should have the same normal grid velocity. The tangential grid velocity can, and usually will, be different. Each side of the sliding interface can be composed out of an arbitrary number of surfaces."""

    sliding_interface_id: str = field(default_factory=create_unique_id, init=False)
    "ID of the sliding interface"
    sliding_interface_name: str = ""
    "Name of the sliding interface"
    sliding_a: list[str] = field(default_factory=list)
    "Names of the surfaces of side A of the sliding interface"
    sliding_b: list[str] = field(default_factory=list)
    "Names of the surfaces of side B of the sliding interface"
    sliding_matching_translation_transform: Vector3 = field(
        default_factory=lambda: Vector3(0.0, 0.0, 0.0)
    )
    "Translation transform vector needed to match the planes defined by each side of the sliding interface. Similar to the translation transform required to match fully-covered and -matching translating periodic bcs. Also, similar to periodic_translation in periodic_pair."
    sliding_matching_periodic_rotation_angles: Vector3 = field(
        default_factory=lambda: Vector3(0.0, 0.0, 0.0)
    )
    "Similar to sliding_matching_translation_transform but for periodic transforms. Also, similar to periodic_rotation_angles in periodic_pair."
    sliding_matching_periodic_center_of_rotation: Vector3 = field(
        default_factory=lambda: Vector3(0.0, 0.0, 0.0)
    )
    "Similar to sliding_matching_translation_transform but for periodic transforms. Also, similar to periodic_center_of_rotation in periodic_pair."
    interface_type: enum.InterfaceType = enum.InterfaceType.GENERAL_INTERFACE
    "Type of interface treatment"

    def _to_proto(self) -> clientpb.SlidingInterfaces:
        _proto = clientpb.SlidingInterfaces()
        if self.sliding_interface_id is not None:
            _proto.sliding_interface_id = self.sliding_interface_id
        if self.sliding_interface_name is not None:
            _proto.sliding_interface_name = self.sliding_interface_name
        if self.sliding_a is not None:
            _proto.sliding_a.extend(self.sliding_a)
        if self.sliding_b is not None:
            _proto.sliding_b.extend(self.sliding_b)
        _proto.sliding_matching_translation_transform.CopyFrom(
            self.sliding_matching_translation_transform._to_ad_proto()
        )
        _proto.sliding_matching_periodic_rotation_angles.CopyFrom(
            self.sliding_matching_periodic_rotation_angles._to_ad_proto()
        )
        _proto.sliding_matching_periodic_center_of_rotation.CopyFrom(
            self.sliding_matching_periodic_center_of_rotation._to_ad_proto()
        )
        _proto.interface_type = self.interface_type
        return _proto

    def _from_proto(self, proto: clientpb.SlidingInterfaces):
        self.sliding_interface_id = proto.sliding_interface_id
        self.sliding_interface_name = proto.sliding_interface_name
        self.sliding_a.extend(proto.sliding_a)
        self.sliding_b.extend(proto.sliding_b)
        self.sliding_matching_translation_transform._from_ad_proto(
            proto.sliding_matching_translation_transform
        )
        self.sliding_matching_periodic_rotation_angles._from_ad_proto(
            proto.sliding_matching_periodic_rotation_angles
        )
        self.sliding_matching_periodic_center_of_rotation._from_ad_proto(
            proto.sliding_matching_periodic_center_of_rotation
        )
        self.interface_type = enum.InterfaceType(proto.interface_type)


@dataclass(kw_only=True)
class PeriodicPair(ParamGroupWrapper[clientpb.PeriodicPair]):
    """Defines the input options needed for periodic boundaries. We assume each periodic BC can have translational OR rotational periodicity. To transform a point on boundary A to its periodically matching point on boundary B, we first subtract the center of rotation from the point coordinates to get the distance vector from the center to the point of interest, then we apply rotation around the periodicity axis and add back the center of rotation to get the coordinates of the transformed point."""

    periodic_pair_name: str = ""
    ""
    bound_a: list[str] = field(default_factory=list)
    ""
    bound_b: list[str] = field(default_factory=list)
    ""
    periodic_bc_type: enum.PeriodicBcType = enum.PeriodicBcType.TRANSLATIONAL
    ""
    translational: float = 0
    ""
    periodic_translation: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Holds the translation vector in the x,y,z directions from each point on the first periodic boundary to its matching point on the second periodic boundary."
    periodic_center_of_rotation: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Origin for the rotational periodicity transformation."
    periodic_rotation_angles: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Holds the rotation vector needed to transform each point on the first periodic boundary to its matching point on the second periodic boundary. The vector direction defines the periodicity axis and its magnitude defines the periodicity angle, in radians, from A to B according to the right-hand rule."

    def _to_proto(self) -> clientpb.PeriodicPair:
        _proto = clientpb.PeriodicPair()
        if self.periodic_pair_name is not None:
            _proto.periodic_pair_name = self.periodic_pair_name
        if self.bound_a is not None:
            _proto.bound_a.extend(self.bound_a)
        if self.bound_b is not None:
            _proto.bound_b.extend(self.bound_b)
        _proto.periodic_bc_type = self.periodic_bc_type
        _proto.translational.value = self.translational
        _proto.periodic_translation.CopyFrom(self.periodic_translation._to_ad_proto())
        _proto.periodic_center_of_rotation.CopyFrom(self.periodic_center_of_rotation._to_ad_proto())
        _proto.periodic_rotation_angles.CopyFrom(self.periodic_rotation_angles._to_ad_proto())
        return _proto

    def _from_proto(self, proto: clientpb.PeriodicPair):
        self.periodic_pair_name = proto.periodic_pair_name
        self.bound_a.extend(proto.bound_a)
        self.bound_b.extend(proto.bound_b)
        self.periodic_bc_type = enum.PeriodicBcType(proto.periodic_bc_type)
        self.translational = proto.translational.value
        self.periodic_translation._from_ad_proto(proto.periodic_translation)
        self.periodic_center_of_rotation._from_ad_proto(proto.periodic_center_of_rotation)
        self.periodic_rotation_angles._from_ad_proto(proto.periodic_rotation_angles)


@dataclass(kw_only=True)
class Heat(ParamGroupWrapper[clientpb.Heat]):
    """Configuration for a heat transfer physics solver - simulates heat transfer in solid media."""

    solution_controls_heat: Optional[SolutionControlsHeat] = field(
        default_factory=SolutionControlsHeat
    )
    "Solution controls for a heat transfer physics solver."
    adjoint_controls_heat: Optional[AdjointControlsHeat] = field(
        default_factory=AdjointControlsHeat
    )
    ""
    spatial_discretization_heat: Optional[SpatialDiscretizationHeat] = field(
        default_factory=SpatialDiscretizationHeat
    )
    "Spatial discretization settings for a heat transfer physics solver."
    boundary_conditions_heat: list[BoundaryConditionsHeat] = field(default_factory=list)
    "Boundary conditions for a heat transfer physics solver."
    initialization_heat: Optional[InitializationHeat] = field(default_factory=InitializationHeat)
    "Initialization settings for a heat transfer physics solver."
    heat_source: list[HeatSource] = field(default_factory=list)
    ""
    sliding_interfaces: list[SlidingInterfaces] = field(default_factory=list)
    "Defines the two sides that form a sliding interface. The two sides are abutting, possibly in combination with a periodic transformation, and should have the same normal grid velocity. The tangential grid velocity can, and usually will, be different. Each side of the sliding interface can be composed out of an arbitrary number of surfaces."
    periodic_pair: list[PeriodicPair] = field(default_factory=list)
    "Defines the input options needed for periodic boundaries. We assume each periodic BC can have translational OR rotational periodicity. To transform a point on boundary A to its periodically matching point on boundary B, we first subtract the center of rotation from the point coordinates to get the distance vector from the center to the point of interest, then we apply rotation around the periodicity axis and add back the center of rotation to get the coordinates of the transformed point."

    def _to_proto(self) -> clientpb.Heat:
        _proto = clientpb.Heat()
        _proto.solution_controls_heat.CopyFrom(self.solution_controls_heat._to_proto())
        _proto.adjoint_controls_heat.CopyFrom(self.adjoint_controls_heat._to_proto())
        _proto.spatial_discretization_heat.CopyFrom(self.spatial_discretization_heat._to_proto())
        _proto.boundary_conditions_heat.extend(v._to_proto() for v in self.boundary_conditions_heat)
        _proto.initialization_heat.CopyFrom(self.initialization_heat._to_proto())
        _proto.heat_source.extend(v._to_proto() for v in self.heat_source)
        _proto.sliding_interfaces.extend(v._to_proto() for v in self.sliding_interfaces)
        _proto.periodic_pair.extend(v._to_proto() for v in self.periodic_pair)
        return _proto

    def _from_proto(self, proto: clientpb.Heat):
        self.solution_controls_heat = SolutionControlsHeat.from_proto(proto.solution_controls_heat)
        self.adjoint_controls_heat = AdjointControlsHeat.from_proto(proto.adjoint_controls_heat)
        self.spatial_discretization_heat = SpatialDiscretizationHeat.from_proto(
            proto.spatial_discretization_heat
        )
        self.boundary_conditions_heat = [
            BoundaryConditionsHeat.from_proto(v) for v in proto.boundary_conditions_heat
        ]
        self.initialization_heat = InitializationHeat.from_proto(proto.initialization_heat)
        self.heat_source = [HeatSource.from_proto(v) for v in proto.heat_source]
        self.sliding_interfaces = [
            SlidingInterfaces.from_proto(v) for v in proto.sliding_interfaces
        ]
        self.periodic_pair = [PeriodicPair.from_proto(v) for v in proto.periodic_pair]


@dataclass(kw_only=True)
class BasicFluid(ParamGroupWrapper[clientpb.BasicFluid]):
    """Basic settings for a fluid flow physics solver."""

    fluid_type: enum.FluidType = enum.FluidType.SINGLE_PHASE
    "Fluid types available for use with the solver."
    viscous_model: enum.ViscousModel = enum.ViscousModel.RANS
    "Set the viscous model for the fluid solver."

    def _to_proto(self) -> clientpb.BasicFluid:
        _proto = clientpb.BasicFluid()
        _proto.fluid_type = self.fluid_type
        _proto.viscous_model = self.viscous_model
        return _proto

    def _from_proto(self, proto: clientpb.BasicFluid):
        self.fluid_type = enum.FluidType(proto.fluid_type)
        self.viscous_model = enum.ViscousModel(proto.viscous_model)


@dataclass(kw_only=True)
class Turbulence(ParamGroupWrapper[clientpb.Turbulence]):
    """Turbulence settings for a fluid flow physics solver."""

    turbulence_model: enum.TurbulenceModel = enum.TurbulenceModel.SPALART_ALLMARAS
    "Turbulence models available for Reynolds-averaged Navier-Stokes (RANS) or Detached Eddy Simulation (DES)."
    qcr_sa: enum.QcrSa = enum.QcrSa.QCR_OFF
    "Modification of the traditional linear Boussinesq relation for the Spalart-Allmaras turbulence model via the quadratic constitutive relation (QCR)."
    qcr_sst: enum.QcrSst = enum.QcrSst.SST_QCR_OFF
    "Modification of the traditional linear Boussinesq relation for the SST turbulence model via the quadratic constitutive relation (QCR)."
    rotation_correction_sa: enum.RotationCorrectionSa = (
        enum.RotationCorrectionSa.ROTATION_CORRECTION_OFF
    )
    "Apply a rotation correction to the Spalart-Allmaras turbulence model."
    turbulence_model_constants: enum.TurbulenceModelConstants = (
        enum.TurbulenceModelConstants.DEFAULT_TURB_CONSTANTS
    )
    "Apply default constants for the RANS turbulence model or choose to customize."
    c_b_1: float = 0.1355
    "C<sub>b1</sub> constant of the Spalart-Allmaras turbulence model."
    sigma: float = 0.6666666666666666
    "sigma constant of the Spalart-Allmaras turbulence model."
    c_b_2: float = 0.622
    "C<sub>b2</sub> constant of the Spalart-Allmaras turbulence model."
    kappa: float = 0.41
    "kappa constant of the Spalart-Allmaras turbulence model."
    c_w_2: float = 0.3
    "C<sub>w2</sub> constant of the Spalart-Allmaras turbulence model."
    c_w_3: float = 2.0
    "C<sub>w3</sub> constant of the Spalart-Allmaras turbulence model."
    c_v_1: float = 7.1
    "C<sub>v1</sub> constant of the Spalart-Allmaras turbulence model."
    c_t_3: float = 1.2
    "C<sub>t3</sub> constant of the Spalart-Allmaras turbulence model."
    c_t_4: float = 0.5
    "C<sub>t4</sub> constant of the Spalart-Allmaras turbulence model."
    c_r_1: float = 0.5
    "C<sub>r1</sub> constant of the Spalart-Allmaras turbulence model, used for roughness."
    c_rot: float = 2.0
    "C<sub>rot</sub> constant of the Spalart-Allmaras turbulence model, used for the rotation correction."
    sigma_k_1: float = 0.85
    "σ<sub>k1</sub> constant of the SST turbulence model."
    sigma_k_2: float = 1.0
    "σ<sub>k2</sub> constant of the SST turbulence model."
    sigma_w_1: float = 0.5
    "σ<sub>w1</sub> constant of the SST turbulence model."
    sigma_w_2: float = 0.856
    "σ<sub>w2</sub> constant of the SST turbulence model."
    beta_1: float = 0.075
    "β<sub>1</sub> constant of the SST turbulence model."
    beta_2: float = 0.0828
    "β<sub>2</sub> constant of the SST turbulence model."
    beta_star: float = 0.09
    "β<sup>*</sup> constant of the SST turbulence model."
    kappa_sst: float = 0.41
    "κ<sub>SST</sub> constant of the SST turbulence model."
    a_1: float = 0.31
    "a<sub>1</sub> constant of the SST turbulence model."
    gamma_1: float = 0.5555555555555556
    "γ<sub>1</sub> constant of the SST turbulence model."
    gamma_2: float = 0.44
    "γ<sub>2</sub> constant of the SST turbulence model."
    des_formulation: enum.DesFormulation = enum.DesFormulation.DDES_VTM
    "Select a Detached Eddy Simulation (DES) formulation."
    C_sa_des: float = 0.65
    "C<sub>des</sub> constant of the Spalart-Allmaras turbulence model for Detached Eddy Simulation."
    C_sst_des1: float = 0.78
    "C<sub>des1</sub> constant of the SST turbulence model for Detached Eddy Simulation."
    C_sst_des2: float = 0.61
    "C<sub>des2</sub> constant of the SST turbulence model for Detached Eddy Simulation."
    rans_region: enum.RansRegion = enum.RansRegion.INSIDE
    "Select a region where RANS behavior should be enforced."
    zdes_rmin: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Minimum bounds (x, y, z coordinates of bottom left corner) of the bounding box."
    zdes_rmax: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Maximum bounds (x, y, z coordinates of top right corner) of the bounding box."
    sub_grid_scale_model: enum.SubGridScaleModel = enum.SubGridScaleModel.VREMAN
    "Sub-grid scale models available for Large Eddy Simulation (LES)."
    c_s: float = 0.1
    "Coefficient of the Smagorinsky eddy viscosity model."
    c_vreman: float = 0.07225
    "Coefficient of the Vreman eddy viscosity model."
    c_wale: float = 0.325
    "Coefficient of the WALE eddy viscosity model."
    c_sigma: float = 1.5
    "Coefficient of the Sigma eddy viscosity model."
    c_amd: float = 0.19
    "Coefficient of the AMD eddy viscosity model."
    turbulent_thermal_conductivity_prandtl_constant: float = 0.85
    "Turbulent Prandtl number for computing an effective thermal conductivity for heat transport."
    transition_model: enum.TransitionModel = enum.TransitionModel.NO_TRANSITION
    "Laminar-turbulent transition models available for Reynolds-averaged Navier-Stokes (RANS)."
    transition_model_cross_flow: enum.TransitionModelCrossFlow = (
        enum.TransitionModelCrossFlow.TRANSITION_MODEL_CROSS_FLOW_OFF
    )
    "Crossflow instability treatment for transition model."
    transition_free_stream_turbulence_intensity: float = 0.002
    "The ratio of the root-mean-square velocity fluctuations to the free stream velocity. A higher number indicates a greater degree of turbulence in the incoming flow."

    def _to_proto(self) -> clientpb.Turbulence:
        _proto = clientpb.Turbulence()
        _proto.turbulence_model = self.turbulence_model
        _proto.qcr_sa = self.qcr_sa
        _proto.qcr_sst = self.qcr_sst
        _proto.rotation_correction_sa = self.rotation_correction_sa
        _proto.turbulence_model_constants = self.turbulence_model_constants
        _proto.c_b_1.value = self.c_b_1
        _proto.sigma.value = self.sigma
        _proto.c_b_2.value = self.c_b_2
        _proto.kappa.value = self.kappa
        _proto.c_w_2.value = self.c_w_2
        _proto.c_w_3.value = self.c_w_3
        _proto.c_v_1.value = self.c_v_1
        _proto.c_t_3.value = self.c_t_3
        _proto.c_t_4.value = self.c_t_4
        _proto.c_r_1.value = self.c_r_1
        _proto.c_rot.value = self.c_rot
        _proto.sigma_k_1.value = self.sigma_k_1
        _proto.sigma_k_2.value = self.sigma_k_2
        _proto.sigma_w_1.value = self.sigma_w_1
        _proto.sigma_w_2.value = self.sigma_w_2
        _proto.beta_1.value = self.beta_1
        _proto.beta_2.value = self.beta_2
        _proto.beta_star.value = self.beta_star
        _proto.kappa_sst.value = self.kappa_sst
        _proto.a_1.value = self.a_1
        _proto.gamma_1.value = self.gamma_1
        _proto.gamma_2.value = self.gamma_2
        _proto.des_formulation = self.des_formulation
        _proto.C_sa_des.value = self.C_sa_des
        _proto.C_sst_des1.value = self.C_sst_des1
        _proto.C_sst_des2.value = self.C_sst_des2
        _proto.rans_region = self.rans_region
        _proto.zdes_rmin.CopyFrom(self.zdes_rmin._to_ad_proto())
        _proto.zdes_rmax.CopyFrom(self.zdes_rmax._to_ad_proto())
        _proto.sub_grid_scale_model = self.sub_grid_scale_model
        _proto.c_s.value = self.c_s
        _proto.c_vreman.value = self.c_vreman
        _proto.c_wale.value = self.c_wale
        _proto.c_sigma.value = self.c_sigma
        _proto.c_amd.value = self.c_amd
        _proto.turbulent_thermal_conductivity_prandtl_constant.value = (
            self.turbulent_thermal_conductivity_prandtl_constant
        )
        _proto.transition_model = self.transition_model
        _proto.transition_model_cross_flow = self.transition_model_cross_flow
        _proto.transition_free_stream_turbulence_intensity.value = (
            self.transition_free_stream_turbulence_intensity
        )
        return _proto

    def _from_proto(self, proto: clientpb.Turbulence):
        self.turbulence_model = enum.TurbulenceModel(proto.turbulence_model)
        self.qcr_sa = enum.QcrSa(proto.qcr_sa)
        self.qcr_sst = enum.QcrSst(proto.qcr_sst)
        self.rotation_correction_sa = enum.RotationCorrectionSa(proto.rotation_correction_sa)
        self.turbulence_model_constants = enum.TurbulenceModelConstants(
            proto.turbulence_model_constants
        )
        self.c_b_1 = proto.c_b_1.value
        self.sigma = proto.sigma.value
        self.c_b_2 = proto.c_b_2.value
        self.kappa = proto.kappa.value
        self.c_w_2 = proto.c_w_2.value
        self.c_w_3 = proto.c_w_3.value
        self.c_v_1 = proto.c_v_1.value
        self.c_t_3 = proto.c_t_3.value
        self.c_t_4 = proto.c_t_4.value
        self.c_r_1 = proto.c_r_1.value
        self.c_rot = proto.c_rot.value
        self.sigma_k_1 = proto.sigma_k_1.value
        self.sigma_k_2 = proto.sigma_k_2.value
        self.sigma_w_1 = proto.sigma_w_1.value
        self.sigma_w_2 = proto.sigma_w_2.value
        self.beta_1 = proto.beta_1.value
        self.beta_2 = proto.beta_2.value
        self.beta_star = proto.beta_star.value
        self.kappa_sst = proto.kappa_sst.value
        self.a_1 = proto.a_1.value
        self.gamma_1 = proto.gamma_1.value
        self.gamma_2 = proto.gamma_2.value
        self.des_formulation = enum.DesFormulation(proto.des_formulation)
        self.C_sa_des = proto.C_sa_des.value
        self.C_sst_des1 = proto.C_sst_des1.value
        self.C_sst_des2 = proto.C_sst_des2.value
        self.rans_region = enum.RansRegion(proto.rans_region)
        self.zdes_rmin._from_ad_proto(proto.zdes_rmin)
        self.zdes_rmax._from_ad_proto(proto.zdes_rmax)
        self.sub_grid_scale_model = enum.SubGridScaleModel(proto.sub_grid_scale_model)
        self.c_s = proto.c_s.value
        self.c_vreman = proto.c_vreman.value
        self.c_wale = proto.c_wale.value
        self.c_sigma = proto.c_sigma.value
        self.c_amd = proto.c_amd.value
        self.turbulent_thermal_conductivity_prandtl_constant = (
            proto.turbulent_thermal_conductivity_prandtl_constant.value
        )
        self.transition_model = enum.TransitionModel(proto.transition_model)
        self.transition_model_cross_flow = enum.TransitionModelCrossFlow(
            proto.transition_model_cross_flow
        )
        self.transition_free_stream_turbulence_intensity = (
            proto.transition_free_stream_turbulence_intensity.value
        )


@dataclass(kw_only=True)
class SolutionControlsFluid(ParamGroupWrapper[clientpb.SolutionControlsFluid]):
    """Solution controls for a fluid flow physics solver."""

    pseudo_time_step_method: enum.PseudoTimeStepMethod = enum.PseudoTimeStepMethod.CFL_BASED
    "Method for obtaining the pseudo time step in a steady-state simulation or for the inner iterations of the dual time stepping method."
    cfl: float = 50.0
    "Courant-Friedrichs-Lewy (CFL) number."
    pseudo_time_step_val: float = 1e-06
    "The fixed pseudo time step."
    local_time_stepping: enum.LocalTimeStepping = enum.LocalTimeStepping.LOCAL_TIME_STEPPING_ON
    "Compute local time steps in each control volume to accelerate convergence of steady-state simulations or the inner iterations of time-accurate simulations with dual time stepping."
    relaxation_method: enum.RelaxationMethod = enum.RelaxationMethod.IMPLICIT
    "Relaxation scheme for steady-state simulations or time implicit transient simulations."
    implicit_method: enum.ImplicitMethod = enum.ImplicitMethod.BACKWARD_EULER
    "Scheme for implicit relaxation of the governing equations."
    explicit_method: enum.ExplicitMethod = enum.ExplicitMethod.RK_4
    "Scheme for explicit relaxation or explicit time-accurate integration of the governing equations."
    linear_solver_type: enum.LinearSolverType = enum.LinearSolverType.GS
    "Type of linear solver used for implicit relaxation."
    linsol_iterations: int = 15
    "Maximum number of linear solver iterations per nonlinear solution update. The linear solver terminates if the maximum is reached."
    linsol_tolerance: float = 0.01
    "Relative reduction target in the linear solver residual from an initial value of 1.0 per nonlinear solution update. The linear solver terminates if the tolerance is met."
    linsol_amg_pre_sweeps: int = 1
    "Linear Solver AMG Pre-Sweeps"
    linsol_amg_post_sweeps: int = 1
    "Linear Solver AMG Post-Sweeps"
    linsol_amg_coarsening_size: int = 8
    "Linear Solver AMG Coarsening Sizing"
    linsol_amg_levels: int = 20
    "Linear Solver AMG Level"
    linsol_amg_relaxation: float = 0.75
    "Linear Solver AMG Relaxation applied to the smoother."
    linsol_amg_cycle_type: enum.LinsolAmgCycleType = enum.LinsolAmgCycleType.LINSOL_AMG_CYCLE_TYPE_V
    "AMG cycle type"
    linsol_amg_freeze_levels_threshold: int = 300
    "Iteration at which the AMG levels are freezed."
    linsol_amg_smoother: enum.LinsolAmgSmoother = enum.LinsolAmgSmoother.LINSOL_AMG_SMOOTHER_JACOBI
    "AMG cycle smoother"
    jacobian_update_method: enum.JacobianUpdateMethod = (
        enum.JacobianUpdateMethod.EXPLICIT_INTERVAL_AND_WARMUP
    )
    "Method for determining how often to "
    jacobian_update_interval: float = 1.0
    "How many iterations in between updating the Jacobian values for implicit solving."
    jacobian_warmup_threshold: int = 300
    "How many iterations to update Jacobians every iteration before switching to the specified 'Jacobian Update Interval'"
    robust_startup: enum.RobustStartup = enum.RobustStartup.ROBUST_STARTUP_ON
    "Applies a robust startup process during the initial transients of a simulation. Applicable to steady problems only."
    robust_startup_initial_cfl: float = 1.0
    "Initial CFL number for robust startup mode. The CFL is ramped toward the target value during startup."
    robust_startup_iterations: int = 300
    "Number of iterations over which to apply the robust startup process."
    relax_flow: float = 1.0
    "Under-relaxation factor in [0,1] applied to the mean flow solution update with each implicit nonlinear iteration. Default of 1.0."
    relax_turb: float = 0.5
    "Under-relaxation factor in [0,1] applied to the turbulence model solution update with each implicit nonlinear iteration. Default of 0.5."
    update_limit_flow: float = 0.2
    "Allowable percent change in the mean flow solution variables (pressure, temperature) with each implicit nonlinear iteration. Values in [0,1] with a default of 0.2."
    update_limit_turb: float = 0.99
    "Allowable percent change in the turbulence solution variables with each implicit nonlinear iteration. Values in [0,1] with a default of 0.99."
    controls_preset_version: int = 0
    ""
    solution_controls_fluid_preset: enum.SolutionControlsFluidPreset = (
        enum.SolutionControlsFluidPreset.DEFAULT_SOLUTION_CONTROLS_FLUID
    )
    "Select suggested control settings or allow a custom choice. In general, assume a trade-off between speed and robustness (i.e. the ability to converge)."

    def _to_proto(self) -> clientpb.SolutionControlsFluid:
        _proto = clientpb.SolutionControlsFluid()
        _proto.pseudo_time_step_method = self.pseudo_time_step_method
        _proto.cfl.value = self.cfl
        _proto.pseudo_time_step_val.value = self.pseudo_time_step_val
        _proto.local_time_stepping = self.local_time_stepping
        _proto.relaxation_method = self.relaxation_method
        _proto.implicit_method = self.implicit_method
        _proto.explicit_method = self.explicit_method
        _proto.linear_solver_type = self.linear_solver_type
        _proto.linsol_iterations.value = self.linsol_iterations
        _proto.linsol_tolerance.value = self.linsol_tolerance
        _proto.linsol_amg_pre_sweeps.value = self.linsol_amg_pre_sweeps
        _proto.linsol_amg_post_sweeps.value = self.linsol_amg_post_sweeps
        _proto.linsol_amg_coarsening_size.value = self.linsol_amg_coarsening_size
        _proto.linsol_amg_levels.value = self.linsol_amg_levels
        _proto.linsol_amg_relaxation.value = self.linsol_amg_relaxation
        _proto.linsol_amg_cycle_type = self.linsol_amg_cycle_type
        _proto.linsol_amg_freeze_levels_threshold.value = self.linsol_amg_freeze_levels_threshold
        _proto.linsol_amg_smoother = self.linsol_amg_smoother
        _proto.jacobian_update_method = self.jacobian_update_method
        _proto.jacobian_update_interval.value = self.jacobian_update_interval
        _proto.jacobian_warmup_threshold.value = self.jacobian_warmup_threshold
        _proto.robust_startup = self.robust_startup
        _proto.robust_startup_initial_cfl.value = self.robust_startup_initial_cfl
        _proto.robust_startup_iterations.value = self.robust_startup_iterations
        _proto.relax_flow.value = self.relax_flow
        _proto.relax_turb.value = self.relax_turb
        _proto.update_limit_flow.value = self.update_limit_flow
        _proto.update_limit_turb.value = self.update_limit_turb
        _proto.controls_preset_version.value = self.controls_preset_version
        _proto.solution_controls_fluid_preset = self.solution_controls_fluid_preset
        return _proto

    def _from_proto(self, proto: clientpb.SolutionControlsFluid):
        self.pseudo_time_step_method = enum.PseudoTimeStepMethod(proto.pseudo_time_step_method)
        self.cfl = proto.cfl.value
        self.pseudo_time_step_val = proto.pseudo_time_step_val.value
        self.local_time_stepping = enum.LocalTimeStepping(proto.local_time_stepping)
        self.relaxation_method = enum.RelaxationMethod(proto.relaxation_method)
        self.implicit_method = enum.ImplicitMethod(proto.implicit_method)
        self.explicit_method = enum.ExplicitMethod(proto.explicit_method)
        self.linear_solver_type = enum.LinearSolverType(proto.linear_solver_type)
        self.linsol_iterations = proto.linsol_iterations.value
        self.linsol_tolerance = proto.linsol_tolerance.value
        self.linsol_amg_pre_sweeps = proto.linsol_amg_pre_sweeps.value
        self.linsol_amg_post_sweeps = proto.linsol_amg_post_sweeps.value
        self.linsol_amg_coarsening_size = proto.linsol_amg_coarsening_size.value
        self.linsol_amg_levels = proto.linsol_amg_levels.value
        self.linsol_amg_relaxation = proto.linsol_amg_relaxation.value
        self.linsol_amg_cycle_type = enum.LinsolAmgCycleType(proto.linsol_amg_cycle_type)
        self.linsol_amg_freeze_levels_threshold = proto.linsol_amg_freeze_levels_threshold.value
        self.linsol_amg_smoother = enum.LinsolAmgSmoother(proto.linsol_amg_smoother)
        self.jacobian_update_method = enum.JacobianUpdateMethod(proto.jacobian_update_method)
        self.jacobian_update_interval = proto.jacobian_update_interval.value
        self.jacobian_warmup_threshold = proto.jacobian_warmup_threshold.value
        self.robust_startup = enum.RobustStartup(proto.robust_startup)
        self.robust_startup_initial_cfl = proto.robust_startup_initial_cfl.value
        self.robust_startup_iterations = proto.robust_startup_iterations.value
        self.relax_flow = proto.relax_flow.value
        self.relax_turb = proto.relax_turb.value
        self.update_limit_flow = proto.update_limit_flow.value
        self.update_limit_turb = proto.update_limit_turb.value
        self.controls_preset_version = proto.controls_preset_version.value
        self.solution_controls_fluid_preset = enum.SolutionControlsFluidPreset(
            proto.solution_controls_fluid_preset
        )


@dataclass(kw_only=True)
class AdjointControlsFluid(ParamGroupWrapper[clientpb.AdjointControlsFluid]):
    """"""

    adjoint_solution_method: enum.AdjointSolutionMethod = (
        enum.AdjointSolutionMethod.ADJOINT_METHOD_GMRES
    )
    "The method used to solve the discrete adjoint equations."
    adjoint_gmres_restart_iters: int = 50
    "Number of iterations between GMRES restarts. A larger period makes the method more effective for tougher problems (for example incompressible flows), but increases the computational cost."
    adjoint_second_order_damping: float = 0
    "Simplify the adjoint equations (at the expense of accuracy) by reducing the blend between first-order and second-order convective schemes used in the primal simulation."
    adjoint_frozen_turbulence: bool = False
    "Simplify the adjoint equations (at the expense of accuracy) by assuming that eddy viscosity does not depend on the turbulence variables."
    adjoint_frozen_transition: bool = False
    "Simplify the adjoint equations (at the expense of accuracy) by assuming that turbulence variables are not affected by turbulence intermittency (γ)."

    def _to_proto(self) -> clientpb.AdjointControlsFluid:
        _proto = clientpb.AdjointControlsFluid()
        _proto.adjoint_solution_method = self.adjoint_solution_method
        _proto.adjoint_gmres_restart_iters.value = self.adjoint_gmres_restart_iters
        _proto.adjoint_second_order_damping.value = self.adjoint_second_order_damping
        if self.adjoint_frozen_turbulence is not None:
            _proto.adjoint_frozen_turbulence = self.adjoint_frozen_turbulence
        if self.adjoint_frozen_transition is not None:
            _proto.adjoint_frozen_transition = self.adjoint_frozen_transition
        return _proto

    def _from_proto(self, proto: clientpb.AdjointControlsFluid):
        self.adjoint_solution_method = enum.AdjointSolutionMethod(proto.adjoint_solution_method)
        self.adjoint_gmres_restart_iters = proto.adjoint_gmres_restart_iters.value
        self.adjoint_second_order_damping = proto.adjoint_second_order_damping.value
        self.adjoint_frozen_turbulence = proto.adjoint_frozen_turbulence
        self.adjoint_frozen_transition = proto.adjoint_frozen_transition


@dataclass(kw_only=True)
class SpatialDiscretizationFluid(ParamGroupWrapper[clientpb.SpatialDiscretizationFluid]):
    """Spatial discretization settings for a fluid flow physics solver."""

    gradient_method: enum.GradientMethod = enum.GradientMethod.HLSQ
    "Method for computing the spatial gradients of fluid variables."
    hlsq_blend: float = 1.7
    "Blending parameter in the hybrid least squares gradient methods in [1,2]."
    convective_schemes_density_based: enum.ConvectiveSchemesDensityBased = (
        enum.ConvectiveSchemesDensityBased.ROE
    )
    "Type of scheme for discretizing the convective terms of the fluid equations."
    entropy_epsilon: float = 2.0
    "Epsilon factor for the entropy fix of Harten."
    alpha_hybrid: float = 1.0
    "Upwind weight in the hybrid central-upwind scheme in [0,1]."
    skew_symmetric_formulation: enum.SkewSymmetricFormulation = (
        enum.SkewSymmetricFormulation.CHANDRASEKHAR_EC2
    )
    "Choice among skew-symmetric formulations."
    artificial_viscosity_model: enum.ArtificialViscosityModel = (
        enum.ArtificialViscosityModel.NO_MODEL
    )
    "Artificial viscosity for shock and interface capturing."
    upwind_scheme_order: enum.UpwindSchemeOrder = enum.UpwindSchemeOrder.SECOND
    "Spatial order of accuracy of the convective scheme used for the fluid equations."
    robust_dissipation: enum.RobustDissipation = enum.RobustDissipation.ROBUST_DISS_OFF
    "Use a form of dissipation that improves robustness but that may reduce accuracy."
    limiter: enum.Limiter = enum.Limiter.NO_LIMITER
    "Apply a slope limiter for second-order upwind schemes. This tends to increase robustness at the expense of solution time and higher dissipation in regions of the flow with sharp gradients. For this reason, it may be helpful to increase gradient blending parameters when using limiters."
    limiter_kappa: float = 0.1
    "Parameter defining smooth flow regions where the limiter is disabled, and also where less robust dissipation is applied (if enabled). Higher values reduce limiting and/or dissipation."
    umuscl_chi: float = 0.0
    "Chi parameter of the U-MUSCL variable extrapolation scheme in (-1,1)."
    alpha_ld2: float = 0.0
    "Parameter in range [0,1], generally 0 is more robust and 1 more accurate, thus it should be used on high quality grids with gentle stretching. On uniform meshes 0 gives a 2nd order reconstruction, and 2/3 gives a 4th order reconstruction. With the value 1, 2nd order is also obtained on non uniform meshes."
    geometry_fixes: enum.GeometryFixes = enum.GeometryFixes.GEOMETRY_FIXES_ON
    "Strategies to cope with problematic mesh regions (e.g. high skewness angles)."
    geometry_fixes_mitigations: float = 0.25
    "Magnitude of the geometrical fixes mitigations. Expected value within [0,1]. The higher this value, the more numerical dissipation is added at control volumes with low-quality topological properties."
    order_blend: float = 1.0
    "Blend factor in [0,1] between a first-order and second-order convective scheme. A value of 0 results in a first-order scheme, and a value of 1.0 results in a second-order scheme. 1.0 by default. A value less than 1.0 may improve robustness at the cost of accuracy compared to a pure second-order scheme."
    preconditioning: enum.Preconditioning = enum.Preconditioning.PRECONDITIONING_ON
    "Apply low-speed preconditioning to obtain Mach number-independent solutions for ideal gases."
    discretization_preset_version: int = 0
    ""
    spatial_discretization_fluid_preset: enum.SpatialDiscretizationFluidPreset = (
        enum.SpatialDiscretizationFluidPreset.DEFAULT_SPATIAL_DISCRETIZATION_FLUID
    )
    "Select suggested control settings or allow a custom choice. In general, assume a trade-off between accuracy and robustness (i.e. the ability to converge)."
    fds_min_low_dissipation: float = 0.05
    "Lower bound on the factor multiplying the FDS dissipation term for scale-resolving problems in [0,1]."

    def _to_proto(self) -> clientpb.SpatialDiscretizationFluid:
        _proto = clientpb.SpatialDiscretizationFluid()
        _proto.gradient_method = self.gradient_method
        _proto.hlsq_blend.value = self.hlsq_blend
        _proto.convective_schemes_density_based = self.convective_schemes_density_based
        _proto.entropy_epsilon.value = self.entropy_epsilon
        _proto.alpha_hybrid.value = self.alpha_hybrid
        _proto.skew_symmetric_formulation = self.skew_symmetric_formulation
        _proto.artificial_viscosity_model = self.artificial_viscosity_model
        _proto.upwind_scheme_order = self.upwind_scheme_order
        _proto.robust_dissipation = self.robust_dissipation
        _proto.limiter = self.limiter
        _proto.limiter_kappa.value = self.limiter_kappa
        _proto.umuscl_chi.value = self.umuscl_chi
        _proto.alpha_ld2.value = self.alpha_ld2
        _proto.geometry_fixes = self.geometry_fixes
        _proto.geometry_fixes_mitigations.value = self.geometry_fixes_mitigations
        _proto.order_blend.value = self.order_blend
        _proto.preconditioning = self.preconditioning
        _proto.discretization_preset_version.value = self.discretization_preset_version
        _proto.spatial_discretization_fluid_preset = self.spatial_discretization_fluid_preset
        _proto.fds_min_low_dissipation.value = self.fds_min_low_dissipation
        return _proto

    def _from_proto(self, proto: clientpb.SpatialDiscretizationFluid):
        self.gradient_method = enum.GradientMethod(proto.gradient_method)
        self.hlsq_blend = proto.hlsq_blend.value
        self.convective_schemes_density_based = enum.ConvectiveSchemesDensityBased(
            proto.convective_schemes_density_based
        )
        self.entropy_epsilon = proto.entropy_epsilon.value
        self.alpha_hybrid = proto.alpha_hybrid.value
        self.skew_symmetric_formulation = enum.SkewSymmetricFormulation(
            proto.skew_symmetric_formulation
        )
        self.artificial_viscosity_model = enum.ArtificialViscosityModel(
            proto.artificial_viscosity_model
        )
        self.upwind_scheme_order = enum.UpwindSchemeOrder(proto.upwind_scheme_order)
        self.robust_dissipation = enum.RobustDissipation(proto.robust_dissipation)
        self.limiter = enum.Limiter(proto.limiter)
        self.limiter_kappa = proto.limiter_kappa.value
        self.umuscl_chi = proto.umuscl_chi.value
        self.alpha_ld2 = proto.alpha_ld2.value
        self.geometry_fixes = enum.GeometryFixes(proto.geometry_fixes)
        self.geometry_fixes_mitigations = proto.geometry_fixes_mitigations.value
        self.order_blend = proto.order_blend.value
        self.preconditioning = enum.Preconditioning(proto.preconditioning)
        self.discretization_preset_version = proto.discretization_preset_version.value
        self.spatial_discretization_fluid_preset = enum.SpatialDiscretizationFluidPreset(
            proto.spatial_discretization_fluid_preset
        )
        self.fds_min_low_dissipation = proto.fds_min_low_dissipation.value


@dataclass(kw_only=True)
class BoundaryConditionsFluid(ParamGroupWrapper[clientpb.BoundaryConditionsFluid]):
    """Boundary conditions for a fluid flow physics solver."""

    surfaces: list[str] = field(default_factory=list)
    ""
    name: str = ""
    ""

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = clientpb.BoundaryConditionsFluid()
        if self.surfaces is not None:
            _proto.surfaces.extend(self.surfaces)
        if self.name is not None:
            _proto.boundary_condition_name = self.name
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        self.surfaces.extend(proto.surfaces)
        self.name = proto.boundary_condition_name


@dataclass(kw_only=True)
class Wall(BoundaryConditionsFluid):
    """Wall boundary condition."""

    momentum: enum.WallMomentum = enum.WallMomentum.NO_SLIP
    "Condition applied to the momentum equations at a solid wall boundary."
    energy_condition: enum.WallEnergy = enum.WallEnergy.FIXED_HEAT_FLUX
    "Condition applied to the energy equation at a solid wall boundary."
    fixed_heat_flux: float = 0.0
    "Heat flux per unit area at wall boundary surfaces. Negative values increase temperatures at the wall while positive values decrease it. Enter 0 for an adiabatic wall."
    fixed_temperature: float = 288.15
    "Temperature at the wall boundary surfaces."
    enable_roughness: bool = False
    "Turn roughness settings on or off."
    roughness_height: float = 0
    "Equivalent sand-grain roughness of the wall."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.WALL
        _proto.wall_momentum = self.momentum
        _proto.wall_energy = self.energy_condition
        _proto.fixed_heat_flux.value = self.fixed_heat_flux
        _proto.fixed_temperature.value = self.fixed_temperature
        if self.enable_roughness is not None:
            _proto.roughness_control = self.enable_roughness
        _proto.equivalent_sand_grain_roughness.value = self.roughness_height
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.WALL
        self.momentum = enum.WallMomentum(proto.wall_momentum)
        self.energy_condition = enum.WallEnergy(proto.wall_energy)
        self.fixed_heat_flux = proto.fixed_heat_flux.value
        self.fixed_temperature = proto.fixed_temperature.value
        self.enable_roughness = proto.roughness_control
        self.roughness_height = proto.equivalent_sand_grain_roughness.value


@dataclass(kw_only=True)
class TurbulenceSpecificationSpalartAllmaras:
    """Spalart-Allmaras turbulence specification."""

    method: enum.TurbulenceSpecificationSpalartAllmaras = (
        enum.TurbulenceSpecificationSpalartAllmaras.TURBULENT_VISCOSITY_RATIO_SA
    )
    "Condition applied to the Spalart-Allmaras turbulence equation at the boundary."
    viscosity: float = 3.765582173541416e-06
    "Turbulent viscosity at the boundary."
    viscosity_ratio: float = 0.21043825715555026
    "Turbulent-to-laminar viscosity ratio at the boundary."
    bc_uniform_nu_tilde: float = 4.166705541552236e-05
    "Uniform boundary condition value for the Spalart-Allmaras turbulence variable."


@dataclass(kw_only=True)
class TurbulenceSpecificationKomega:
    """K-omega turbulence specification."""

    method: enum.TurbulenceSpecificationKomega = (
        enum.TurbulenceSpecificationKomega.BC_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
    )
    "Condition applied to the k-ω turbulence variables at the boundary."
    intensity: float = 0.05
    "Turbulence intensity at the boundary."
    viscosity: float = 3.765582173541416e-06
    "Turbulent viscosity at the boundary."
    viscosity_ratio: float = 0.21043825715555026
    "Turbulent-to-laminar viscosity ratio at the boundary."
    bc_uniform_tke: float = 4.166705541552236e-05
    "Uniform boundary condition value for the turbulent kinetic energy variable."
    bc_uniform_omega: float = 4.166705541552236e-05
    "Uniform boundary condition value for the specific dissipation rate variable."


@dataclass(kw_only=True)
class TurbulenceSpecification:
    """Turbulence specification."""

    turbulence_specification_spalart_allmaras: Optional[TurbulenceSpecificationSpalartAllmaras] = (
        field(default_factory=TurbulenceSpecificationSpalartAllmaras)
    )
    "Spalart-Allmaras turbulence specification."
    turbulence_specification_komega: Optional[TurbulenceSpecificationKomega] = field(
        default_factory=TurbulenceSpecificationKomega
    )
    "K-omega turbulence specification."


@dataclass(kw_only=True)
class Inlet(BoundaryConditionsFluid):
    """Inlet boundary condition."""

    turbulence_specification: Optional[TurbulenceSpecification] = field(
        default_factory=TurbulenceSpecification
    )
    "Turbulence specification."
    total_temperature: float = 300
    "Total temperature at the inlet boundary."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.INLET
        _proto.turbulence_specification_spalart_allmaras = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.method
        )
        _proto.turbulent_viscosity.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity
        )
        _proto.turbulent_viscosity_ratio.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity_ratio
        )
        _proto.bc_uniform_nu_tilde.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.bc_uniform_nu_tilde
        )
        _proto.turbulence_specification_komega = (
            self.turbulence_specification.turbulence_specification_komega.method
        )
        _proto.turbulence_intensity.value = (
            self.turbulence_specification.turbulence_specification_komega.intensity
        )
        _proto.turbulent_viscosity.value = (
            self.turbulence_specification.turbulence_specification_komega.viscosity
        )
        _proto.turbulent_viscosity_ratio.value = (
            self.turbulence_specification.turbulence_specification_komega.viscosity_ratio
        )
        _proto.bc_uniform_tke.value = (
            self.turbulence_specification.turbulence_specification_komega.bc_uniform_tke
        )
        _proto.bc_uniform_omega.value = (
            self.turbulence_specification.turbulence_specification_komega.bc_uniform_omega
        )
        _proto.total_temperature.value = self.total_temperature
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.INLET
        self.turbulence_specification.turbulence_specification_spalart_allmaras.method = (
            enum.TurbulenceSpecificationSpalartAllmaras(
                proto.turbulence_specification_spalart_allmaras
            )
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity = (
            proto.turbulent_viscosity.value
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity_ratio = (
            proto.turbulent_viscosity_ratio.value
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.bc_uniform_nu_tilde = (
            proto.bc_uniform_nu_tilde.value
        )
        self.turbulence_specification.turbulence_specification_komega.method = (
            enum.TurbulenceSpecificationKomega(proto.turbulence_specification_komega)
        )
        self.turbulence_specification.turbulence_specification_komega.intensity = (
            proto.turbulence_intensity.value
        )
        self.turbulence_specification.turbulence_specification_komega.viscosity = (
            proto.turbulent_viscosity.value
        )
        self.turbulence_specification.turbulence_specification_komega.viscosity_ratio = (
            proto.turbulent_viscosity_ratio.value
        )
        self.turbulence_specification.turbulence_specification_komega.bc_uniform_tke = (
            proto.bc_uniform_tke.value
        )
        self.turbulence_specification.turbulence_specification_komega.bc_uniform_omega = (
            proto.bc_uniform_omega.value
        )
        self.total_temperature = proto.total_temperature.value


@dataclass(kw_only=True)
class VelocityMagnitudeInlet(Inlet):
    """Velocity magnitude inlet boundary condition."""

    magnitude: float = 1.0
    "Velocity magnitude at the inlet boundary."
    direction: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Vector (x,y,z) defining the flow direction. Automatically scaled to a unit vector internally."
    direction_specification: enum.DirectionSpecification = (
        enum.DirectionSpecification.NORMAL_TO_BOUNDARY
    )
    "Method of defining the flow direction at the inlet."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.inlet_momentum = enum.InletMomentum.VELOCITY_INLET
        _proto.inlet_velocity_magnitude.value = self.magnitude
        _proto.flow_direction.CopyFrom(self.direction._to_ad_proto())
        _proto.direction_specification = self.direction_specification
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.inlet_momentum == enum.InletMomentum.VELOCITY_INLET
        self.magnitude = proto.inlet_velocity_magnitude.value
        self.direction._from_ad_proto(proto.flow_direction)
        self.direction_specification = enum.DirectionSpecification(proto.direction_specification)


@dataclass(kw_only=True)
class VelocityComponentsInlet(Inlet):
    """Velocity components inlet boundary condition."""

    velocity: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Vector (x,y,z) defining the velocity vector."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.inlet_momentum = enum.InletMomentum.VELOCITY_COMPONENTS_INLET
        _proto.inlet_velocity_components.CopyFrom(self.velocity._to_ad_proto())
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.inlet_momentum == enum.InletMomentum.VELOCITY_COMPONENTS_INLET
        self.velocity._from_ad_proto(proto.inlet_velocity_components)


@dataclass(kw_only=True)
class TotalPressureInlet(Inlet):
    """Total pressure inlet boundary condition."""

    total_pressure: float = 101325
    "Total pressure at the boundary relative to the material reference pressure."
    direction: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Vector (x,y,z) defining the flow direction. Automatically scaled to a unit vector internally."
    direction_specification: enum.DirectionSpecification = (
        enum.DirectionSpecification.NORMAL_TO_BOUNDARY
    )
    "Method of defining the flow direction at the inlet."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.inlet_momentum = enum.InletMomentum.TOTAL_PRESSURE_INLET
        _proto.total_pressure.value = self.total_pressure
        _proto.flow_direction.CopyFrom(self.direction._to_ad_proto())
        _proto.direction_specification = self.direction_specification
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.inlet_momentum == enum.InletMomentum.TOTAL_PRESSURE_INLET
        self.total_pressure = proto.total_pressure.value
        self.direction._from_ad_proto(proto.flow_direction)
        self.direction_specification = enum.DirectionSpecification(proto.direction_specification)


@dataclass(kw_only=True)
class MassFlowInlet(Inlet):
    """Mass flow rate inlet boundary condition."""

    mass_flow_rate: float = 1.0
    "Mass flow rate at the inlet. The prescribed mass flow is imposed over the aggregate area of all surfaces listed for the inlet boundary condition. To prescribe mass flow on a per-surface basis, create multiple mass flow inlet boundary conditions, each with a single surface."
    direction: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Vector (x,y,z) defining the flow direction. Automatically scaled to a unit vector internally."
    direction_specification: enum.DirectionSpecification = (
        enum.DirectionSpecification.NORMAL_TO_BOUNDARY
    )
    "Method of defining the flow direction at the inlet."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.inlet_momentum = enum.InletMomentum.MASS_FLOW_INLET
        _proto.mass_flow_rate.value = self.mass_flow_rate
        _proto.flow_direction.CopyFrom(self.direction._to_ad_proto())
        _proto.direction_specification = self.direction_specification
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.inlet_momentum == enum.InletMomentum.MASS_FLOW_INLET
        self.mass_flow_rate = proto.mass_flow_rate.value
        self.direction._from_ad_proto(proto.flow_direction)
        self.direction_specification = enum.DirectionSpecification(proto.direction_specification)


@dataclass(kw_only=True)
class Outlet(BoundaryConditionsFluid):
    """Outlet boundary condition."""

    strategy: enum.OutletStrategy = enum.OutletStrategy.OUTLET_PRESSURE
    "Outlet strategy."
    static_pressure: float = 101325.0
    "Static pressure at the boundary relative to the material reference pressure. Also used as initial estimate to establish the target mass flow rate if requested."
    pressure_constraint: enum.OutletPressureConstraint = (
        enum.OutletPressureConstraint.OUTLET_LOCAL_CONSTRAINT
    )
    "Mode of imposing pressure at the outlet."
    target_mass_flow_rate: float = 1.0
    "Target mass flow rate (or corrected mass flow rate)."
    reference_pressure: float = 101325.0
    "Absolute total pressure used to compute the corrected mass flow target."
    reference_temperature: float = 288.15
    "Total temperature used to compute the corrected mass flow target."
    head_loss_coefficient: float = 0.0
    "Fraction of dynamic pressure lost through the fan."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.OUTLET
        _proto.outlet_strategy = self.strategy
        _proto.outlet_pressure.value = self.static_pressure
        _proto.outlet_pressure_constraint = self.pressure_constraint
        _proto.outlet_target_mass_flow_rate.value = self.target_mass_flow_rate
        _proto.outlet_reference_pressure.value = self.reference_pressure
        _proto.outlet_reference_temperature.value = self.reference_temperature
        _proto.head_loss_coefficient.value = self.head_loss_coefficient
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.OUTLET
        self.strategy = enum.OutletStrategy(proto.outlet_strategy)
        self.static_pressure = proto.outlet_pressure.value
        self.pressure_constraint = enum.OutletPressureConstraint(proto.outlet_pressure_constraint)
        self.target_mass_flow_rate = proto.outlet_target_mass_flow_rate.value
        self.reference_pressure = proto.outlet_reference_pressure.value
        self.reference_temperature = proto.outlet_reference_temperature.value
        self.head_loss_coefficient = proto.head_loss_coefficient.value


@dataclass(kw_only=True)
class Symmetry(BoundaryConditionsFluid):
    """Symmetry boundary condition."""

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.SYMMETRY
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.SYMMETRY


@dataclass(kw_only=True)
class Farfield(BoundaryConditionsFluid):
    """Farfield boundary condition."""

    static_pressure: float = 101325
    "Static pressure at the boundary relative to the material reference pressure."
    mach_number: float = 0.5
    "Mach number at the boundary."
    temperature: float = 288.15
    "Static temperature at the boundary."
    flow_direction_specification: enum.FarFieldFlowDirectionSpecification = (
        enum.FarFieldFlowDirectionSpecification.FARFIELD_DIRECTION
    )
    "Method of defining the flow direction at the far-field."
    velocity_magnitude: float = 1.0
    "Velocity magnitude at the far-field boundary."
    flow_direction: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Vector specifying the flow direction at the far-field boundary. Automatically scaled to a unit vector internally."
    angle_alpha: float = 0.0
    "Angle of attack. Positive angle of attack results in a non-zero far-field velocity component in the negative body-z direction."
    angle_beta: float = 0.0
    "Angle of sideslip. Positive angle of sideslip results in a non-zero far-field velocity component in the positive body-y direction."
    turbulence_specification: Optional[TurbulenceSpecification] = field(
        default_factory=TurbulenceSpecification
    )
    "Turbulence specification."

    def _to_proto(self) -> clientpb.BoundaryConditionsFluid:
        _proto = super()._to_proto()
        _proto.physical_boundary = enum.PhysicalBoundary.FARFIELD
        _proto.farfield_pressure.value = self.static_pressure
        _proto.farfield_mach_number.value = self.mach_number
        _proto.farfield_temperature.value = self.temperature
        _proto.far_field_flow_direction_specification = self.flow_direction_specification
        _proto.farfield_velocity_magnitude.value = self.velocity_magnitude
        _proto.farfield_flow_direction.CopyFrom(self.flow_direction._to_ad_proto())
        _proto.farfield_angle_alpha.value = self.angle_alpha
        _proto.farfield_angle_beta.value = self.angle_beta
        _proto.turbulence_specification_spalart_allmaras = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.method
        )
        _proto.turbulent_viscosity.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity
        )
        _proto.turbulent_viscosity_ratio.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity_ratio
        )
        _proto.bc_uniform_nu_tilde.value = (
            self.turbulence_specification.turbulence_specification_spalart_allmaras.bc_uniform_nu_tilde
        )
        _proto.turbulence_specification_komega = (
            self.turbulence_specification.turbulence_specification_komega.method
        )
        _proto.turbulence_intensity.value = (
            self.turbulence_specification.turbulence_specification_komega.intensity
        )
        _proto.turbulent_viscosity.value = (
            self.turbulence_specification.turbulence_specification_komega.viscosity
        )
        _proto.turbulent_viscosity_ratio.value = (
            self.turbulence_specification.turbulence_specification_komega.viscosity_ratio
        )
        _proto.bc_uniform_tke.value = (
            self.turbulence_specification.turbulence_specification_komega.bc_uniform_tke
        )
        _proto.bc_uniform_omega.value = (
            self.turbulence_specification.turbulence_specification_komega.bc_uniform_omega
        )
        return _proto

    def _from_proto(self, proto: clientpb.BoundaryConditionsFluid):
        super()._from_proto(proto)
        assert proto.physical_boundary == enum.PhysicalBoundary.FARFIELD
        self.static_pressure = proto.farfield_pressure.value
        self.mach_number = proto.farfield_mach_number.value
        self.temperature = proto.farfield_temperature.value
        self.flow_direction_specification = enum.FarFieldFlowDirectionSpecification(
            proto.far_field_flow_direction_specification
        )
        self.velocity_magnitude = proto.farfield_velocity_magnitude.value
        self.flow_direction._from_ad_proto(proto.farfield_flow_direction)
        self.angle_alpha = proto.farfield_angle_alpha.value
        self.angle_beta = proto.farfield_angle_beta.value
        self.turbulence_specification.turbulence_specification_spalart_allmaras.method = (
            enum.TurbulenceSpecificationSpalartAllmaras(
                proto.turbulence_specification_spalart_allmaras
            )
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity = (
            proto.turbulent_viscosity.value
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.viscosity_ratio = (
            proto.turbulent_viscosity_ratio.value
        )
        self.turbulence_specification.turbulence_specification_spalart_allmaras.bc_uniform_nu_tilde = (
            proto.bc_uniform_nu_tilde.value
        )
        self.turbulence_specification.turbulence_specification_komega.method = (
            enum.TurbulenceSpecificationKomega(proto.turbulence_specification_komega)
        )
        self.turbulence_specification.turbulence_specification_komega.intensity = (
            proto.turbulence_intensity.value
        )
        self.turbulence_specification.turbulence_specification_komega.viscosity = (
            proto.turbulent_viscosity.value
        )
        self.turbulence_specification.turbulence_specification_komega.viscosity_ratio = (
            proto.turbulent_viscosity_ratio.value
        )
        self.turbulence_specification.turbulence_specification_komega.bc_uniform_tke = (
            proto.bc_uniform_tke.value
        )
        self.turbulence_specification.turbulence_specification_komega.bc_uniform_omega = (
            proto.bc_uniform_omega.value
        )


@dataclass(kw_only=True)
class InitializationFluid(ParamGroupWrapper[clientpb.InitializationFluid]):
    """Initialization settings for a fluid flow physics solver."""

    initialization_type: enum.InitializationType = enum.InitializationType.UNIFORM_VALUES
    "Type of initial condition for the field variables."
    existing_solution_id: str = ""
    "ID for the existing solution to use for initialization."
    verification_solutions: enum.VerificationSolutions = (
        enum.VerificationSolutions.TAYLOR_GREEN_VORTEX
    )
    "Predefined verification problems built into the solver."
    potential_flow_pressure_initialization: enum.PotentialFlowPressureInitialization = (
        enum.PotentialFlowPressureInitialization.INITIALIZATION_POTENTIAL_FLOW_PRESSURE_OFF
    )
    "Pressure initialization options when using potential flow initialization."
    uniform_p: float = 101325.0
    "Uniform initial condition for the static pressure relative to the material reference pressure."
    uniform_v: Vector3 = field(default_factory=lambda: Vector3(1.0, 0.0, 0.0))
    "Uniform initial condition for velocity."
    uniform_t: float = 288.15
    "Uniform initial condition for static temperature."
    turbulent_variable_initialization_type_sa: enum.TurbulentVariableInitializationTypeSa = (
        enum.TurbulentVariableInitializationTypeSa.INIT_TURBULENT_VISCOSITY_RATIO_SA
    )
    "Type of initial condition for the turbulent variables."
    turbulent_variable_initialization_type_komega: (
        enum.TurbulentVariableInitializationTypeKomega
    ) = (
        enum.TurbulentVariableInitializationTypeKomega.INIT_TURBULENT_VISCOSITY_RATIO_AND_INTENSITY_KOMEGA
    )
    "Type of initial condition for the turbulent variables."
    init_turbulent_viscosity_ratio: float = 0.21043825715555026
    "Turbulent-to-laminar viscosity ratio."
    init_turbulent_viscosity: float = 3.765582173541416e-06
    "Turbulent viscosity."
    init_turbulence_intensity: float = 0.05
    "Turbulence intensity."
    uniform_nu_tilde: float = 4.166705541552236e-05
    "Uniform initial condition for the Spalart-Allmaras turbulence variable."
    uniform_tke: float = 4.166705541552236e-05
    "Uniform initial condition for the turbulent kinetic energy variable."
    uniform_omega: float = 4.166705541552236e-05
    "Uniform initial condition for the specific dissipation rate variable."
    tgv_rho: float = 1.0
    "Initial Taylor-Green vortex density."
    tgv_p: float = 100.0
    "Initial Taylor-Green vortex pressure."
    tgv_v: float = 1.0
    "Initial Taylor-Green vortex velocity (magnitude)."
    shocktube_p1: float = 0.1
    "Initial pressure on side 1."
    shocktube_p4: float = 1.0
    "Initial pressure on side 4."
    shocktube_t1: float = 0.00278
    "Initial temperature on side 1."
    shocktube_t4: float = 0.00348
    "Initial temperature on side 4."
    shuosher_p1: float = 10.3333
    "Initial pressure on side 1."
    shuosher_rho1: float = 3.857143
    "Initial density on side 1."
    shuosher_m1: float = 3.0
    "Initial Mach Number on side 1."
    shuosher_p2: float = 1.0
    "Initial pressure on side 2."
    shuosher_rho2: float = 1.0
    "Initial density on side 2."
    shuosher_m2: float = 0.0
    "Initial Mach Number on side 2."
    shuosher_amp: float = 0.2
    "Amplitude of the entropy wave."
    shuosher_kx: float = 5.0
    "Wavenumber of the entropy wave."
    disturbancewave_p: float = 0.7143
    "Base flow pressure."
    disturbancewave_t: float = 0.0025
    "Base flow temperature."
    disturbancewave_m: float = 0.2
    "Base flow Mach number."
    acousticwave_amp: float = 0.01
    "Amplitude of the acoustic wave."
    vorticitywave_amp: float = 0.01
    "Amplitude of the vorticity wave."
    entropywave_amp: float = 0.01
    "Amplitude of the entropy wave."
    disturbancewave_kx: float = 5.0
    "Wavenumber of the disturbance wave."
    normalshock_p1: float = 0.7143
    "Initial pressure on side 1."
    normalshock_t1: float = 0.0025
    "Initial temperature on side 1."
    normalshock_m1: float = 2.0
    "Initial Mach Number on side 1."
    shockvortex_p1: float = 1.0
    "Initial pressure on side 1."
    shockvortex_t1: float = 0.0035
    "Initial temperature on side 1."
    shockvortex_m1: float = 1.5
    "Initial Mach Number on side 1."
    shockvortex_mv: float = 0.2
    "Vortex Mach Number."
    shockvortex_xv: float = 0.25
    "X-Location of vortex core center."
    shockvortex_zv: float = 0.5
    "Z-Location of vortex core center."
    shockvortex_av: float = 0.075
    "Av constant for the vortex."
    shockvortex_bv: float = 0.175
    "Bv constant for the vortex."
    mms_k: float = 3.141592653589793
    "K constant for the MMS solution."
    mms_a: float = 10.0
    "A constant for the MMS solution."
    inviscid_vortex_minfty: float = 0.05
    "Free-stream Mach number far away from the vortex."
    inviscid_vortex_pinfty: float = 100000
    "Free-stream pressure far away from the vortex."
    inviscid_vortex_tinfty: float = 300
    "Free-stream temperature far away from the vortex."
    inviscid_vortex_xv: float = 0.5
    "X-Location of vortex core center at t = 0."
    inviscid_vortex_yv: float = 0.5
    "Y-Location of vortex core center at t = 0."
    inviscid_vortex_xflowdir: float = 1.0
    "X-component of the uniform flow direction."
    inviscid_vortex_yflowdir: float = 0.0
    "Y-component of the uniform flow direction."
    inviscid_vortex_rvortex: float = 0.005
    "Characteristic radius of the vortex."
    inviscid_vortex_betavortex: float = 0.02
    "Strength of the vortex."

    def _to_proto(self) -> clientpb.InitializationFluid:
        _proto = clientpb.InitializationFluid()
        _proto.initialization_type = self.initialization_type
        if self.existing_solution_id is not None:
            _proto.existing_solution_id = self.existing_solution_id
        _proto.verification_solutions = self.verification_solutions
        _proto.potential_flow_pressure_initialization = self.potential_flow_pressure_initialization
        _proto.uniform_p.value = self.uniform_p
        _proto.uniform_v.CopyFrom(self.uniform_v._to_ad_proto())
        _proto.uniform_t.value = self.uniform_t
        _proto.turbulent_variable_initialization_type_sa = (
            self.turbulent_variable_initialization_type_sa
        )
        _proto.turbulent_variable_initialization_type_komega = (
            self.turbulent_variable_initialization_type_komega
        )
        _proto.init_turbulent_viscosity_ratio.value = self.init_turbulent_viscosity_ratio
        _proto.init_turbulent_viscosity.value = self.init_turbulent_viscosity
        _proto.init_turbulence_intensity.value = self.init_turbulence_intensity
        _proto.uniform_nu_tilde.value = self.uniform_nu_tilde
        _proto.uniform_tke.value = self.uniform_tke
        _proto.uniform_omega.value = self.uniform_omega
        _proto.tgv_rho.value = self.tgv_rho
        _proto.tgv_p.value = self.tgv_p
        _proto.tgv_v.value = self.tgv_v
        _proto.shocktube_p1.value = self.shocktube_p1
        _proto.shocktube_p4.value = self.shocktube_p4
        _proto.shocktube_t1.value = self.shocktube_t1
        _proto.shocktube_t4.value = self.shocktube_t4
        _proto.shuosher_p1.value = self.shuosher_p1
        _proto.shuosher_rho1.value = self.shuosher_rho1
        _proto.shuosher_m1.value = self.shuosher_m1
        _proto.shuosher_p2.value = self.shuosher_p2
        _proto.shuosher_rho2.value = self.shuosher_rho2
        _proto.shuosher_m2.value = self.shuosher_m2
        _proto.shuosher_amp.value = self.shuosher_amp
        _proto.shuosher_kx.value = self.shuosher_kx
        _proto.disturbancewave_p.value = self.disturbancewave_p
        _proto.disturbancewave_t.value = self.disturbancewave_t
        _proto.disturbancewave_m.value = self.disturbancewave_m
        _proto.acousticwave_amp.value = self.acousticwave_amp
        _proto.vorticitywave_amp.value = self.vorticitywave_amp
        _proto.entropywave_amp.value = self.entropywave_amp
        _proto.disturbancewave_kx.value = self.disturbancewave_kx
        _proto.normalshock_p1.value = self.normalshock_p1
        _proto.normalshock_t1.value = self.normalshock_t1
        _proto.normalshock_m1.value = self.normalshock_m1
        _proto.shockvortex_p1.value = self.shockvortex_p1
        _proto.shockvortex_t1.value = self.shockvortex_t1
        _proto.shockvortex_m1.value = self.shockvortex_m1
        _proto.shockvortex_mv.value = self.shockvortex_mv
        _proto.shockvortex_xv.value = self.shockvortex_xv
        _proto.shockvortex_zv.value = self.shockvortex_zv
        _proto.shockvortex_av.value = self.shockvortex_av
        _proto.shockvortex_bv.value = self.shockvortex_bv
        _proto.mms_k.value = self.mms_k
        _proto.mms_a.value = self.mms_a
        _proto.inviscid_vortex_minfty.value = self.inviscid_vortex_minfty
        _proto.inviscid_vortex_pinfty.value = self.inviscid_vortex_pinfty
        _proto.inviscid_vortex_tinfty.value = self.inviscid_vortex_tinfty
        _proto.inviscid_vortex_xv.value = self.inviscid_vortex_xv
        _proto.inviscid_vortex_yv.value = self.inviscid_vortex_yv
        _proto.inviscid_vortex_xflowdir.value = self.inviscid_vortex_xflowdir
        _proto.inviscid_vortex_yflowdir.value = self.inviscid_vortex_yflowdir
        _proto.inviscid_vortex_rvortex.value = self.inviscid_vortex_rvortex
        _proto.inviscid_vortex_betavortex.value = self.inviscid_vortex_betavortex
        return _proto

    def _from_proto(self, proto: clientpb.InitializationFluid):
        self.initialization_type = enum.InitializationType(proto.initialization_type)
        self.existing_solution_id = proto.existing_solution_id
        self.verification_solutions = enum.VerificationSolutions(proto.verification_solutions)
        self.potential_flow_pressure_initialization = enum.PotentialFlowPressureInitialization(
            proto.potential_flow_pressure_initialization
        )
        self.uniform_p = proto.uniform_p.value
        self.uniform_v._from_ad_proto(proto.uniform_v)
        self.uniform_t = proto.uniform_t.value
        self.turbulent_variable_initialization_type_sa = enum.TurbulentVariableInitializationTypeSa(
            proto.turbulent_variable_initialization_type_sa
        )
        self.turbulent_variable_initialization_type_komega = (
            enum.TurbulentVariableInitializationTypeKomega(
                proto.turbulent_variable_initialization_type_komega
            )
        )
        self.init_turbulent_viscosity_ratio = proto.init_turbulent_viscosity_ratio.value
        self.init_turbulent_viscosity = proto.init_turbulent_viscosity.value
        self.init_turbulence_intensity = proto.init_turbulence_intensity.value
        self.uniform_nu_tilde = proto.uniform_nu_tilde.value
        self.uniform_tke = proto.uniform_tke.value
        self.uniform_omega = proto.uniform_omega.value
        self.tgv_rho = proto.tgv_rho.value
        self.tgv_p = proto.tgv_p.value
        self.tgv_v = proto.tgv_v.value
        self.shocktube_p1 = proto.shocktube_p1.value
        self.shocktube_p4 = proto.shocktube_p4.value
        self.shocktube_t1 = proto.shocktube_t1.value
        self.shocktube_t4 = proto.shocktube_t4.value
        self.shuosher_p1 = proto.shuosher_p1.value
        self.shuosher_rho1 = proto.shuosher_rho1.value
        self.shuosher_m1 = proto.shuosher_m1.value
        self.shuosher_p2 = proto.shuosher_p2.value
        self.shuosher_rho2 = proto.shuosher_rho2.value
        self.shuosher_m2 = proto.shuosher_m2.value
        self.shuosher_amp = proto.shuosher_amp.value
        self.shuosher_kx = proto.shuosher_kx.value
        self.disturbancewave_p = proto.disturbancewave_p.value
        self.disturbancewave_t = proto.disturbancewave_t.value
        self.disturbancewave_m = proto.disturbancewave_m.value
        self.acousticwave_amp = proto.acousticwave_amp.value
        self.vorticitywave_amp = proto.vorticitywave_amp.value
        self.entropywave_amp = proto.entropywave_amp.value
        self.disturbancewave_kx = proto.disturbancewave_kx.value
        self.normalshock_p1 = proto.normalshock_p1.value
        self.normalshock_t1 = proto.normalshock_t1.value
        self.normalshock_m1 = proto.normalshock_m1.value
        self.shockvortex_p1 = proto.shockvortex_p1.value
        self.shockvortex_t1 = proto.shockvortex_t1.value
        self.shockvortex_m1 = proto.shockvortex_m1.value
        self.shockvortex_mv = proto.shockvortex_mv.value
        self.shockvortex_xv = proto.shockvortex_xv.value
        self.shockvortex_zv = proto.shockvortex_zv.value
        self.shockvortex_av = proto.shockvortex_av.value
        self.shockvortex_bv = proto.shockvortex_bv.value
        self.mms_k = proto.mms_k.value
        self.mms_a = proto.mms_a.value
        self.inviscid_vortex_minfty = proto.inviscid_vortex_minfty.value
        self.inviscid_vortex_pinfty = proto.inviscid_vortex_pinfty.value
        self.inviscid_vortex_tinfty = proto.inviscid_vortex_tinfty.value
        self.inviscid_vortex_xv = proto.inviscid_vortex_xv.value
        self.inviscid_vortex_yv = proto.inviscid_vortex_yv.value
        self.inviscid_vortex_xflowdir = proto.inviscid_vortex_xflowdir.value
        self.inviscid_vortex_yflowdir = proto.inviscid_vortex_yflowdir.value
        self.inviscid_vortex_rvortex = proto.inviscid_vortex_rvortex.value
        self.inviscid_vortex_betavortex = proto.inviscid_vortex_betavortex.value


@dataclass(kw_only=True)
class BladeElementAirfoilData(ParamGroupWrapper[clientpb.BladeElementAirfoilData]):
    """Construct a blade by assigning airfoil profiles to different radial stations"""

    airfoil_id: str = field(default_factory=create_unique_id, init=False)
    "Assign a unique ID to this airfoil"
    airfoil_name: str = ""
    "Apply a descriptive name to this airfoil"
    airfoil_radial_station: float = 0.0
    "Airfoil shape on the blade at this r/R"
    airfoil_performance_data: Optional[RectilinearTable] = None
    "Lift, drag, and pitching moment coefficients vs. alpha & Mach number"

    def _to_proto(self) -> clientpb.BladeElementAirfoilData:
        _proto = clientpb.BladeElementAirfoilData()
        if self.airfoil_id is not None:
            _proto.airfoil_id = self.airfoil_id
        if self.airfoil_name is not None:
            _proto.airfoil_name = self.airfoil_name
        if self.airfoil_radial_station is not None:
            _proto.airfoil_radial_station.value = self.airfoil_radial_station
        if self.airfoil_performance_data is not None:
            _proto.airfoil_performance_data = self.airfoil_performance_data
        return _proto

    def _from_proto(self, proto: clientpb.BladeElementAirfoilData):
        self.airfoil_id = proto.airfoil_id
        self.airfoil_name = proto.airfoil_name
        self.airfoil_radial_station = proto.airfoil_radial_station.value
        self.airfoil_performance_data = proto.airfoil_performance_data


@dataclass(kw_only=True)
class PhysicalBehavior(ParamGroupWrapper[clientpb.PhysicalBehavior]):
    """Physical behavior settings for a fluid flow physics solver."""

    physical_behavior_id: str = field(default_factory=create_unique_id, init=False)
    ""
    physical_behavior_name: str = ""
    ""
    physical_behavior_model: enum.PhysicalBehaviorModel = (
        enum.PhysicalBehaviorModel.ACTUATOR_DISK_MODEL
    )
    "Defines the physical behavior type."
    actuator_disk_model: enum.ActuatorDiskModel = (
        enum.ActuatorDiskModel.ACTUATOR_DISK_UNIFORM_THRUST
    )
    "Defines the physics behavior of the actuator disk."
    actuator_line_model: enum.ActuatorLineModel = enum.ActuatorLineModel.ACTUATOR_LINE_BLADE_ELEMENT
    "Defines the physics behavior of the actuator line."
    particle_source_model: enum.ParticleSourceModel = enum.ParticleSourceModel.GENERAL_MASS_SOURCE
    "Defines the behavior of the general source particles."
    actuator_disk_thrust: float = 0.0
    "Thrust provided by the actuator disk"
    actuator_disk_torque: float = 0.0
    "Torque of the actuator disk"
    actuator_disk_radial_force: float = 0.0
    "Radial force of the actuator disk"
    actuator_disk_rotation_rate: float = 100.0
    "Rotational speed of the fictitious blades represented by the actuator disk"
    actuator_disk_blade_count: int = 2
    "Number of blades in the propeller/rotor"
    blade_element_pitch_schedule: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant, cosine, and sine Fourier series coefficients for pitch first harmonic"
    blade_element_flap_schedule: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant, cosine, and sine Fourier series coefficients for flap hinge first harmonic"
    blade_element_lag_schedule: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "Constant, cosine, and sine Fourier series coefficients for lag hinge first harmonic"
    blade_element_geometry_data: Optional[RectilinearTable] = None
    "Blade twist, sweep, anhedral, and chord vs. radial station (r/R)"
    blade_element_reference_sound_speed: float = 340.0
    "Reference sound speed required for each blade element model in constant density flows. Sound speed of air at sea level conditions is 340 m/s."
    actuator_disk_radial_table_data: Optional[RectilinearTable] = None
    "Radially dependent axial, circumferential, and radial force distribution"
    source_particle_acceleration_vector: Vector3 = field(
        default_factory=lambda: Vector3(0.0, 0.0, -9.81)
    )
    "Acceleration applied by generic source particles"
    source_particle_mass_injection_rate: float = 0.0
    "Mass injection rate supplied by particle group"
    blade_element_airfoil_data: list[BladeElementAirfoilData] = field(default_factory=list)
    "Construct a blade by assigning airfoil profiles to different radial stations"
    fan_curve_table_data: Optional[RectilinearTable] = None
    "Correlation between fan pressure rise and volume flow rate"
    head_loss_coefficient: float = 0.0
    "Fraction of dynamic pressure lost through the fan."

    def _to_proto(self) -> clientpb.PhysicalBehavior:
        _proto = clientpb.PhysicalBehavior()
        if self.physical_behavior_id is not None:
            _proto.physical_behavior_id = self.physical_behavior_id
        if self.physical_behavior_name is not None:
            _proto.physical_behavior_name = self.physical_behavior_name
        _proto.physical_behavior_model = self.physical_behavior_model
        _proto.actuator_disk_model = self.actuator_disk_model
        _proto.actuator_line_model = self.actuator_line_model
        _proto.particle_source_model = self.particle_source_model
        _proto.actuator_disk_thrust.value = self.actuator_disk_thrust
        _proto.actuator_disk_torque.value = self.actuator_disk_torque
        _proto.actuator_disk_radial_force.value = self.actuator_disk_radial_force
        _proto.actuator_disk_rotation_rate.value = self.actuator_disk_rotation_rate
        _proto.actuator_disk_blade_count.value = self.actuator_disk_blade_count
        _proto.blade_element_pitch_schedule.CopyFrom(
            self.blade_element_pitch_schedule._to_ad_proto()
        )
        _proto.blade_element_flap_schedule.CopyFrom(self.blade_element_flap_schedule._to_ad_proto())
        _proto.blade_element_lag_schedule.CopyFrom(self.blade_element_lag_schedule._to_ad_proto())
        if self.blade_element_geometry_data is not None:
            _proto.blade_element_geometry_data = self.blade_element_geometry_data
        _proto.blade_element_reference_sound_speed.value = self.blade_element_reference_sound_speed
        if self.actuator_disk_radial_table_data is not None:
            _proto.actuator_disk_radial_table_data = self.actuator_disk_radial_table_data
        _proto.source_particle_acceleration_vector.CopyFrom(
            self.source_particle_acceleration_vector._to_ad_proto()
        )
        _proto.source_particle_mass_injection_rate.value = self.source_particle_mass_injection_rate
        _proto.blade_element_airfoil_data.extend(
            v._to_proto() for v in self.blade_element_airfoil_data
        )
        if self.fan_curve_table_data is not None:
            _proto.fan_curve_table_data = self.fan_curve_table_data
        _proto.head_loss_coefficient.value = self.head_loss_coefficient
        return _proto

    def _from_proto(self, proto: clientpb.PhysicalBehavior):
        self.physical_behavior_id = proto.physical_behavior_id
        self.physical_behavior_name = proto.physical_behavior_name
        self.physical_behavior_model = enum.PhysicalBehaviorModel(proto.physical_behavior_model)
        self.actuator_disk_model = enum.ActuatorDiskModel(proto.actuator_disk_model)
        self.actuator_line_model = enum.ActuatorLineModel(proto.actuator_line_model)
        self.particle_source_model = enum.ParticleSourceModel(proto.particle_source_model)
        self.actuator_disk_thrust = proto.actuator_disk_thrust.value
        self.actuator_disk_torque = proto.actuator_disk_torque.value
        self.actuator_disk_radial_force = proto.actuator_disk_radial_force.value
        self.actuator_disk_rotation_rate = proto.actuator_disk_rotation_rate.value
        self.actuator_disk_blade_count = proto.actuator_disk_blade_count.value
        self.blade_element_pitch_schedule._from_ad_proto(proto.blade_element_pitch_schedule)
        self.blade_element_flap_schedule._from_ad_proto(proto.blade_element_flap_schedule)
        self.blade_element_lag_schedule._from_ad_proto(proto.blade_element_lag_schedule)
        self.blade_element_geometry_data = proto.blade_element_geometry_data
        self.blade_element_reference_sound_speed = proto.blade_element_reference_sound_speed.value
        self.actuator_disk_radial_table_data = proto.actuator_disk_radial_table_data
        self.source_particle_acceleration_vector._from_ad_proto(
            proto.source_particle_acceleration_vector
        )
        self.source_particle_mass_injection_rate = proto.source_particle_mass_injection_rate.value
        self.blade_element_airfoil_data = [
            BladeElementAirfoilData.from_proto(v) for v in proto.blade_element_airfoil_data
        ]
        self.fan_curve_table_data = proto.fan_curve_table_data
        self.head_loss_coefficient = proto.head_loss_coefficient.value


@dataclass(kw_only=True)
class Cavitation(ParamGroupWrapper[clientpb.Cavitation]):
    """Cavitation settings for a fluid flow physics solver."""

    cavitation_model: enum.CavitationModel = enum.CavitationModel.SAUER_SCHNERR
    "Cavitation models available for simulating flow with cavitation."
    density_vapor_phase_cavitation: float = 0.7267
    "The density of the vapor phase for the simulation of a flow with a cavitating fluid"
    saturation_pressure_cavitation: float = 3170
    "The saturation pressure of the fluid, assumed constant for now, for the simulation of a flow with a cavitating fluid"
    n0_sauer_schnerr: float = 100000000.0
    "The initial nuclei concentration in bubbles/m3 for the Sauer Schnerr cavitation model"
    n_reboud: float = 10.0
    "Exponent for the Reboud correction for the eddy viscosity in cavitating regions"

    def _to_proto(self) -> clientpb.Cavitation:
        _proto = clientpb.Cavitation()
        _proto.cavitation_model = self.cavitation_model
        _proto.density_vapor_phase_cavitation.value = self.density_vapor_phase_cavitation
        _proto.saturation_pressure_cavitation.value = self.saturation_pressure_cavitation
        _proto.n0_sauer_schnerr.value = self.n0_sauer_schnerr
        _proto.n_reboud.value = self.n_reboud
        return _proto

    def _from_proto(self, proto: clientpb.Cavitation):
        self.cavitation_model = enum.CavitationModel(proto.cavitation_model)
        self.density_vapor_phase_cavitation = proto.density_vapor_phase_cavitation.value
        self.saturation_pressure_cavitation = proto.saturation_pressure_cavitation.value
        self.n0_sauer_schnerr = proto.n0_sauer_schnerr.value
        self.n_reboud = proto.n_reboud.value


@dataclass(kw_only=True)
class PorousBehavior(ParamGroupWrapper[clientpb.PorousBehavior]):
    """Porous model settings for a fluid flow physics solver."""

    porous_behavior_id: str = field(default_factory=create_unique_id, init=False)
    ""
    porous_behavior_name: str = ""
    ""
    zone_ids: list[str] = field(default_factory=list)
    ""
    porous_model_type: enum.PorousModelType = enum.PorousModelType.DARCY_FORCHHEIMER
    "Type of porous model."
    darcy_coeff: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "(x,y,z) components of the Darcy coefficients."
    forchheimer_coeff: Vector3 = field(default_factory=lambda: Vector3(0.0, 0.0, 0.0))
    "(x,y,z) components of the Forchheimer coefficients."
    porous_heat_source_power: float = 0.0
    "Power of the heat source."
    porous_heat_source_power_per_unit_volume: float = 0.0
    "Power per unit volume of the heat source."
    ref_frame_id: str = ""
    "Frame that defines the principal directions used by the Darcy-Forchheimer coefficients."

    def _to_proto(self) -> clientpb.PorousBehavior:
        _proto = clientpb.PorousBehavior()
        if self.porous_behavior_id is not None:
            _proto.porous_behavior_id = self.porous_behavior_id
        if self.porous_behavior_name is not None:
            _proto.porous_behavior_name = self.porous_behavior_name
        if self.zone_ids is not None:
            _proto.zone_ids.extend(self.zone_ids)
        _proto.porous_model_type = self.porous_model_type
        _proto.darcy_coeff.CopyFrom(self.darcy_coeff._to_ad_proto())
        _proto.forchheimer_coeff.CopyFrom(self.forchheimer_coeff._to_ad_proto())
        if self.porous_heat_source_power is not None:
            _proto.porous_heat_source_power.value = self.porous_heat_source_power
        if self.porous_heat_source_power_per_unit_volume is not None:
            _proto.porous_heat_source_power_per_unit_volume.value = (
                self.porous_heat_source_power_per_unit_volume
            )
        if self.ref_frame_id is not None:
            _proto.ref_frame_id = self.ref_frame_id
        return _proto

    def _from_proto(self, proto: clientpb.PorousBehavior):
        self.porous_behavior_id = proto.porous_behavior_id
        self.porous_behavior_name = proto.porous_behavior_name
        self.zone_ids.extend(proto.zone_ids)
        self.porous_model_type = enum.PorousModelType(proto.porous_model_type)
        self.darcy_coeff._from_ad_proto(proto.darcy_coeff)
        self.forchheimer_coeff._from_ad_proto(proto.forchheimer_coeff)
        self.porous_heat_source_power = proto.porous_heat_source_power.value
        self.porous_heat_source_power_per_unit_volume = (
            proto.porous_heat_source_power_per_unit_volume.value
        )
        self.ref_frame_id = proto.ref_frame_id


@dataclass(kw_only=True)
class Fluid(ParamGroupWrapper[clientpb.Fluid]):
    """Configuration for a fluid flow physics solver - simulates the flow of liquids and gases."""

    basic_fluid: Optional[BasicFluid] = field(default_factory=BasicFluid)
    "Basic settings for a fluid flow physics solver."
    turbulence: Optional[Turbulence] = field(default_factory=Turbulence)
    "Turbulence settings for a fluid flow physics solver."
    solution_controls_fluid: Optional[SolutionControlsFluid] = field(
        default_factory=SolutionControlsFluid
    )
    "Solution controls for a fluid flow physics solver."
    adjoint_controls_fluid: Optional[AdjointControlsFluid] = field(
        default_factory=AdjointControlsFluid
    )
    ""
    spatial_discretization_fluid: Optional[SpatialDiscretizationFluid] = field(
        default_factory=SpatialDiscretizationFluid
    )
    "Spatial discretization settings for a fluid flow physics solver."
    boundary_conditions_fluid: list[BoundaryConditionsFluid] = field(default_factory=list)
    "Boundary conditions for a fluid flow physics solver."
    sliding_interfaces: list[SlidingInterfaces] = field(default_factory=list)
    "Defines the two sides that form a sliding interface. The two sides are abutting, possibly in combination with a periodic transformation, and should have the same normal grid velocity. The tangential grid velocity can, and usually will, be different. Each side of the sliding interface can be composed out of an arbitrary number of surfaces."
    periodic_pair: list[PeriodicPair] = field(default_factory=list)
    "Defines the input options needed for periodic boundaries. We assume each periodic BC can have translational OR rotational periodicity. To transform a point on boundary A to its periodically matching point on boundary B, we first subtract the center of rotation from the point coordinates to get the distance vector from the center to the point of interest, then we apply rotation around the periodicity axis and add back the center of rotation to get the coordinates of the transformed point."
    initialization_fluid: Optional[InitializationFluid] = field(default_factory=InitializationFluid)
    "Initialization settings for a fluid flow physics solver."
    physical_behavior: list[PhysicalBehavior] = field(default_factory=list)
    "Physical behavior settings for a fluid flow physics solver."
    cavitation: Optional[Cavitation] = field(default_factory=Cavitation)
    "Cavitation settings for a fluid flow physics solver."
    porous_behavior: list[PorousBehavior] = field(default_factory=list)
    "Porous model settings for a fluid flow physics solver."

    def _to_proto(self) -> clientpb.Fluid:
        _proto = clientpb.Fluid()
        _proto.basic_fluid.CopyFrom(self.basic_fluid._to_proto())
        _proto.turbulence.CopyFrom(self.turbulence._to_proto())
        _proto.solution_controls_fluid.CopyFrom(self.solution_controls_fluid._to_proto())
        _proto.adjoint_controls_fluid.CopyFrom(self.adjoint_controls_fluid._to_proto())
        _proto.spatial_discretization_fluid.CopyFrom(self.spatial_discretization_fluid._to_proto())
        _proto.boundary_conditions_fluid.extend(
            v._to_proto() for v in self.boundary_conditions_fluid
        )
        _proto.sliding_interfaces.extend(v._to_proto() for v in self.sliding_interfaces)
        _proto.periodic_pair.extend(v._to_proto() for v in self.periodic_pair)
        _proto.initialization_fluid.CopyFrom(self.initialization_fluid._to_proto())
        _proto.physical_behavior.extend(v._to_proto() for v in self.physical_behavior)
        _proto.cavitation.CopyFrom(self.cavitation._to_proto())
        _proto.porous_behavior.extend(v._to_proto() for v in self.porous_behavior)
        return _proto

    def _from_proto(self, proto: clientpb.Fluid):
        self.basic_fluid = BasicFluid.from_proto(proto.basic_fluid)
        self.turbulence = Turbulence.from_proto(proto.turbulence)
        self.solution_controls_fluid = SolutionControlsFluid.from_proto(
            proto.solution_controls_fluid
        )
        self.adjoint_controls_fluid = AdjointControlsFluid.from_proto(proto.adjoint_controls_fluid)
        self.spatial_discretization_fluid = SpatialDiscretizationFluid.from_proto(
            proto.spatial_discretization_fluid
        )
        self.boundary_conditions_fluid = [
            BoundaryConditionsFluid.from_proto(v) for v in proto.boundary_conditions_fluid
        ]
        self.sliding_interfaces = [
            SlidingInterfaces.from_proto(v) for v in proto.sliding_interfaces
        ]
        self.periodic_pair = [PeriodicPair.from_proto(v) for v in proto.periodic_pair]
        self.initialization_fluid = InitializationFluid.from_proto(proto.initialization_fluid)
        self.physical_behavior = [PhysicalBehavior.from_proto(v) for v in proto.physical_behavior]
        self.cavitation = Cavitation.from_proto(proto.cavitation)
        self.porous_behavior = [PorousBehavior.from_proto(v) for v in proto.porous_behavior]


@dataclass(kw_only=True)
class MultiPhysicsCouplingOptions(ParamGroupWrapper[clientpb.MultiPhysicsCouplingOptions]):
    """Defines coupling solution strategies between different physics."""

    mp_coupling_lin_sol_coupling: enum.MpCouplingLinSolCoupling = (
        enum.MpCouplingLinSolCoupling.MP_COUPLING_LIN_SOL_COUPLING_ON
    )
    "Turns on the use of enhanced coupling between the physics, which provides greater robustness at the cost of simulation speed."

    def _to_proto(self) -> clientpb.MultiPhysicsCouplingOptions:
        _proto = clientpb.MultiPhysicsCouplingOptions()
        _proto.mp_coupling_lin_sol_coupling = self.mp_coupling_lin_sol_coupling
        return _proto

    def _from_proto(self, proto: clientpb.MultiPhysicsCouplingOptions):
        self.mp_coupling_lin_sol_coupling = enum.MpCouplingLinSolCoupling(
            proto.mp_coupling_lin_sol_coupling
        )


@dataclass(kw_only=True)
class SimulationParam(ParamGroupWrapper[clientpb.SimulationParam]):
    """Simulation configuration that supports multiple physics."""

    volume_entity: list[VolumeEntity] = field(default_factory=list)
    "Volume entity."
    general: Optional[General] = field(default_factory=General)
    "Basic parameters used by a solution."
    adjoint: Optional[Adjoint] = field(default_factory=Adjoint)
    "Settings for adjoint sensitivity analysis."
    time: Optional[Time] = field(default_factory=Time)
    "Time parameters used by a transient solution (required if flow_behavior = transient)."
    motion_data: list[MotionData] = field(default_factory=list)
    "Motion data."
    particle_group: list[ParticleGroup] = field(default_factory=list)
    "Particle groups."
    monitor_plane: list[MonitorPlane] = field(default_factory=list)
    "Monitor plane."
    body_frame: Optional[BodyFrame] = field(default_factory=BodyFrame)
    "Body frame."
    surface_name: dict[str, SurfaceName] = field(default_factory=dict)
    "Surface name map."
    table: dict[str, Any] = field(default_factory=dict)
    "Solution inputs - General n-dimensional rectilinear grid data (Monitor points, radial distribution, blade geometry, airfoil performance)."
    table_references: dict[str, Any] = field(default_factory=dict)
    "Solution inputs - metadata for general n-dimensional rectilinear grid data (Monitor points, radial distribution, blade geometry, airfoil performance)."
    output: Optional[Output] = field(default_factory=Output)
    "Solution output settings."
    entity_relationships: Optional[EntityRelationships] = field(default_factory=EntityRelationships)
    "Relationships between different entities."
    reference_values: Optional[ReferenceValues] = field(default_factory=ReferenceValues)
    "Define reference values needed for computing forces and moments."
    adaptive_mesh_refinement: Optional[AdaptiveMeshRefinement] = field(
        default_factory=AdaptiveMeshRefinement
    )
    "Adaptive Mesh Refinement"
    interfaces: list[SlidingInterfaces] = field(default_factory=list)
    "Defines the two sides that form a sliding interface. The two sides are abutting, possibly in combination with a periodic transformation, and should have the same normal grid velocity. The tangential grid velocity can, and usually will, be different. Each side of the sliding interface can be composed out of an arbitrary number of surfaces."
    mp_coupling_options: Optional[MultiPhysicsCouplingOptions] = field(
        default_factory=MultiPhysicsCouplingOptions
    )
    "Defines coupling solution strategies between different physics."

    def _to_proto(self) -> clientpb.SimulationParam:
        _proto = clientpb.SimulationParam()
        _proto.volume_entity.extend(v._to_proto() for v in self.volume_entity)
        _proto.general.CopyFrom(self.general._to_proto())
        _proto.adjoint.CopyFrom(self.adjoint._to_proto())
        _proto.time.CopyFrom(self.time._to_proto())
        _proto.motion_data.extend(v._to_proto() for v in self.motion_data)
        _proto.particle_group.extend(v._to_proto() for v in self.particle_group)
        _proto.monitor_plane.extend(v._to_proto() for v in self.monitor_plane)
        _proto.body_frame.CopyFrom(self.body_frame._to_proto())
        _proto.surface_name.update({k: v._to_proto() for k, v in self.surface_name.items()})
        if self.table is not None:
            _proto.table.update(self.table)
        if self.table_references is not None:
            _proto.table_references.update(self.table_references)
        _proto.output.CopyFrom(self.output._to_proto())
        _proto.entity_relationships.CopyFrom(self.entity_relationships._to_proto())
        _proto.reference_values.CopyFrom(self.reference_values._to_proto())
        _proto.adaptive_mesh_refinement.CopyFrom(self.adaptive_mesh_refinement._to_proto())
        _proto.interfaces.extend(v._to_proto() for v in self.interfaces)
        _proto.mp_coupling_options.CopyFrom(self.mp_coupling_options._to_proto())
        return _proto

    def _from_proto(self, proto: clientpb.SimulationParam):
        self.volume_entity = [VolumeEntity.from_proto(v) for v in proto.volume_entity]
        self.general = General.from_proto(proto.general)
        self.adjoint = Adjoint.from_proto(proto.adjoint)
        self.time = Time.from_proto(proto.time)
        self.motion_data = [MotionData.from_proto(v) for v in proto.motion_data]
        self.particle_group = [ParticleGroup.from_proto(v) for v in proto.particle_group]
        self.monitor_plane = [MonitorPlane.from_proto(v) for v in proto.monitor_plane]
        self.body_frame = BodyFrame.from_proto(proto.body_frame)
        self.surface_name = {k: SurfaceName.from_proto(v) for k, v in proto.surface_name.items()}
        self.table.update(proto.table)
        self.table_references.update(proto.table_references)
        self.output = Output.from_proto(proto.output)
        self.entity_relationships = EntityRelationships.from_proto(proto.entity_relationships)
        self.reference_values = ReferenceValues.from_proto(proto.reference_values)
        self.adaptive_mesh_refinement = AdaptiveMeshRefinement.from_proto(
            proto.adaptive_mesh_refinement
        )
        self.interfaces = [SlidingInterfaces.from_proto(v) for v in proto.interfaces]
        self.mp_coupling_options = MultiPhysicsCouplingOptions.from_proto(proto.mp_coupling_options)
