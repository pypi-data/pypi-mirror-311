from __future__ import annotations

from typing import Tuple, Literal

import numpy as np

from .utils import get_logger


def rightshift(bdata: np.ndarray, shift: int) -> np.ndarray:
    """
    Downshift the integer used for fixed point representation in FPT. This function is compatible with the negative
    numbers padded with '1' from the left.

    :param bdata: numpy array of integers
    :param shift: number of positions to downshift the integer
    :return: numpy array of integers shifted right
    """
    return np.sign(bdata) * (np.abs(bdata) >> shift)


def bit_reverse(data: np.ndarray | int, nbits: int) -> np.ndarray | int:
    """
    Reverses order of bits in a given integer data.

    | For example, the array
    | 0      1      2      3      4      5      6      7      8      9
    | in binary form
    | 0[000] 0[001] 0[010] 0[011] 0[100] 0[101] 0[110] 0[111] 1[000] 1[001]
    | using nbits = 3 gets reversed into
    | 0[000] 0[100] 0[010] 0[110] 0[001] 0[101] 0[011] 0[111] 1[000] 1[100]

    :param data: The input integer data to reverse.
    :param nbits: The number of bits to consider for the reversal. Must be a positive integer. If
                  nbits is smaller than the number of bits in the data, then only nbits from the
                  left will be reversed and returned.
    :return: The reversed integer data.
    """

    if nbits < 1:
        # Return the LSB, which is irreversible
        return data & 1

    if isinstance(data, np.ndarray):
        res = np.zeros(data.shape, dtype=data.dtype)
    elif isinstance(data, int):
        res = 0
    else:
        raise TypeError("data must be an integer or a numpy array")

    for i in range(nbits):
        # Order of operations: >>, &, |
        res = res << 1 | data >> i & 1
    return res


class FixedPoint:
    """
    Data type for fixed-point binary arithmetic.

    For example, FixedPoint(bw=8, fw=3, ...) will create a binary representation in form 00000|000, where the total
    number of bits is 8, but only the first 5 represent integer part.

    :param bw: Bit width of the fixed point type.
    :param fw: Fraction width starting from the lsb.
    :param data: Numpy array containing data.
    :param disbin: Flag indicating whether the data has already been converted to binary format.
    :param ofmode: Overflow handling mode: either 'wrap' or 'saturate' (default).
    """

    # TODO: Describe all methods that are not autogenerated here
    def __init__(self, bw: int, fw: int, data: np.ndarray = None, disbin: bool = False, dtype: np.dtype = np.int64,
                 ofmode: Literal["saturate", "wrap"] = "saturate"):
        # TODO: make sure all FPT operations respect the dtype
        self.bw = bw
        self.fw = fw
        self.dtype = dtype
        self.ofmode = ofmode
        self.logger = get_logger(self.__class__.__name__)
        if data is not None:
            data = np.atleast_1d(data)

        if data is None:
            self.bdata = data
        else:
            if disbin:
                self.bdata = self.mask_bitwidth(data)
            else:
                self.bdata = self.from_float(data)

    def __getitem__(self, item) -> FixedPoint:
        """
        Works similarly to np.ndarray, but slices bdata and returns a new FixedPoint.
        :param item: Unsigned integer index.
        :return: A new FixedPoint with bdata containing an item or a slice of FixedPoint.bdata
        """
        return self.__class__(self.bw, self.fw, self.bdata.__getitem__(item), disbin=True, ofmode=self.ofmode)

    def __setitem__(self, item, value: FixedPoint):
        """
        Works similarly to np.ndarray, but slices bdata and returns FixedPoint.
        :param item: Unsigned integer index.
        :param value: Value(s) to be assigned to the item or slice.
        """
        if not isinstance(value, FixedPoint):
            raise ValueError("The assigned value is not a FixedPoint")
        if not value.bwfw == self.bwfw:
            raise ValueError("The bit width and point position of the value differs from the target FixedPoint")
        self.bdata.__setitem__(item, value.bdata)

    def __add__(self, obj: FixedPoint) -> FixedPoint:
        """
        Return a new FixedPoint type resulting from summing this type with the provided one,
        including the carry bit. Increases bit width, but keeps point position.
        """
        if type(obj) is not type(self):
            raise ValueError("Addition is implemented only for the same class types")

        if obj.bw != self.bw:
            raise ValueError("Cannot add FixedPoint with different bit width. You may want to cast() the FixedPoint "
                             "first.")

        if obj.fw != self.fw:
            self.logger.warning("Adding FixedPoint with different fraction width may be unintentional. You may want "
                                "to cast() the FixedPoint first.")

        whole_bits = max([self.bw - self.fw, obj.bw - obj.fw])
        fw = max([self.fw, obj.fw])
        bw = fw + whole_bits + 1
        return self.__class__(bw, fw, self.bdata + obj.bdata, disbin=True, ofmode=self.ofmode)

    def __neg__(self) -> "FixedPoint":
        return self.copy(-self.bdata)

    def __sub__(self, obj: FixedPoint) -> FixedPoint:
        """
        Subtraction would still increase bit width.
        """
        return self + (-obj)

    def __mul__(self, obj: FixedPoint) -> FixedPoint:
        """
        Return a new FixedPoint type resulting from multiplying this type with the provided one.
        """
        if type(obj) is not type(self):
            raise ValueError("Multiplication is implemented only for the same class types")

        bw = self.bw + obj.bw
        fw = self.fw + obj.fw
        return self.__class__(bw, fw, self.bdata * obj.bdata, disbin=True, ofmode=self.ofmode)

    def __repr__(self):
        return f"{type(self)}({self.bw}, {self.fw})\nData: \n{self.binstr}\n{self.data}"

    def __getattr__(self, attr):
        """
        This manages attribute requests. If attribute is present in class - it is returned.
        If not - the request is redirected to data numpy array. For example, although "shape"
        property is not defined in FixedPoint, one can still request FixedPoint.shape, which
        will return FixedPoint.bdata.shape. This also works for numpy array class methods.
        """
        np_attr = getattr(self.bdata, attr)
        if callable(np_attr):
            return lambda *args, **kwargs: self.__global_handler(np_attr, *args, **kwargs)
        return np_attr

    def __global_handler(self, func, *args, inplace: bool = False, newinst: bool = True, **kwargs):
        """
        :param inplace: If True - modifies the self.bdata with result of a ndarray method call, else returns result.
                        Overrides newinst parameter.
        :param newinst: If True - creates a new instance of the fpt with copied data, else returns a result of the
                        ndarray method call.
        """
        if inplace:
            self.bdata = np.asarray(func(*args, **kwargs), dtype=self.bdata.dtype)
        else:
            data = func(*args, **kwargs)
            if newinst:
                return self.copy(np.asarray(data, dtype=self.bdata.dtype))
            return data

    @property
    def bwfw(self) -> Tuple[int, int]:
        """
        :return: Bit width and point position returned in a tuple.
        """
        return self.bw, self.fw

    @property
    def data(self):
        """
        :return: FixedPoint.bdata converted to float.
        """
        return self.to_float()

    @property
    def nbits(self):
        """
        :return: Number of available bits in the FixedPoint. For instance, if dtype is np.int64, nbits is 64.
                 Not all bits are necessarily used for storing data; the data size is limited to FixedPoint.bw
        """
        return np.dtype(self.dtype).itemsize * 8

    @property
    def binstr(self):
        """
        :return: Binary representation of the FixedPoint.bdata.
        """
        binstr = np.vectorize(np.binary_repr)(self.bdata, width=self.bw)
        return [x[:self.bw - self.fw] + "." + x[self.bw - self.fw:] for x in binstr]

    def copy(self, new_bdata: np.ndarray = None) -> FixedPoint:
        """
        :param new_bdata: If provided, the data will be copied into the new FixedPoint.
        :return: A copy of the FixedPoint instance.
        """
        bdata = new_bdata if new_bdata is not None else self.bdata
        return self.__class__(self.bw, self.fw, bdata.astype(self.dtype, copy=True), disbin=True, ofmode=self.ofmode)

    def empty(self, shape: Tuple[int] = None) -> FixedPoint:
        """
        :param shape: Shape of the bdata array in the returned FixedPoint.
        :return: An empty (no bdata) FixedPoint instance.
        """
        shape = shape or self.bdata.shape
        return self.__class__(self.bw, self.fw, np.empty(shape, dtype=self.dtype), ofmode=self.ofmode)

    def mask_bitwidth(self, bdata: np.ndarray = None) -> np.ndarray:
        """
        Truncates data from the left and fills all the left bits with MSB.

        :param bdata: Array to be masked. If None, self.bdata will be masked.
        :return: Array masked.
        """
        if bdata is None:
            bdata = self.bdata

        shift = self.nbits - self.bw
        return (bdata.astype(self.dtype) << shift) >> shift

    def _handle_overflow(self, bdata: np.ndarray):
        if self.ofmode == "saturate":
            min_value = -1 << (self.bw - 1)
            max_value = (1 << (self.bw - 1)) - 1
            return np.clip(bdata, min_value, max_value)
        return bdata

    def from_float(self, data: np.ndarray):
        """
        Convert the provided floating point number or numpy array into
        its fixed-point representation according to the bit width and
        binary point of this data type.

        :param data: Array to be converted.
        :return: Data array in binary format.
        """
        _bdata = np.around(data * 2 ** self.fw).astype(self.dtype)
        _bdata = self._handle_overflow(_bdata)
        return self.mask_bitwidth(_bdata)

    def to_float(self, bdata: np.ndarray = None) -> np.ndarray:
        """
        Convert the contained binary array into its floating-point value according to the bit width and
        binary point of this data type.

        :param bdata: Array to be converted.
        :return: Data array with floating point values.
        """
        if bdata is None:
            bdata = self.bdata
        return self.mask_bitwidth(bdata).astype(np.float64) / 2 ** self.fw

    def __rshift__(self, other: int) -> FixedPoint:
        return self.copy(new_bdata=rightshift(self.bdata, other))

    def __lshift__(self, other: int) -> FixedPoint:
        return self.copy(new_bdata=self.bdata << other)

    def __and__(self, other: int) -> FixedPoint:
        return self.copy(new_bdata=self.bdata & other)

    def __or__(self, other: int) -> FixedPoint:
        return self.copy(new_bdata=self.bdata | other)

    def __xor__(self, other: int) -> FixedPoint:
        return self.copy(new_bdata=self.bdata ^ other)

    def __invert__(self) -> FixedPoint:
        return self.copy(new_bdata=~self.bdata)

    def cast(self, bw: int, fw: int) -> FixedPoint:
        """
        Cast the FixedPoint into a new one with specified bit width and binary point. Before
        performing arithmetic operations on FixedPoint instances with different bw and fw, bot must
        be casted to the same FixedPoint configuration. The new bw and fw parameters must be equal or
        larger than the original FixedPoint configuration.

        Casting happens in two steps:
        1. Right or left shifting based on the new point position (skipped if keep_lsb is True)
        2. Truncating from the left

        :param bw: Bit width of the fixed point type.
        :param fw: Fraction width starting from the lsb.
        :return: A new FixedPoint instance.
        """

        if bw < self.bw or fw < self.fw:
            raise ValueError("New bit width and fraction width must be greater than or equal to original FixedPoint"
                             "configuration. For operations causing data loss use explicit functions")
        if bw - self.bw < fw - self.fw:
            raise ValueError(
                f"You must increase the bit width at least by {fw - self.fw} to accommodate extra fraction "
                f"width.")

        bdata = self.bdata.astype(self.dtype, copy=True)

        bdata = bdata << (fw - self.fw)

        return self.__class__(bw, fw, bdata, disbin=True, ofmode=self.ofmode)

    def reinterpret(self, fw: int) -> FixedPoint:
        """
        Reinterprets existing FixedPointType data without changing the bit width.

        :param fw: New binary point location
        :return: A new FixedPoint instance.
        """
        return self.__class__(self.bw, fw, self.bdata, disbin=True, ofmode=self.ofmode)

    def truncate(self, bw: int) -> FixedPoint:
        """
        Truncate the FixedPoint to a new specified bit width. The current bit width will not be replaced if the new
        value is larger. The relative position of the fixed point is not preserved.

        :param bw: New bit width of the FixedPoint
        :return: A new FixedPoint instance.
        """
        bdata = self.bdata.astype(self.dtype, copy=True)
        shift = self.bw - bw
        bdata = bdata >> shift
        return self.__class__(bw, max(0, self.fw - shift), bdata, disbin=True, ofmode=self.ofmode)

    def _round(self, bw: int):
        """
        :param bw: New bit width
        :return: Truncated FixedPoint instance and round-off data in binary format.
        """
        shift = self.bw - bw
        round_data = rightshift(self.bdata, shift) << shift
        rnd_off = self.bdata - round_data
        rnd_off = rightshift(rnd_off, shift - 1)
        return self.truncate(bw), np.where(rnd_off > 0, 1, 0)

    def round_from_zero(self, bw: int) -> FixedPoint:
        """
        Round the FixedPoint to a new specified bit width. This implements a round to nearest with ties away
        from zero. The bit width will not be replaced if the new value is larger. The relative position
        of the fixed point is preserved.

        :param bw: New bit width of the fixed point type
        :return: A new FixedPoint instance.
        """
        shift = self.bw - bw
        rnd_off_mask = (1 << shift) - 1
        rnd_off_bin = self.bdata & rnd_off_mask
        tie_bin = 1 << (shift - 1)
        rnd_off = np.where(self.bdata >= 0,
                           (rnd_off_bin >= tie_bin).astype(int),
                           (rnd_off_bin > tie_bin).astype(int))
        obj = self.truncate(bw)
        obj.bdata += rnd_off
        obj.bdata = obj.mask_bitwidth()
        return obj

    def round_to_even(self, bw: int) -> FixedPoint:
        """
        Round the FixedPoint to a new specified bit width. This implements a round to nearest with ties to
        nearest even. The current bit width will not be replaced if the new value is larger. The relative position
        of the fixed point is preserved.

        :param bw: New bit width of the fixed point type
        :return: A new FixedPoint instance.
        """
        obj = self.truncate(bw)
        shift = self.bw - bw
        rnd_off_mask = (1 << shift) - 1
        rnd_off_bin = self.bdata & rnd_off_mask
        tie_bin = 1 << (shift - 1)
        rnd_off = np.where(rnd_off_bin != tie_bin,
                           rnd_off_bin >> (shift - 1),
                           obj.bdata % 2)
        obj.bdata += rnd_off
        obj.bdata = obj.mask_bitwidth()
        return obj

    def truncate_msb(self, bw: int) -> FixedPoint:
        """
        Truncate the FixedPoint from the left (MSB) to a specified bit width.
        The current bit width will not be replaced if the new value is larger.
        The absolute position of the fixed point is preserved.

        :param bw: New bit width of the FixedPoint
        :return: A new FixedPoint instance.
        """
        bdata = self.bdata.astype(self.dtype, copy=True)
        return self.__class__(bw, self.fw, bdata, disbin=True, ofmode=self.ofmode)

    def sum(self, axis: int) -> FixedPoint:
        """
        Sums the data along the give axis by simulating step-bey-step addition. The number of hardware addition
        operations would be ceil(log2(n_elements))

        :param axis: Axis along which to sum.
        :return: A new FixedPoint instance.
        """
        n_elements = self.bdata.shape[axis]
        nadds = int(np.ceil(np.log2(n_elements)))
        return self.__class__(self.bw + nadds, self.fw, self.bdata.sum(axis=axis), disbin=True, ofmode=self.ofmode)

    def bit_reverse(self) -> FixedPoint:
        """
        Revereses the bits in the bdata.
        :return: A new FixedPoint instance.
        """
        return self.copy(new_bdata=bit_reverse(self.bdata, self.bw))

    def shift_insert(self, bdata_insert: np.ndarray) -> FixedPoint:
        """
        Shifts the bdata by one position in the 0 axis (by discarding the last entry), and inserts
        a new entry in the beginning. This is used to simulate the data flow through the buffer.
        :param bdata_insert:
        :return: A new FixedPoint instance.
        """
        if bdata_insert.shape != self.bdata[:, 0].shape:
            raise ValueError(f"Passed data does not fit the expected shape of {self.bdata[:, 0].shape}")
        bdata = np.empty(self.bdata.shape, dtype=self.dtype)
        bdata[:, 1:] = self.bdata[:, :-1]
        bdata[:, 0] = bdata_insert
        return self.copy(new_bdata=bdata)
