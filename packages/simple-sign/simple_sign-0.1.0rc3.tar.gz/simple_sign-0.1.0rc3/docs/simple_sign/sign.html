<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.simple_sign.sign API documentation</title>
<meta name="description" content="Orcfax simple sign." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.simple_sign.sign</code></h1>
</header>
<section id="section-intro">
<p>Orcfax simple sign.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Orcfax simple sign.&#34;&#34;&#34;

# pylint: disable=W0613

import argparse
import logging
import os
import sys
import time
from typing import Final

import pycardano as pyc

try:
    from src.simple_sign.version import get_version
except ModuleNotFoundError:
    try:
        from version import get_version
    except ModuleNotFoundError:
        from simple_sign.version import get_version

# Set up logging.
logging.basicConfig(
    format=&#34;%(asctime)-15s %(levelname)s :: %(filename)s:%(lineno)s:%(funcName)s() :: %(message)s&#34;,  # noqa: E501
    datefmt=&#34;%Y-%m-%d %H:%M:%S&#34;,
    level=&#34;INFO&#34;,
    handlers=[
        logging.StreamHandler(),
    ],
)

# Format logs using UTC time.
logging.Formatter.converter = time.gmtime


logger = logging.getLogger(__name__)


KNOWN_SIGNERS_CONFIG: Final[str] = &#34;CIP8_NOTARIES&#34;
KUPO_URL: Final[str] = &#34;KUPO_URL_NOTARIES&#34;


class UnknownSigningKey(Exception):
    &#34;&#34;&#34;Exception to raise when the signing key is unknown.&#34;&#34;&#34;


def retrieve_aliased(pkey: str) -&gt; str:
    &#34;&#34;&#34;Retrieve another public key aliased by the given lookup.

    The result might then be used to verify using one of the other
    methods in this library, e.g.

    1. lookup aliased staking key.
    2. lookup staking key in license pool.
    3. if not exists, raise exception, else, pass.

    We want to do this on an address by address basis. The difficulty
    is consistent parsing of metadata that allows this function to be
    broadly applicable across functions.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading staked values is not yet implemented&#34;)


def signature_in_staked_pool(
    pkey: str, token_policy_id: str, min_stake: int
) -&gt; bool:
    &#34;&#34;&#34;Validate whether the signing key belongs to a someone who has
    enough stake in a given token.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading staked values is not yet implemented&#34;)


def signature_in_license_pool(pkey: str, policy_id: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those in a pool of
    licenses associated with the project and return True if so.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading from license pool is not yet implemented&#34;)


def signature_in_constitution_datum_utxo(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those a list of
    addresses in a given constitution UTxO.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading from datum is not yet implemented&#34;)


def signature_in_constitution_config(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those listed in a
    configuration file.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;reading from a constitution config is not yet implemented&#34;
    )


def retrieve_env_notaries() -&gt; list:
    &#34;&#34;&#34;Retrieve notaries from the environment.&#34;&#34;&#34;
    notaries_env = os.getenv(KNOWN_SIGNERS_CONFIG, &#34;&#34;)
    if not notaries_env:
        return []
    return [notary.strip() for notary in notaries_env.split(&#34;,&#34;)]


def signature_in_dapp_environment(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those configured in
    the environment of the dApp.

    Largely a method for early prototyping. This isn&#39;t the most secure
    approach to doing this and especially not for use in decentralized
    systems. This check is only for projects with complete control over
    their own project.
    &#34;&#34;&#34;
    notaries = retrieve_env_notaries()
    if pkey.strip() not in notaries:
        raise UnknownSigningKey(f&#34;{pkey} is an unknown key&#34;)
    return True


def sign_with_key(data: str, signing_key: str) -&gt; str:
    &#34;&#34;&#34;Sign with an signing key.&#34;&#34;&#34;
    skey = pyc.SigningKey.from_json(signing_key)
    vkey = pyc.VerificationKey.from_signing_key(skey)
    logger.info(&#34;signing with addr: %s&#34;, pyc.Address(vkey.hash()))
    return pyc.sign(data, skey)


def signing_handler(data: str, signing_key: str) -&gt; str:
    &#34;&#34;&#34;Handle signing functions.&#34;&#34;&#34;
    return sign_with_key(data, signing_key)


def verify_signature(data: str) -&gt; dict:
    &#34;&#34;&#34;Verify a signature with an address.&#34;&#34;&#34;
    try:
        status = pyc.verify(data)
    except (TypeError, ValueError) as err:
        # Message might not be invalid signed-CBOR or simply unexpected
        # data.
        logger.info(&#34;cannot decode message: %s&#39;&#39; (%s)&#34;, data, err)
        return {
            &#34;verified&#34;: False,
            &#34;message&#34;: None,
            &#34;signing_address&#34;: None,
        }
    # Message from pycardano does not treat address as a string.
    return {
        &#34;verified&#34;: status[&#34;verified&#34;],
        &#34;message&#34;: f&#34;{status[&#39;message&#39;]}&#34;,
        &#34;signing_address&#34;: f&#34;{status[&#39;signing_address&#39;]}&#34;,
    }


def verify_handler(data: str) -&gt; dict:
    &#34;&#34;&#34;Verify input data.&#34;&#34;&#34;
    return verify_signature(data)


def main() -&gt; None:
    &#34;&#34;&#34;Primary entry point for this script.

    Useful article on sub-commands (which are strangely harder than they should be):

    ```text
        https://dev.to/taikedz/ive-parked-my-side-projects-3o62
    ```

    &#34;&#34;&#34;
    arg_sign: Final[str] = &#34;sign&#34;
    arg_verify: Final[str] = &#34;verify&#34;
    arg_version: Final[str] = &#34;version&#34;
    parser = argparse.ArgumentParser(
        prog=&#34;simple signer&#34;,
        description=&#34;provides helper functions signing simple data using Cardano primitives&#34;,
        epilog=&#34;for more information visit https://orcfax.io/&#34;,
    )
    subparsers = parser.add_subparsers(dest=&#34;cmd&#34;)
    verify = subparsers.add_parser(arg_verify)
    sign = subparsers.add_parser(arg_sign)
    subparsers.add_parser(arg_version)
    verify.add_argument(&#34;-d&#34;, &#34;--data&#34;, type=str, help=&#34;data to verify&#34;)
    verify.add_argument(
        &#34;-l&#34;,
        &#34;--list-env&#34;,
        action=&#34;store_true&#34;,
        help=f&#34;list known notaries in the environment at {KNOWN_SIGNERS_CONFIG}&#34;,
    )
    sign.add_argument(&#34;-d&#34;, &#34;--data&#34;, type=str, help=&#34;data to sign&#34;)
    sign.add_argument(&#34;-s&#34;, &#34;--signing_key&#34;, type=str, help=&#34;signing key&#34;)
    args = parser.parse_args()
    if not args.cmd:
        parser.print_usage()
        sys.exit()
    if args.cmd == arg_sign:
        print(signing_handler(args.data, args.signing_key))
    if args.cmd == arg_verify and not args.list_env:
        if not args.data:
            logger.error(&#34;supply data with the `-d` flag&#34;)
            sys.exit()
        print(verify_handler(args.data))
    if args.cmd == arg_version:
        print(f&#34;simple-sign version: {get_version()}&#34;)
    if args.cmd == &#34;verify&#34; and args.list_env:
        notaries = retrieve_env_notaries()
        if not notaries:
            logger.info(
                &#34;no environment notaries, ensure &#39;%s&#39; is configured&#34;,
                KNOWN_SIGNERS_CONFIG,
            )
            sys.exit()
        print(notaries)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="src.simple_sign.sign.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Primary entry point for this script.</p>
<p>Useful article on sub-commands (which are strangely harder than they should be):</p>
<pre><code class="language-text">    https://dev.to/taikedz/ive-parked-my-side-projects-3o62
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main() -&gt; None:
    &#34;&#34;&#34;Primary entry point for this script.

    Useful article on sub-commands (which are strangely harder than they should be):

    ```text
        https://dev.to/taikedz/ive-parked-my-side-projects-3o62
    ```

    &#34;&#34;&#34;
    arg_sign: Final[str] = &#34;sign&#34;
    arg_verify: Final[str] = &#34;verify&#34;
    arg_version: Final[str] = &#34;version&#34;
    parser = argparse.ArgumentParser(
        prog=&#34;simple signer&#34;,
        description=&#34;provides helper functions signing simple data using Cardano primitives&#34;,
        epilog=&#34;for more information visit https://orcfax.io/&#34;,
    )
    subparsers = parser.add_subparsers(dest=&#34;cmd&#34;)
    verify = subparsers.add_parser(arg_verify)
    sign = subparsers.add_parser(arg_sign)
    subparsers.add_parser(arg_version)
    verify.add_argument(&#34;-d&#34;, &#34;--data&#34;, type=str, help=&#34;data to verify&#34;)
    verify.add_argument(
        &#34;-l&#34;,
        &#34;--list-env&#34;,
        action=&#34;store_true&#34;,
        help=f&#34;list known notaries in the environment at {KNOWN_SIGNERS_CONFIG}&#34;,
    )
    sign.add_argument(&#34;-d&#34;, &#34;--data&#34;, type=str, help=&#34;data to sign&#34;)
    sign.add_argument(&#34;-s&#34;, &#34;--signing_key&#34;, type=str, help=&#34;signing key&#34;)
    args = parser.parse_args()
    if not args.cmd:
        parser.print_usage()
        sys.exit()
    if args.cmd == arg_sign:
        print(signing_handler(args.data, args.signing_key))
    if args.cmd == arg_verify and not args.list_env:
        if not args.data:
            logger.error(&#34;supply data with the `-d` flag&#34;)
            sys.exit()
        print(verify_handler(args.data))
    if args.cmd == arg_version:
        print(f&#34;simple-sign version: {get_version()}&#34;)
    if args.cmd == &#34;verify&#34; and args.list_env:
        notaries = retrieve_env_notaries()
        if not notaries:
            logger.info(
                &#34;no environment notaries, ensure &#39;%s&#39; is configured&#34;,
                KNOWN_SIGNERS_CONFIG,
            )
            sys.exit()
        print(notaries)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.retrieve_aliased"><code class="name flex">
<span>def <span class="ident">retrieve_aliased</span></span>(<span>pkey: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve another public key aliased by the given lookup.</p>
<p>The result might then be used to verify using one of the other
methods in this library, e.g.</p>
<ol>
<li>lookup aliased staking key.</li>
<li>lookup staking key in license pool.</li>
<li>if not exists, raise exception, else, pass.</li>
</ol>
<p>We want to do this on an address by address basis. The difficulty
is consistent parsing of metadata that allows this function to be
broadly applicable across functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_aliased(pkey: str) -&gt; str:
    &#34;&#34;&#34;Retrieve another public key aliased by the given lookup.

    The result might then be used to verify using one of the other
    methods in this library, e.g.

    1. lookup aliased staking key.
    2. lookup staking key in license pool.
    3. if not exists, raise exception, else, pass.

    We want to do this on an address by address basis. The difficulty
    is consistent parsing of metadata that allows this function to be
    broadly applicable across functions.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading staked values is not yet implemented&#34;)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.retrieve_env_notaries"><code class="name flex">
<span>def <span class="ident">retrieve_env_notaries</span></span>(<span>) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve notaries from the environment.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_env_notaries() -&gt; list:
    &#34;&#34;&#34;Retrieve notaries from the environment.&#34;&#34;&#34;
    notaries_env = os.getenv(KNOWN_SIGNERS_CONFIG, &#34;&#34;)
    if not notaries_env:
        return []
    return [notary.strip() for notary in notaries_env.split(&#34;,&#34;)]</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.sign_with_key"><code class="name flex">
<span>def <span class="ident">sign_with_key</span></span>(<span>data: str, signing_key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sign with an signing key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign_with_key(data: str, signing_key: str) -&gt; str:
    &#34;&#34;&#34;Sign with an signing key.&#34;&#34;&#34;
    skey = pyc.SigningKey.from_json(signing_key)
    vkey = pyc.VerificationKey.from_signing_key(skey)
    logger.info(&#34;signing with addr: %s&#34;, pyc.Address(vkey.hash()))
    return pyc.sign(data, skey)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signature_in_constitution_config"><code class="name flex">
<span>def <span class="ident">signature_in_constitution_config</span></span>(<span>pkey: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate whether signing key matches one of those listed in a
configuration file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_in_constitution_config(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those listed in a
    configuration file.
    &#34;&#34;&#34;
    raise NotImplementedError(
        &#34;reading from a constitution config is not yet implemented&#34;
    )</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signature_in_constitution_datum_utxo"><code class="name flex">
<span>def <span class="ident">signature_in_constitution_datum_utxo</span></span>(<span>pkey: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate whether signing key matches one of those a list of
addresses in a given constitution UTxO.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_in_constitution_datum_utxo(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those a list of
    addresses in a given constitution UTxO.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading from datum is not yet implemented&#34;)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signature_in_dapp_environment"><code class="name flex">
<span>def <span class="ident">signature_in_dapp_environment</span></span>(<span>pkey: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate whether signing key matches one of those configured in
the environment of the dApp.</p>
<p>Largely a method for early prototyping. This isn't the most secure
approach to doing this and especially not for use in decentralized
systems. This check is only for projects with complete control over
their own project.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_in_dapp_environment(pkey: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those configured in
    the environment of the dApp.

    Largely a method for early prototyping. This isn&#39;t the most secure
    approach to doing this and especially not for use in decentralized
    systems. This check is only for projects with complete control over
    their own project.
    &#34;&#34;&#34;
    notaries = retrieve_env_notaries()
    if pkey.strip() not in notaries:
        raise UnknownSigningKey(f&#34;{pkey} is an unknown key&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signature_in_license_pool"><code class="name flex">
<span>def <span class="ident">signature_in_license_pool</span></span>(<span>pkey: str, policy_id: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate whether signing key matches one of those in a pool of
licenses associated with the project and return True if so.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_in_license_pool(pkey: str, policy_id: str) -&gt; bool:
    &#34;&#34;&#34;Validate whether signing key matches one of those in a pool of
    licenses associated with the project and return True if so.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading from license pool is not yet implemented&#34;)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signature_in_staked_pool"><code class="name flex">
<span>def <span class="ident">signature_in_staked_pool</span></span>(<span>pkey: str, token_policy_id: str, min_stake: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate whether the signing key belongs to a someone who has
enough stake in a given token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signature_in_staked_pool(
    pkey: str, token_policy_id: str, min_stake: int
) -&gt; bool:
    &#34;&#34;&#34;Validate whether the signing key belongs to a someone who has
    enough stake in a given token.
    &#34;&#34;&#34;
    raise NotImplementedError(&#34;reading staked values is not yet implemented&#34;)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.signing_handler"><code class="name flex">
<span>def <span class="ident">signing_handler</span></span>(<span>data: str, signing_key: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Handle signing functions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signing_handler(data: str, signing_key: str) -&gt; str:
    &#34;&#34;&#34;Handle signing functions.&#34;&#34;&#34;
    return sign_with_key(data, signing_key)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.verify_handler"><code class="name flex">
<span>def <span class="ident">verify_handler</span></span>(<span>data: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Verify input data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_handler(data: str) -&gt; dict:
    &#34;&#34;&#34;Verify input data.&#34;&#34;&#34;
    return verify_signature(data)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.sign.verify_signature"><code class="name flex">
<span>def <span class="ident">verify_signature</span></span>(<span>data: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a signature with an address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_signature(data: str) -&gt; dict:
    &#34;&#34;&#34;Verify a signature with an address.&#34;&#34;&#34;
    try:
        status = pyc.verify(data)
    except (TypeError, ValueError) as err:
        # Message might not be invalid signed-CBOR or simply unexpected
        # data.
        logger.info(&#34;cannot decode message: %s&#39;&#39; (%s)&#34;, data, err)
        return {
            &#34;verified&#34;: False,
            &#34;message&#34;: None,
            &#34;signing_address&#34;: None,
        }
    # Message from pycardano does not treat address as a string.
    return {
        &#34;verified&#34;: status[&#34;verified&#34;],
        &#34;message&#34;: f&#34;{status[&#39;message&#39;]}&#34;,
        &#34;signing_address&#34;: f&#34;{status[&#39;signing_address&#39;]}&#34;,
    }</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.simple_sign.sign.UnknownSigningKey"><code class="flex name class">
<span>class <span class="ident">UnknownSigningKey</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception to raise when the signing key is unknown.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnknownSigningKey(Exception):
    &#34;&#34;&#34;Exception to raise when the signing key is unknown.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.simple_sign" href="index.html">src.simple_sign</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="src.simple_sign.sign.main" href="#src.simple_sign.sign.main">main</a></code></li>
<li><code><a title="src.simple_sign.sign.retrieve_aliased" href="#src.simple_sign.sign.retrieve_aliased">retrieve_aliased</a></code></li>
<li><code><a title="src.simple_sign.sign.retrieve_env_notaries" href="#src.simple_sign.sign.retrieve_env_notaries">retrieve_env_notaries</a></code></li>
<li><code><a title="src.simple_sign.sign.sign_with_key" href="#src.simple_sign.sign.sign_with_key">sign_with_key</a></code></li>
<li><code><a title="src.simple_sign.sign.signature_in_constitution_config" href="#src.simple_sign.sign.signature_in_constitution_config">signature_in_constitution_config</a></code></li>
<li><code><a title="src.simple_sign.sign.signature_in_constitution_datum_utxo" href="#src.simple_sign.sign.signature_in_constitution_datum_utxo">signature_in_constitution_datum_utxo</a></code></li>
<li><code><a title="src.simple_sign.sign.signature_in_dapp_environment" href="#src.simple_sign.sign.signature_in_dapp_environment">signature_in_dapp_environment</a></code></li>
<li><code><a title="src.simple_sign.sign.signature_in_license_pool" href="#src.simple_sign.sign.signature_in_license_pool">signature_in_license_pool</a></code></li>
<li><code><a title="src.simple_sign.sign.signature_in_staked_pool" href="#src.simple_sign.sign.signature_in_staked_pool">signature_in_staked_pool</a></code></li>
<li><code><a title="src.simple_sign.sign.signing_handler" href="#src.simple_sign.sign.signing_handler">signing_handler</a></code></li>
<li><code><a title="src.simple_sign.sign.verify_handler" href="#src.simple_sign.sign.verify_handler">verify_handler</a></code></li>
<li><code><a title="src.simple_sign.sign.verify_signature" href="#src.simple_sign.sign.verify_signature">verify_signature</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.simple_sign.sign.UnknownSigningKey" href="#src.simple_sign.sign.UnknownSigningKey">UnknownSigningKey</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
