<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>src.simple_sign.backend API documentation</title>
<meta name="description" content="Cardano handlers …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.simple_sign.backend</code></h1>
</header>
<section id="section-intro">
<p>Cardano handlers.</p>
<p>This is very much a work in progress aimed at a very small dApp where
the anticipated amount of data to be returned for a query is very
small. The concept of a backend is not really fleshed out either and
so remains unexported until an interface is implemented or some other
useful/interesting concept.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Cardano handlers.

This is very much a work in progress aimed at a very small dApp where
the anticipated amount of data to be returned for a query is very
small. The concept of a backend is not really fleshed out either and
so remains unexported until an interface is implemented or some other
useful/interesting concept.
&#34;&#34;&#34;

import logging
from dataclasses import dataclass
from typing import Callable, Final

import cachetools.func
import pycardano as pyc
import pydantic
import requests


@dataclass
class ValidTx:
    slot: int
    tx_id: str
    address: str
    staking: str


logger = logging.getLogger(__name__)

BACKENDS: Final[list] = [&#34;kupo&#34;]


def _sum_dict(key: str, value: int, accumulator: dict):
    &#34;&#34;&#34;Increment values in a given dictionary&#34;&#34;&#34;
    if key not in accumulator:
        accumulator[key] = value
        return accumulator
    count = accumulator[key]
    count = count + value
    accumulator[key] = count
    return accumulator


def _get_staking_from_addr(addr: str) -&gt; str:
    &#34;&#34;&#34;Return a staking address if possible from a given address,
    otherwise, return the original address string.
    &#34;&#34;&#34;
    try:
        address = pyc.Address.from_primitive(addr)
        return str(
            pyc.Address(staking_part=address.staking_part, network=pyc.Network.MAINNET)
        )
    except pyc.exception.InvalidAddressInputException:
        return str(address)
    except TypeError as err:
        logger.error(&#34;cannot convert &#39;%s&#39; (%s)&#34;, addr, err)
        return str(addr)


class BackendContext:
    &#34;&#34;&#34;Backend interfaces.

    NB. this will probably prove to be a naive implementation of this
    sort of thing, but lets see. Learning from PyCardano.
    &#34;&#34;&#34;

    def _retrieve_unspent_utxos(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from the backend.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_staked_holders(self, token_policy: str) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_nft_holders(
        self, policy: str, deny_list: list, seek_addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_metadata(
        self, value: int, policy: str, tag: str, callback: Callable = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve metadata from the backend.&#34;&#34;&#34;
        raise NotImplementedError()


class KupoContext(BackendContext):
    &#34;&#34;&#34;Kupo backend.&#34;&#34;&#34;

    def __init__(
        self,
        base_url: str,
        port: int,
    ):
        &#34;&#34;&#34;Initialize this thing...&#34;&#34;&#34;
        self._base_url = base_url
        self._port = port

    @cachetools.func.ttl_cache(ttl=60)
    def _retrieve_unspent_utxos(self, addr: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from Kupo.

        NB. Kupo must be configured to capture sparingly.
        &#34;&#34;&#34;
        if not addr:
            resp = requests.get(
                f&#34;{self._base_url}:{self._port}/matches?unspent&#34;, timeout=30
            )
            return resp.json()
        resp = requests.get(
            f&#34;{self._base_url}:{self._port}/matches/{addr}?unspent&#34;, timeout=30
        )
        return resp.json()

    def _retrieve_metadata(self, tag: str, tx_list: list[ValidTx]):
        &#34;&#34;&#34;Return metadata based on slot and transaction ID. This is
        very much a Kupo-centric approach. Metadata is not indexed
        locally and instead needs to be retrieved directly from
        a node.

        IMPORTANT: The metadata is modified here to provide information
        about the source address. This is so that the data remains
        accurately coupled with what is retrieved. We can&#39;t do this
        with Kupo easily otherwise.
        &#34;&#34;&#34;
        md_list = []
        for tx in tx_list:
            resp = requests.get(
                f&#34;{self._base_url}:{self._port}/metadata/{tx.slot}?transaction_id={tx.tx_id}&#34;,
                timeout=30,
            )
            if not resp.json():
                return md_list
            md_dict = resp.json()
            try:
                _ = md_dict[0][&#34;schema&#34;][tag]
            except (IndexError, KeyError):
                return md_list
            md_dict[0][&#34;address&#34;] = tx.address
            md_dict[0][&#34;staking&#34;] = tx.staking
            md_dict[0][&#34;transaction&#34;] = tx.tx_id
            md_list.append(md_dict[0])
        return md_list

    def retrieve_staked_holders(self, token_policy: str, seek_addr: str = None) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        addresses_with_fact = {}
        for item in unspent:
            addr = item[&#34;address&#34;]
            if seek_addr and addr != seek_addr:
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            staking = _get_staking_from_addr(addr)
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, value in assets.items():
                if token_policy in key:
                    addresses_with_fact = _sum_dict(staking, value, addresses_with_fact)
        return addresses_with_fact

    def retrieve_nft_holders(
        self, policy: str, deny_list: list = None, seek_addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.

        Filtering can be performed elsewhere, but a deny_list is used
        to remove some results that are unhelpful, e.g. the minting
        address if desired.
        &#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        holders = {}
        for item in unspent:
            addr = item[&#34;address&#34;]
            if seek_addr and addr != seek_addr:
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            staking = _get_staking_from_addr(addr)
            if addr in deny_list:
                continue
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, _ in assets.items():
                if not key.startswith(policy):
                    continue
                holders[key] = staking
        return holders

    @staticmethod
    def _get_valid_txs(unspent: list[dict], value: int, policy: str) -&gt; list[ValidTx]:
        &#34;&#34;&#34;Retrieve a list of valid transactions according to our
        policy rules.
        &#34;&#34;&#34;
        valid_txs = []
        if not unspent:
            return valid_txs
        for item in unspent:
            coins = item[&#34;value&#34;][&#34;coins&#34;]
            if coins != value:
                continue
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for asset in assets:
                if policy not in asset:
                    continue
                logger.error(policy)
                slot = item[&#34;created_at&#34;][&#34;slot_no&#34;]
                tx_id = item[&#34;transaction_id&#34;]
                address = item[&#34;address&#34;]
                valid_tx = ValidTx(
                    slot=slot,
                    tx_id=tx_id,
                    address=address,
                    staking=_get_staking_from_addr(address),
                )
                valid_txs.append(valid_tx)
        return valid_txs

    @pydantic.validate_call()
    def retrieve_metadata(
        self,
        value: int,
        policy: str,
        tag: str,
        callback: Callable = None,
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of aliased signing addresses. An aliased
        signing address is an address that has been setup using a
        protocol that allows NFT holders to participate in a network
        without having the key to their primary wallets hot/live on the
        decentralized node that they are operating.

        Kupo queries involved:

        ```sh
            curl -s &#34;http://0.0.0.0:1442/matches?unspent&#34;
            curl -s &#34;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&#34;
        ```

        Strategy 1: Retrieve all aliased keys for a policy ID.
                    Capture all values that match.
                    Capture all slots and tx ids for those values.
                    Retrieve metadata for all those txs.
                    Augment metadata with address and staking address.
                    Optionally, use the callback to process the data
                    according to a set of rules.
                    Return the metadata or a list of processed values to
                    the caller.

        NB. the callback must return a list to satisfy the output of the
        primary function.

        NB. this function is not as generic as it could be.

        &#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        valid_txs = self._get_valid_txs(unspent, value, policy)
        if not valid_txs:
            return valid_txs
        md = self._retrieve_metadata(tag, valid_txs)
        if not callback:
            return md
        return callback(md)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.simple_sign.backend.BackendContext"><code class="flex name class">
<span>class <span class="ident">BackendContext</span></span>
</code></dt>
<dd>
<div class="desc"><p>Backend interfaces.</p>
<p>NB. this will probably prove to be a naive implementation of this
sort of thing, but lets see. Learning from PyCardano.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BackendContext:
    &#34;&#34;&#34;Backend interfaces.

    NB. this will probably prove to be a naive implementation of this
    sort of thing, but lets see. Learning from PyCardano.
    &#34;&#34;&#34;

    def _retrieve_unspent_utxos(self) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from the backend.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_staked_holders(self, token_policy: str) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_nft_holders(
        self, policy: str, deny_list: list, seek_addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.
        &#34;&#34;&#34;
        raise NotImplementedError()

    def retrieve_metadata(
        self, value: int, policy: str, tag: str, callback: Callable = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve metadata from the backend.&#34;&#34;&#34;
        raise NotImplementedError()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="src.simple_sign.backend.KupoContext" href="#src.simple_sign.backend.KupoContext">KupoContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.simple_sign.backend.BackendContext.retrieve_metadata"><code class="name flex">
<span>def <span class="ident">retrieve_metadata</span></span>(<span>self, value: int, policy: str, tag: str, callback: Callable = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve metadata from the backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_metadata(
    self, value: int, policy: str, tag: str, callback: Callable = None
) -&gt; list:
    &#34;&#34;&#34;Retrieve metadata from the backend.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="src.simple_sign.backend.BackendContext.retrieve_nft_holders"><code class="name flex">
<span>def <span class="ident">retrieve_nft_holders</span></span>(<span>self, policy: str, deny_list: list, seek_addr: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of NFT holders, e.g. a license to operate
a decentralized node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_nft_holders(
    self, policy: str, deny_list: list, seek_addr: str = None
) -&gt; list:
    &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
    a decentralized node.
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="src.simple_sign.backend.BackendContext.retrieve_staked_holders"><code class="name flex">
<span>def <span class="ident">retrieve_staked_holders</span></span>(<span>self, token_policy: str) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of staked holders against a given CNT.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_staked_holders(self, token_policy: str) -&gt; list:
    &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="src.simple_sign.backend.KupoContext"><code class="flex name class">
<span>class <span class="ident">KupoContext</span></span>
<span>(</span><span>base_url: str, port: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Kupo backend.</p>
<p>Initialize this thing&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KupoContext(BackendContext):
    &#34;&#34;&#34;Kupo backend.&#34;&#34;&#34;

    def __init__(
        self,
        base_url: str,
        port: int,
    ):
        &#34;&#34;&#34;Initialize this thing...&#34;&#34;&#34;
        self._base_url = base_url
        self._port = port

    @cachetools.func.ttl_cache(ttl=60)
    def _retrieve_unspent_utxos(self, addr: str = &#34;&#34;) -&gt; dict:
        &#34;&#34;&#34;Retrieve unspent utxos from Kupo.

        NB. Kupo must be configured to capture sparingly.
        &#34;&#34;&#34;
        if not addr:
            resp = requests.get(
                f&#34;{self._base_url}:{self._port}/matches?unspent&#34;, timeout=30
            )
            return resp.json()
        resp = requests.get(
            f&#34;{self._base_url}:{self._port}/matches/{addr}?unspent&#34;, timeout=30
        )
        return resp.json()

    def _retrieve_metadata(self, tag: str, tx_list: list[ValidTx]):
        &#34;&#34;&#34;Return metadata based on slot and transaction ID. This is
        very much a Kupo-centric approach. Metadata is not indexed
        locally and instead needs to be retrieved directly from
        a node.

        IMPORTANT: The metadata is modified here to provide information
        about the source address. This is so that the data remains
        accurately coupled with what is retrieved. We can&#39;t do this
        with Kupo easily otherwise.
        &#34;&#34;&#34;
        md_list = []
        for tx in tx_list:
            resp = requests.get(
                f&#34;{self._base_url}:{self._port}/metadata/{tx.slot}?transaction_id={tx.tx_id}&#34;,
                timeout=30,
            )
            if not resp.json():
                return md_list
            md_dict = resp.json()
            try:
                _ = md_dict[0][&#34;schema&#34;][tag]
            except (IndexError, KeyError):
                return md_list
            md_dict[0][&#34;address&#34;] = tx.address
            md_dict[0][&#34;staking&#34;] = tx.staking
            md_dict[0][&#34;transaction&#34;] = tx.tx_id
            md_list.append(md_dict[0])
        return md_list

    def retrieve_staked_holders(self, token_policy: str, seek_addr: str = None) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of staked holders against a given CNT.&#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        addresses_with_fact = {}
        for item in unspent:
            addr = item[&#34;address&#34;]
            if seek_addr and addr != seek_addr:
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            staking = _get_staking_from_addr(addr)
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, value in assets.items():
                if token_policy in key:
                    addresses_with_fact = _sum_dict(staking, value, addresses_with_fact)
        return addresses_with_fact

    def retrieve_nft_holders(
        self, policy: str, deny_list: list = None, seek_addr: str = None
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
        a decentralized node.

        Filtering can be performed elsewhere, but a deny_list is used
        to remove some results that are unhelpful, e.g. the minting
        address if desired.
        &#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        holders = {}
        for item in unspent:
            addr = item[&#34;address&#34;]
            if seek_addr and addr != seek_addr:
                # don&#39;t process further than we have to if we&#39;re only
                # looking for a single address.
                continue
            staking = _get_staking_from_addr(addr)
            if addr in deny_list:
                continue
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for key, _ in assets.items():
                if not key.startswith(policy):
                    continue
                holders[key] = staking
        return holders

    @staticmethod
    def _get_valid_txs(unspent: list[dict], value: int, policy: str) -&gt; list[ValidTx]:
        &#34;&#34;&#34;Retrieve a list of valid transactions according to our
        policy rules.
        &#34;&#34;&#34;
        valid_txs = []
        if not unspent:
            return valid_txs
        for item in unspent:
            coins = item[&#34;value&#34;][&#34;coins&#34;]
            if coins != value:
                continue
            assets = item[&#34;value&#34;][&#34;assets&#34;]
            for asset in assets:
                if policy not in asset:
                    continue
                logger.error(policy)
                slot = item[&#34;created_at&#34;][&#34;slot_no&#34;]
                tx_id = item[&#34;transaction_id&#34;]
                address = item[&#34;address&#34;]
                valid_tx = ValidTx(
                    slot=slot,
                    tx_id=tx_id,
                    address=address,
                    staking=_get_staking_from_addr(address),
                )
                valid_txs.append(valid_tx)
        return valid_txs

    @pydantic.validate_call()
    def retrieve_metadata(
        self,
        value: int,
        policy: str,
        tag: str,
        callback: Callable = None,
    ) -&gt; list:
        &#34;&#34;&#34;Retrieve a list of aliased signing addresses. An aliased
        signing address is an address that has been setup using a
        protocol that allows NFT holders to participate in a network
        without having the key to their primary wallets hot/live on the
        decentralized node that they are operating.

        Kupo queries involved:

        ```sh
            curl -s &#34;http://0.0.0.0:1442/matches?unspent&#34;
            curl -s &#34;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&#34;
        ```

        Strategy 1: Retrieve all aliased keys for a policy ID.
                    Capture all values that match.
                    Capture all slots and tx ids for those values.
                    Retrieve metadata for all those txs.
                    Augment metadata with address and staking address.
                    Optionally, use the callback to process the data
                    according to a set of rules.
                    Return the metadata or a list of processed values to
                    the caller.

        NB. the callback must return a list to satisfy the output of the
        primary function.

        NB. this function is not as generic as it could be.

        &#34;&#34;&#34;
        unspent = self._retrieve_unspent_utxos()
        valid_txs = self._get_valid_txs(unspent, value, policy)
        if not valid_txs:
            return valid_txs
        md = self._retrieve_metadata(tag, valid_txs)
        if not callback:
            return md
        return callback(md)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="src.simple_sign.backend.KupoContext.retrieve_metadata"><code class="name flex">
<span>def <span class="ident">retrieve_metadata</span></span>(<span>self, value: int, policy: str, tag: str, callback: Callable = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of aliased signing addresses. An aliased
signing address is an address that has been setup using a
protocol that allows NFT holders to participate in a network
without having the key to their primary wallets hot/live on the
decentralized node that they are operating.</p>
<p>Kupo queries involved:</p>
<pre><code class="language-sh">    curl -s &quot;http://0.0.0.0:1442/matches?unspent&quot;
    curl -s &quot;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&quot;
</code></pre>
<p>Strategy 1: Retrieve all aliased keys for a policy ID.
Capture all values that match.
Capture all slots and tx ids for those values.
Retrieve metadata for all those txs.
Augment metadata with address and staking address.
Optionally, use the callback to process the data
according to a set of rules.
Return the metadata or a list of processed values to
the caller.</p>
<p>NB. the callback must return a list to satisfy the output of the
primary function.</p>
<p>NB. this function is not as generic as it could be.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@pydantic.validate_call()
def retrieve_metadata(
    self,
    value: int,
    policy: str,
    tag: str,
    callback: Callable = None,
) -&gt; list:
    &#34;&#34;&#34;Retrieve a list of aliased signing addresses. An aliased
    signing address is an address that has been setup using a
    protocol that allows NFT holders to participate in a network
    without having the key to their primary wallets hot/live on the
    decentralized node that they are operating.

    Kupo queries involved:

    ```sh
        curl -s &#34;http://0.0.0.0:1442/matches?unspent&#34;
        curl -s &#34;http://0.0.0.0:1442/metadata/{slot_id}?transaction_id={}&#34;
    ```

    Strategy 1: Retrieve all aliased keys for a policy ID.
                Capture all values that match.
                Capture all slots and tx ids for those values.
                Retrieve metadata for all those txs.
                Augment metadata with address and staking address.
                Optionally, use the callback to process the data
                according to a set of rules.
                Return the metadata or a list of processed values to
                the caller.

    NB. the callback must return a list to satisfy the output of the
    primary function.

    NB. this function is not as generic as it could be.

    &#34;&#34;&#34;
    unspent = self._retrieve_unspent_utxos()
    valid_txs = self._get_valid_txs(unspent, value, policy)
    if not valid_txs:
        return valid_txs
    md = self._retrieve_metadata(tag, valid_txs)
    if not callback:
        return md
    return callback(md)</code></pre>
</details>
</dd>
<dt id="src.simple_sign.backend.KupoContext.retrieve_nft_holders"><code class="name flex">
<span>def <span class="ident">retrieve_nft_holders</span></span>(<span>self, policy: str, deny_list: list = None, seek_addr: str = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve a list of NFT holders, e.g. a license to operate
a decentralized node.</p>
<p>Filtering can be performed elsewhere, but a deny_list is used
to remove some results that are unhelpful, e.g. the minting
address if desired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retrieve_nft_holders(
    self, policy: str, deny_list: list = None, seek_addr: str = None
) -&gt; list:
    &#34;&#34;&#34;Retrieve a list of NFT holders, e.g. a license to operate
    a decentralized node.

    Filtering can be performed elsewhere, but a deny_list is used
    to remove some results that are unhelpful, e.g. the minting
    address if desired.
    &#34;&#34;&#34;
    unspent = self._retrieve_unspent_utxos()
    holders = {}
    for item in unspent:
        addr = item[&#34;address&#34;]
        if seek_addr and addr != seek_addr:
            # don&#39;t process further than we have to if we&#39;re only
            # looking for a single address.
            continue
        staking = _get_staking_from_addr(addr)
        if addr in deny_list:
            continue
        assets = item[&#34;value&#34;][&#34;assets&#34;]
        for key, _ in assets.items():
            if not key.startswith(policy):
                continue
            holders[key] = staking
    return holders</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></b></code>:
<ul class="hlist">
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_staked_holders" href="#src.simple_sign.backend.BackendContext.retrieve_staked_holders">retrieve_staked_holders</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="src.simple_sign.backend.ValidTx"><code class="flex name class">
<span>class <span class="ident">ValidTx</span></span>
<span>(</span><span>slot: int, tx_id: str, address: str, staking: str)</span>
</code></dt>
<dd>
<div class="desc"><p>ValidTx(slot: int, tx_id: str, address: str, staking: str)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ValidTx:
    slot: int
    tx_id: str
    address: str
    staking: str</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="src.simple_sign.backend.ValidTx.address"><code class="name">var <span class="ident">address</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.slot"><code class="name">var <span class="ident">slot</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.staking"><code class="name">var <span class="ident">staking</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="src.simple_sign.backend.ValidTx.tx_id"><code class="name">var <span class="ident">tx_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.simple_sign" href="index.html">src.simple_sign</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.simple_sign.backend.BackendContext" href="#src.simple_sign.backend.BackendContext">BackendContext</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_metadata" href="#src.simple_sign.backend.BackendContext.retrieve_metadata">retrieve_metadata</a></code></li>
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_nft_holders" href="#src.simple_sign.backend.BackendContext.retrieve_nft_holders">retrieve_nft_holders</a></code></li>
<li><code><a title="src.simple_sign.backend.BackendContext.retrieve_staked_holders" href="#src.simple_sign.backend.BackendContext.retrieve_staked_holders">retrieve_staked_holders</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.simple_sign.backend.KupoContext" href="#src.simple_sign.backend.KupoContext">KupoContext</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.KupoContext.retrieve_metadata" href="#src.simple_sign.backend.KupoContext.retrieve_metadata">retrieve_metadata</a></code></li>
<li><code><a title="src.simple_sign.backend.KupoContext.retrieve_nft_holders" href="#src.simple_sign.backend.KupoContext.retrieve_nft_holders">retrieve_nft_holders</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="src.simple_sign.backend.ValidTx" href="#src.simple_sign.backend.ValidTx">ValidTx</a></code></h4>
<ul class="">
<li><code><a title="src.simple_sign.backend.ValidTx.address" href="#src.simple_sign.backend.ValidTx.address">address</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.slot" href="#src.simple_sign.backend.ValidTx.slot">slot</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.staking" href="#src.simple_sign.backend.ValidTx.staking">staking</a></code></li>
<li><code><a title="src.simple_sign.backend.ValidTx.tx_id" href="#src.simple_sign.backend.ValidTx.tx_id">tx_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
