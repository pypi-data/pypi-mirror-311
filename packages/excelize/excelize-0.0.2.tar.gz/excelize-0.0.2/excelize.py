"""Copyright 2024 The excelize Authors. All rights reserved. Use of this source
code is governed by a BSD-style license that can be found in the LICENSE file.

Package excelize-py is a Python port of Go Excelize library, providing a set of
functions that allow you to write and read from XLAM / XLSM / XLSX / XLTM / XLTX
files. Supports reading and writing spreadsheet documents generated by Microsoft
Excelâ„¢ 2007 and later. Supports complex components by high compatibility, and
provided streaming API for generating or reading data from a worksheet with huge
amounts of data. This library needs Python version 3.7 or later.
"""

from dataclasses import fields
from datetime import datetime, date, time
from enum import Enum
from types import NoneType
from typing import Tuple, get_args, get_origin
import types_go
from types_py import *
from ctypes import (
    CDLL,
    c_char,
    c_int,
    c_char_p,
    POINTER,
    byref,
    c_ubyte,
    string_at,
    cast,
    create_string_buffer,
    pointer,
)
import os
import platform


def load_lib():
    system = platform.system().lower()
    arch = platform.architecture()[0]
    machine = platform.machine().lower()
    ext_map = {"linux": ".so", "darwin": ".dylib", "windows": ".dll"}
    arch_map = {
        "linux": {
            "64bit": {
                "x86_64": "amd64",
                "aarch64": "arm64",
            },
        },
        "darwin": {
            "64bit": {
                "x86_64": "amd64",
                "arm64": "arm64",
            },
        },
        "windows": {
            "64bit": {
                "x86_64": "amd64",
            },
        },
    }
    if system in ext_map and arch in arch_map.get(system, {}):
        arch_name = arch_map[system][arch].get(machine)
        if arch_name:
            return f"libexcelize.{arch_name}.{system}{ext_map[system]}"

    print("This platform or architecture is not supported.")
    exit(1)


lib = CDLL(os.path.join(os.path.dirname(__file__), load_lib()))
ENCODE = "utf-8"
__version__ = "0.0.1"
uppercase_words = ["xml"]


def py_to_base_ctype(py_value, c_type):
    return (
        c_type(py_value.encode(ENCODE)) if str is type(py_value) else c_type(py_value)
    )


def is_py_primitive_type(t: type) -> bool:
    return True if issubclass(t, Enum) else t in {int, float, bool, str, bytes, complex}


def snake_to_pascal(snake_str: str) -> str:
    return "".join(
        word.upper() if word.lower() in uppercase_words else word.capitalize()
        for word in snake_str.split("_")
    )


def c_value_to_py(ctypes_instance, py_instance):
    if ctypes_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if NoneType not in py_field_args:
            if is_py_primitive_type(py_field.type):
                c_val = getattr(ctypes_instance, c_field_name)
                if c_val:
                    setattr(
                        py_instance,
                        py_field_name,
                        (c_val.decode(ENCODE) if str is py_field.type else c_val),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                setattr(
                    py_instance,
                    py_field_name,
                    c_value_to_py(
                        getattr(ctypes_instance, c_field_name), py_field.type()
                    ),
                )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(ctypes_instance, c_field_name)
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        value = getattr(ctypes_instance, c_field_name)
                        setattr(
                            py_instance,
                            py_field_name,
                            (
                                value.contents.value.decode(ENCODE)
                                if str in py_field_args
                                else value.contents.value
                            ),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            py_instance,
                            py_field_name,
                            c_value_to_py(
                                value.contents,
                                py_field_args[0](),
                            ),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                if NoneType not in get_args(get_args(py_field_args[0])[0]):
                    # The Go data type array, for example: []excelize.Options or []string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(get_args(py_field_args[0])[0]):
                            # The Go basic data type array, for example: []string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(py_field_args[0])[0]
                                    else c_array[i]
                                )
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i], get_args(py_field_args[0])[0]()
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    py_list = []
                    l = getattr(ctypes_instance, c_field_name + "Len")
                    c_array = getattr(ctypes_instance, c_field_name)
                    if c_array:
                        if is_py_primitive_type(
                            get_args(get_args(py_field_args[0])[0])[0]
                        ):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                py_list.append(
                                    string_at(c_array[i]).decode(ENCODE)
                                    if str is get_args(get_args(py_field_args[0])[0])[0]
                                    else c_array[i].contents.value
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                py_list.append(
                                    c_value_to_py(
                                        c_array[i].contents,
                                        get_args(get_args(py_field_args[0])[0])[0](),
                                    ),
                                )
                        setattr(py_instance, py_field_name, py_list)
    return py_instance


def get_c_field_type(struct, field_name):
    for field in struct._fields_:
        if field[0] == field_name:
            return field[1]


def py_value_to_c(py_instance, ctypes_instance):
    if py_instance is None:
        return None
    for py_field in fields(py_instance):
        py_field_name = py_field.name
        c_field_name = snake_to_pascal(py_field.name)
        # The Go base type
        py_field_args = get_args(py_field.type)

        if NoneType not in py_field_args:
            if is_py_primitive_type(py_field.type):
                if hasattr(py_instance, py_field_name):
                    c_type = get_c_field_type(ctypes_instance, c_field_name)
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_to_base_ctype(getattr(py_instance, py_field_name), c_type),
                    )
                    continue
            else:
                # The Go struct, for example: excelize.Options, convert sub fields recursively
                c_type = get_c_field_type(ctypes_instance, c_field_name)
                if hasattr(py_instance, py_field_name):
                    setattr(
                        ctypes_instance,
                        c_field_name,
                        py_value_to_c(getattr(py_instance, py_field_name), c_type()),
                    )
        else:
            if get_origin(py_field_args[0]) is not list:
                # Pointer of the Go data type, for example: *excelize.Options or *string
                value = getattr(py_instance, py_field_name)
                c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                if value:
                    if any(is_py_primitive_type(arg) for arg in py_field_args):
                        # Pointer of the Go basic data type, for example: *string
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_to_base_ctype(value, c_type)),
                        )
                    else:
                        # Pointer of the Go struct, for example: *excelize.Options
                        setattr(
                            ctypes_instance,
                            c_field_name,
                            pointer(py_value_to_c(value, c_type())),
                        )
            else:
                # The Go data type array, for example:
                # []*excelize.Options, []excelize.Options, []string, []*string
                py_field_type = get_args(py_field_args[0])[0]
                if NoneType not in get_args(py_field_type):
                    # The Go data type array, for example: []excelize.Options or []string
                    c_type = get_c_field_type(ctypes_instance, c_field_name)._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (c_type * l)()
                        if is_py_primitive_type(py_field_type):
                            # The Go basic data type array, for example: []string
                            if str is py_field_type:
                                c_array_type = POINTER(c_char) * l
                                ctypes_instance.__setattr__(
                                    c_field_name,
                                    c_array_type(
                                        *[
                                            create_string_buffer(c.encode(ENCODE))
                                            for c in py_list
                                        ]
                                    ),
                                )
                            else:
                                for i in range(l):
                                    c_array.__setitem__(
                                        i, py_to_base_ctype(py_list[i], c_type)
                                    )
                                ctypes_instance.__setattr__(c_field_name, c_array)
                        else:
                            # The Go struct array, for example: []excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i, py_value_to_c(py_list[i], c_type())
                                )
                            ctypes_instance.__setattr__(c_field_name, c_array)
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))

                else:
                    # Pointer array of the Go data type, for example: []*excelize.Options or []*string
                    c_type = get_c_field_type(
                        ctypes_instance, c_field_name
                    )._type_._type_
                    py_list = getattr(py_instance, py_field_name)
                    if py_list:
                        l = len(py_list)
                        c_array = (POINTER(c_type) * l)()
                        if is_py_primitive_type(get_args(py_field_type)[0]):
                            # Pointer array of the Go basic data type, for example: []*string
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_to_base_ctype(py_list[i], c_type)),
                                )
                        else:
                            #  Pointer array of the Go struct, for example: []*excelize.Options
                            for i in range(l):
                                c_array.__setitem__(
                                    i,
                                    pointer(py_value_to_c(py_list[i], c_type())),
                                )
                        ctypes_instance.__setattr__(c_field_name + "Len", c_int(l))
                        ctypes_instance.__setattr__(c_field_name, c_array)
    return ctypes_instance


def py_value_to_c_interface(py_value):
    type_mappings = {
        int: lambda: Interface(type=1, integer=py_value),
        str: lambda: Interface(type=2, string=py_value),
        float: lambda: Interface(type=3, float64=py_value),
        bool: lambda: Interface(type=4, boolean=py_value),
        datetime: lambda: Interface(type=5, integer=int(py_value.timestamp())),
        date: lambda: Interface(
            type=5, integer=int(datetime.combine(py_value, time.min).timestamp())
        ),
    }
    interface = type_mappings.get(type(py_value), lambda: Interface())()
    return py_value_to_c(interface, types_go._Interface())


class File:
    file_index: int

    def __init__(self, file_index):
        self.file_index = file_index

    def save(self, *opts: Options) -> Exception | None:
        err, lib.Save.restype = None, c_char_p
        if len(opts) > 0:
            options = py_value_to_c(opts[0], types_go._Options())
            err = lib.Save(self.file_index, byref(options)).decode(ENCODE)
            return None if err == "" else err
        err = lib.Save(self.file_index, POINTER(types_go._Options)()).decode(ENCODE)
        return None if err == "" else Exception(err)

    def save_as(self, filename: str, *opts: Options) -> Exception | None:
        err, lib.SaveAs.restype = None, c_char_p
        if len(opts) > 0:
            options = py_value_to_c(opts[0], types_go._Options())
            err = lib.SaveAs(
                self.file_index, filename.encode(ENCODE), byref(options)
            ).decode(ENCODE)
            return None if err == "" else err
        err = lib.SaveAs(
            self.file_index, filename.encode(ENCODE), POINTER(types_go._Options)()
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def close(self) -> Exception | None:
        err, lib.Close.restype = None, c_char_p
        err = lib.Close(self.file_index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def new_sheet(self, sheet: str) -> Tuple[int, Exception | None]:
        lib.NewSheet.restype = types_go.NewSheetResult
        res = lib.NewSheet(self.file_index, sheet.encode(ENCODE))
        err = res.err.decode(ENCODE)
        return res.idx, None if err == "" else Exception(err)

    def new_style(self, style: Style) -> Tuple[int, Exception | None]:
        lib.NewStyle.restype = types_go.NewStyleResult
        options = py_value_to_c(style, types_go._Style())
        res = lib.NewStyle(self.file_index, byref(options))
        err = res.err.decode(ENCODE)
        return res.style, None if err == "" else Exception(err)

    def get_style(self, style_id: int) -> Tuple[Style | None, Exception | None]:
        lib.GetStyle.restype = types_go.GetStyleResult
        res = lib.GetStyle(self.file_index, c_int(style_id))
        err = res.err.decode(ENCODE)
        if err == "":
            return c_value_to_py(res.style, Style()), None
        return None, Exception(err)

    def set_active_sheet(self, index: int) -> Exception | None:
        err, lib.SetActiveSheet.restype = None, c_char_p
        err = lib.SetActiveSheet(self.file_index, index).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_value(
        self, sheet: str, cell: str, value: None | int | str | bool | datetime | date
    ) -> Exception | None:
        lib.SetCellValue.restype = c_char_p
        err = lib.SetCellValue(
            self.file_index,
            sheet.encode(ENCODE),
            cell.encode(ENCODE),
            byref(py_value_to_c_interface(value)),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_cell_style(
        self, sheet: str, top_left_cell: str, bottom_right_cell: str, style_id: int
    ) -> Exception | None:
        lib.SetCellStyle.restype = c_char_p
        err = lib.SetCellStyle(
            self.file_index,
            sheet.encode(ENCODE),
            top_left_cell.encode(ENCODE),
            bottom_right_cell.encode(ENCODE),
            style_id,
        ).decode(ENCODE)
        return None if err == "" else Exception(err)

    def set_sheet_background_from_bytes(
        self, sheet: str, extension: str, picture: bytes
    ) -> Exception | None:
        lib.SetSheetBackgroundFromBytes.restype = c_char_p
        err = lib.SetSheetBackgroundFromBytes(
            self.file_index,
            sheet.encode(ENCODE),
            extension.encode(ENCODE),
            cast(picture, POINTER(c_ubyte)),
            len(picture),
        ).decode(ENCODE)
        return None if err == "" else Exception(err)


def new_file() -> File:
    """Create new file by default template.

    Returns:
        File: A populated spreadsheet file struct.
    """
    return File(lib.NewFile())


def open_file(filename: str, *opts: Options) -> Tuple[File | None, Exception | None]:
    """OpenFile take the name of a spreadsheet file and returns a populated
    spreadsheet file struct for it.
    """
    lib.OpenFile.restype, options = types_go.OptionsResult, None
    if len(opts) > 0:
        options = byref(py_value_to_c(opts[0], types_go._Options()))
    res = lib.OpenFile(filename.encode(ENCODE), options)
    err = res.err.decode(ENCODE)
    if err == "":
        return File(res.idx), None
    return None, Exception(err)
