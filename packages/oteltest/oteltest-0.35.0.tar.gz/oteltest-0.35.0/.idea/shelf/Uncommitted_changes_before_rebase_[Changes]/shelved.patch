Index: src/oteltest/private.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import glob\nimport importlib\nimport importlib.util\nimport inspect\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\nimport typing\nimport venv\nfrom logging import Logger\nfrom pathlib import Path\n\nfrom oteltest import OtelTest\nfrom oteltest.sink import GrpcSink, HttpSink, raise_if_port_in_use\nfrom oteltest.sink.handler import AccumulatingHandler\nfrom oteltest.version import __version__\n\n\ndef run(script_paths: [str], venv_parent_dir: str, json_dir: str, logger: Logger):\n    logger.info(\"oteltest version %s\", __version__)\n\n    temp_dir = venv_parent_dir or tempfile.mkdtemp()\n    logger.info(\"Using temp dir for venvs: %s\", temp_dir)\n\n    for script_path in script_paths:\n        if os.path.isdir(script_path):\n            handle_dir(script_path, temp_dir, json_dir, logger)\n        elif os.path.isfile(script_path):\n            handle_file(script_path, temp_dir, json_dir, logger)\n        else:\n            logger.warning(\"argument %s does not exist\", script_path)\n\n\ndef handle_dir(dir_path, temp_dir, json_dir, logger):\n    sys.path.append(dir_path)\n    for script in ls_scripts(dir_path):\n        logger.info(\"Setting up environment for script %s\", script)\n        setup_script_environment(temp_dir, dir_path, script, json_dir, logger)\n\n\ndef handle_file(file_path, temp_dir, json_dir, logger):\n    logger.info(\"Setting up environment for file %s\", file_path)\n    script_dir = os.path.dirname(file_path)\n    sys.path.append(script_dir)\n    setup_script_environment(\n        temp_dir, script_dir, os.path.basename(file_path), json_dir, logger\n    )\n\n\ndef ls_scripts(script_dir):\n    original_dir = os.getcwd()\n    os.chdir(script_dir)\n    scripts = glob.glob(\"*.py\")\n    os.chdir(original_dir)\n    return scripts\n\n\ndef setup_script_environment(\n    venv_parent: str, script_dir: str, script: str, json_dir_base: str, logger: Logger\n):\n    module_name = script[:-3]\n    module_path = os.path.join(script_dir, script)\n    oteltest_class = load_oteltest_class_for_script(module_name, module_path, logger)\n    if oteltest_class is None:\n        logger.info(\"No oteltest class present in [%s]\", module_name)\n        return\n    oteltest_instance = oteltest_class()\n\n    handler = AccumulatingHandler()\n    if hasattr(oteltest_instance, \"is_http\") and oteltest_instance.is_http():\n        raise_if_port_in_use(4318)\n        sink = HttpSink(handler, logger)\n    else:\n        raise_if_port_in_use(4317)\n        sink = GrpcSink(handler, logger)\n    sink.start()\n\n    script_venv = Venv(str(Path(venv_parent) / module_name), logger)\n    script_venv.create()\n\n    pip_path = script_venv.path_to_executable(\"pip\")\n\n    for req in oteltest_instance.requirements():\n        logger.info(\"Will install requirement: '%s'\", req)\n        run_subprocess([pip_path, \"install\", req], logger)\n\n    stdout, stderr, returncode = run_python_script(\n        start_subprocess, script_dir, script, oteltest_instance, script_venv, logger\n    )\n    print_subprocess_result(stdout, stderr, returncode, logger)\n\n    json_dir = os.path.join(script_dir, json_dir_base)\n    filename = get_next_json_file(json_dir, module_name)\n    logger.info(\"Will save telemetry to %s\", filename)\n    save_telemetry_json(json_dir, filename, handler.telemetry_to_json())\n\n    oteltest_instance.on_stop(handler.telemetry, stdout, stderr, returncode)\n    logger.info(\"PASSED: %s\", script)\n    sink.stop()\n\n\ndef get_next_json_file(path_str: str, module_name: str):\n    path = Path(path_str)\n    path.mkdir(exist_ok=True)\n    max_index = -1\n    for file in path.glob(f\"{module_name}.*.json\"):\n        last_part = file.stem.split(\".\")[-1]\n        if last_part.isdigit():\n            index = int(last_part)\n            if index > max_index:\n                max_index = index\n    return f\"{module_name}.{max_index + 1}.json\"\n\n\ndef save_telemetry_json(script_dir: str, file_name: str, json_str: str):\n    path = Path(script_dir) / file_name\n    with open(str(path), \"w\", encoding=\"utf-8\") as file:\n        file.write(json_str)\n\n\ndef run_python_script(\n    start_subprocess_func,\n    script_dir: str,\n    script: str,\n    oteltest_instance,\n    script_venv,\n    logger: Logger,\n) -> typing.Tuple[str, str, int]:\n    logger.info(\"Running python script: %s\", script)\n    python_script_cmd = [\n        script_venv.path_to_executable(\"python\"),\n        str(Path(script_dir) / script),\n    ]\n\n    wrapper_script = oteltest_instance.wrapper_command()\n    if wrapper_script:\n        python_script_cmd.insert(0, script_venv.path_to_executable(wrapper_script))\n\n    # typically python_script_cmd will be [\"opentelemetry-instrument\", \"python\", \"foo.py\"] but with full paths\n    logger.info(f\"Start subprocess: %s\", python_script_cmd)\n    proc = start_subprocess_func(\n        python_script_cmd, oteltest_instance.environment_variables()\n    )\n    timeout_seconds = oteltest_instance.on_start()\n    if timeout_seconds is None:\n        logger.info(\"Will wait for %s to finish by itself\", script)\n    else:\n        logger.info(\n            \"Will wait for %d seconds for %s to finish\", timeout_seconds, script\n        )\n    try:\n        stdout, stderr = proc.communicate(timeout=timeout_seconds)\n        return stdout, stderr, proc.returncode\n    except subprocess.TimeoutExpired as ex:\n        proc.kill()\n        logger.info(\"Script %s terminated\", script)\n        return decode(ex.stdout), decode(ex.stderr), proc.returncode\n\n\ndef start_subprocess(python_script_cmd, env):\n    return subprocess.Popen(\n        python_script_cmd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        text=True,\n        env=env,\n    )\n\n\ndef decode(b: typing.Optional[bytes]) -> str:\n    return b.decode(\"utf-8\") if b else \"\"\n\n\ndef run_subprocess(args, logger: Logger):\n    logger.info(\"Subprocess: %s\", args)\n    result = subprocess.run(\n        args,\n        capture_output=True,\n        text=True,\n        check=True,\n    )\n    print_subprocess_result(result.stdout, result.stderr, result.returncode, logger)\n\n\ndef print_subprocess_result(stdout: str, stderr: str, returncode: int, logger: Logger):\n    logger.info(\"Return Code: [%s]\", returncode)  # %s because can be None\n    logger.info(\"Standard Output:\")\n    if stdout:\n        print(stdout)\n    logger.info(\"Standard Error:\")\n    if stderr:\n        print(stderr)\n    logger.info(\"End Subprocess\")\n\n\ndef load_oteltest_class_for_script(module_name, module_path, logger: Logger):\n    logger.debug(\n        \"loading spec from file: module_name [%s] module_path [%s]\",\n        module_name,\n        module_path,\n    )\n    spec = importlib.util.spec_from_file_location(module_name, module_path)\n    logger.debug(\"spec loaded: [%s]\", spec)\n    module = importlib.util.module_from_spec(spec)\n    logger.debug(\"module loaded: [%s]\", module)\n    spec.loader.exec_module(module)\n    for attr_name in dir(module):\n        value = getattr(module, attr_name)\n        if is_test_class(value):\n            logger.debug(\"found test class: [%s]\", value)\n            return value\n    return None\n\n\ndef is_test_class(value):\n    return inspect.isclass(value) and (\n        is_strict_subclass(value) or \"OtelTest\" in value.__name__\n    )\n\n\ndef is_strict_subclass(value):\n    return (\n        issubclass(value, OtelTest)\n        and value is not OtelTest\n        and not inspect.isabstract(value)\n    )\n\n\nclass Venv:\n    def __init__(self, venv_dir, logger: Logger):\n        self.venv_dir = venv_dir\n        self.logger = logger\n\n    def create(self):\n        if os.path.exists(self.venv_dir):\n            self.logger.info(\n                \"Path to virtual env [%s] already exists, skipping creation\",\n                self.venv_dir,\n            )\n        else:\n            venv.create(self.venv_dir, with_pip=True)\n\n    def path_to_executable(self, executable_name: str):\n        return f\"{self.venv_dir}/bin/{executable_name}\"\n\n    def rm(self):\n        shutil.rmtree(self.venv_dir)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/oteltest/private.py b/src/oteltest/private.py
--- a/src/oteltest/private.py	(revision 928685dc456b4830deca4b83b99782fa970677cb)
+++ b/src/oteltest/private.py	(date 1732648363660)
@@ -96,8 +96,11 @@
     logger.info("Will save telemetry to %s", filename)
     save_telemetry_json(json_dir, filename, handler.telemetry_to_json())
 
-    oteltest_instance.on_stop(handler.telemetry, stdout, stderr, returncode)
-    logger.info("PASSED: %s", script)
+    try:
+        oteltest_instance.on_stop(handler.telemetry, stdout, stderr, returncode)
+        logger.info("PASSED: %s", script)
+    except AssertionError as ae:
+        logger.info("AssertionError: %s %s", script, ae)
     sink.stop()
 
 
