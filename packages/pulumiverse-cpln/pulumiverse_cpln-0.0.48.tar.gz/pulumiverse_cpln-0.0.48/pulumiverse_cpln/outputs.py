# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'CloudAccountAws',
    'CloudAccountAzure',
    'CloudAccountGcp',
    'CloudAccountNgs',
    'DomainRouteHeaders',
    'DomainRouteHeadersRequest',
    'DomainSpec',
    'DomainSpecPort',
    'DomainSpecPortCors',
    'DomainSpecPortCorsAllowOrigin',
    'DomainSpecPortTls',
    'DomainSpecPortTlsClientCertificate',
    'DomainSpecPortTlsServerCertificate',
    'DomainStatus',
    'DomainStatusDnsConfig',
    'DomainStatusEndpoint',
    'DomainStatusLocation',
    'GroupIdentityMatcher',
    'GroupMemberQuery',
    'GroupMemberQuerySpec',
    'GroupMemberQuerySpecTerm',
    'GvcControlplaneTracing',
    'GvcLightstepTracing',
    'GvcLoadBalancer',
    'GvcLoadBalancerRedirect',
    'GvcLoadBalancerRedirectClass',
    'GvcOtelTracing',
    'GvcSidecar',
    'IdentityAwsAccessPolicy',
    'IdentityAzureAccessPolicy',
    'IdentityAzureAccessPolicyRoleAssignment',
    'IdentityGcpAccessPolicy',
    'IdentityGcpAccessPolicyBinding',
    'IdentityNativeNetworkResource',
    'IdentityNativeNetworkResourceAwsPrivateLink',
    'IdentityNativeNetworkResourceGcpServiceConnect',
    'IdentityNetworkResource',
    'IdentityNgsAccessPolicy',
    'IdentityNgsAccessPolicyPub',
    'IdentityNgsAccessPolicyResp',
    'IdentityNgsAccessPolicySub',
    'IpSetLocation',
    'IpSetStatus',
    'IpSetStatusIpAddress',
    'LocationGeo',
    'Mk8sAddOns',
    'Mk8sAddOnsAwsEcr',
    'Mk8sAddOnsAwsEfs',
    'Mk8sAddOnsAwsElb',
    'Mk8sAddOnsAzureAcr',
    'Mk8sAddOnsAzureWorkloadIdentity',
    'Mk8sAddOnsLogs',
    'Mk8sAddOnsMetrics',
    'Mk8sAddOnsMetricsScrapeAnnotated',
    'Mk8sAddOnsNvidia',
    'Mk8sAwsProvider',
    'Mk8sAwsProviderAutoscaler',
    'Mk8sAwsProviderDeployRoleChain',
    'Mk8sAwsProviderImage',
    'Mk8sAwsProviderNetworking',
    'Mk8sAwsProviderNodePool',
    'Mk8sAwsProviderNodePoolOverrideImage',
    'Mk8sAwsProviderNodePoolTaint',
    'Mk8sDigitalOceanProvider',
    'Mk8sDigitalOceanProviderAutoscaler',
    'Mk8sDigitalOceanProviderNetworking',
    'Mk8sDigitalOceanProviderNodePool',
    'Mk8sDigitalOceanProviderNodePoolTaint',
    'Mk8sEphemeralProvider',
    'Mk8sEphemeralProviderNodePool',
    'Mk8sEphemeralProviderNodePoolTaint',
    'Mk8sFirewall',
    'Mk8sGenericProvider',
    'Mk8sGenericProviderNetworking',
    'Mk8sGenericProviderNodePool',
    'Mk8sGenericProviderNodePoolTaint',
    'Mk8sHetznerProvider',
    'Mk8sHetznerProviderAutoscaler',
    'Mk8sHetznerProviderDedicatedServerNodePool',
    'Mk8sHetznerProviderDedicatedServerNodePoolTaint',
    'Mk8sHetznerProviderNetworking',
    'Mk8sHetznerProviderNodePool',
    'Mk8sHetznerProviderNodePoolTaint',
    'Mk8sLambdalabsProvider',
    'Mk8sLambdalabsProviderAutoscaler',
    'Mk8sLambdalabsProviderNodePool',
    'Mk8sLambdalabsProviderNodePoolTaint',
    'Mk8sLambdalabsProviderUnmanagedNodePool',
    'Mk8sLambdalabsProviderUnmanagedNodePoolTaint',
    'Mk8sLinodeProvider',
    'Mk8sLinodeProviderAutoscaler',
    'Mk8sLinodeProviderNetworking',
    'Mk8sLinodeProviderNodePool',
    'Mk8sLinodeProviderNodePoolTaint',
    'Mk8sOblivusProvider',
    'Mk8sOblivusProviderAutoscaler',
    'Mk8sOblivusProviderNodePool',
    'Mk8sOblivusProviderNodePoolTaint',
    'Mk8sOblivusProviderUnmanagedNodePool',
    'Mk8sOblivusProviderUnmanagedNodePoolTaint',
    'Mk8sPaperspaceProvider',
    'Mk8sPaperspaceProviderAutoscaler',
    'Mk8sPaperspaceProviderNodePool',
    'Mk8sPaperspaceProviderNodePoolTaint',
    'Mk8sPaperspaceProviderUnmanagedNodePool',
    'Mk8sPaperspaceProviderUnmanagedNodePoolTaint',
    'Mk8sStatus',
    'Mk8sStatusAddOn',
    'Mk8sStatusAddOnAwsEcr',
    'Mk8sStatusAddOnAwsEf',
    'Mk8sStatusAddOnAwsElb',
    'Mk8sStatusAddOnAwsWorkloadIdentity',
    'Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig',
    'Mk8sStatusAddOnDashboard',
    'Mk8sStatusAddOnLog',
    'Mk8sStatusAddOnMetric',
    'Mk8sTritonProvider',
    'Mk8sTritonProviderAutoscaler',
    'Mk8sTritonProviderConnection',
    'Mk8sTritonProviderNetworking',
    'Mk8sTritonProviderNodePool',
    'Mk8sTritonProviderNodePoolTaint',
    'OrgAuthConfig',
    'OrgLoggingCloudWatchLogging',
    'OrgLoggingCoralogixLogging',
    'OrgLoggingDatadogLogging',
    'OrgLoggingElasticLogging',
    'OrgLoggingElasticLoggingAws',
    'OrgLoggingElasticLoggingElasticCloud',
    'OrgLoggingElasticLoggingGeneric',
    'OrgLoggingFluentdLogging',
    'OrgLoggingLogzioLogging',
    'OrgLoggingS3Logging',
    'OrgLoggingStackdriverLogging',
    'OrgLoggingSyslogLogging',
    'OrgObservability',
    'OrgSecurity',
    'OrgSecurityThreatDetection',
    'OrgSecurityThreatDetectionSyslog',
    'OrgStatus',
    'OrgTracingControlplaneTracing',
    'OrgTracingLightstepTracing',
    'OrgTracingOtelTracing',
    'PolicyBinding',
    'PolicyTargetQuery',
    'PolicyTargetQuerySpec',
    'PolicyTargetQuerySpecTerm',
    'SecretAws',
    'SecretAzureConnector',
    'SecretEcr',
    'SecretKeypair',
    'SecretNatsAccount',
    'SecretOpaque',
    'SecretTls',
    'SecretUserpass',
    'VolumeSetAutoscaling',
    'VolumeSetSnapshots',
    'VolumeSetStatus',
    'WorkloadContainer',
    'WorkloadContainerGpuNvidia',
    'WorkloadContainerLifecycle',
    'WorkloadContainerLifecyclePostStart',
    'WorkloadContainerLifecyclePostStartExec',
    'WorkloadContainerLifecyclePreStop',
    'WorkloadContainerLifecyclePreStopExec',
    'WorkloadContainerLivenessProbe',
    'WorkloadContainerLivenessProbeExec',
    'WorkloadContainerLivenessProbeGrpc',
    'WorkloadContainerLivenessProbeHttpGet',
    'WorkloadContainerLivenessProbeTcpSocket',
    'WorkloadContainerMetrics',
    'WorkloadContainerPort',
    'WorkloadContainerReadinessProbe',
    'WorkloadContainerReadinessProbeExec',
    'WorkloadContainerReadinessProbeGrpc',
    'WorkloadContainerReadinessProbeHttpGet',
    'WorkloadContainerReadinessProbeTcpSocket',
    'WorkloadContainerVolume',
    'WorkloadFirewallSpec',
    'WorkloadFirewallSpecExternal',
    'WorkloadFirewallSpecExternalOutboundAllowPort',
    'WorkloadFirewallSpecInternal',
    'WorkloadJob',
    'WorkloadLoadBalancer',
    'WorkloadLoadBalancerDirect',
    'WorkloadLoadBalancerDirectPort',
    'WorkloadLoadBalancerGeoLocation',
    'WorkloadLoadBalancerGeoLocationHeaders',
    'WorkloadLocalOption',
    'WorkloadLocalOptionAutoscaling',
    'WorkloadLocalOptionAutoscalingMulti',
    'WorkloadOptions',
    'WorkloadOptionsAutoscaling',
    'WorkloadOptionsAutoscalingMulti',
    'WorkloadRolloutOptions',
    'WorkloadSecurityOptions',
    'WorkloadSidecar',
    'WorkloadStatus',
    'WorkloadStatusHealthCheck',
    'WorkloadStatusLoadBalancer',
    'WorkloadStatusResolvedImage',
    'WorkloadStatusResolvedImageImage',
    'WorkloadStatusResolvedImageImageManifest',
    'GetGvcControlplaneTracingResult',
    'GetGvcLightstepTracingResult',
    'GetGvcLoadBalancerResult',
    'GetGvcLoadBalancerRedirectResult',
    'GetGvcLoadBalancerRedirectClassResult',
    'GetGvcOtelTracingResult',
    'GetGvcSidecarResult',
    'GetImageManifestResult',
    'GetImageManifestConfigResult',
    'GetImageManifestLayerResult',
    'GetImagesImageResult',
    'GetImagesImageManifestResult',
    'GetImagesImageManifestConfigResult',
    'GetImagesImageManifestLayerResult',
    'GetImagesQueryResult',
    'GetImagesQuerySpecResult',
    'GetImagesQuerySpecTermResult',
    'GetLocationGeoResult',
    'GetLocationsLocationResult',
    'GetLocationsLocationGeoResult',
    'GetSecretAwsResult',
    'GetSecretAzureConnectorResult',
    'GetSecretEcrResult',
    'GetSecretKeypairResult',
    'GetSecretNatsAccountResult',
    'GetSecretOpaqueResult',
    'GetSecretTlsResult',
    'GetSecretUserpassResult',
]

@pulumi.output_type
class CloudAccountAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str):
        CloudAccountAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class CloudAccountAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        CloudAccountAzure._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class CloudAccountGcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountGcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountGcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 project_id: str):
        CloudAccountGcp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            project_id=project_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             project_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'projectId' in kwargs:
            project_id = kwargs['projectId']

        _setter("project_id", project_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class CloudAccountNgs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudAccountNgs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudAccountNgs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: str):
        CloudAccountNgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> str:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainRouteHeaders(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 request: Optional['outputs.DomainRouteHeadersRequest'] = None):
        DomainRouteHeaders._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            request=request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             request: Optional['outputs.DomainRouteHeadersRequest'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if request is not None:
            _setter("request", request)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DomainRouteHeadersRequest']:
        return pulumi.get(self, "request")


@pulumi.output_type
class DomainRouteHeadersRequest(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 set: Optional[Mapping[str, str]] = None):
        DomainRouteHeadersRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            set=set,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             set: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if set is not None:
            _setter("set", set)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "set")


@pulumi.output_type
class DomainSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "acceptAllHosts":
            suggest = "accept_all_hosts"
        elif key == "dnsMode":
            suggest = "dns_mode"
        elif key == "gvcLink":
            suggest = "gvc_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ports: Sequence['outputs.DomainSpecPort'],
                 accept_all_hosts: Optional[bool] = None,
                 dns_mode: Optional[str] = None,
                 gvc_link: Optional[str] = None):
        DomainSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ports=ports,
            accept_all_hosts=accept_all_hosts,
            dns_mode=dns_mode,
            gvc_link=gvc_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ports: Sequence['outputs.DomainSpecPort'],
             accept_all_hosts: Optional[bool] = None,
             dns_mode: Optional[str] = None,
             gvc_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'acceptAllHosts' in kwargs:
            accept_all_hosts = kwargs['acceptAllHosts']
        if 'dnsMode' in kwargs:
            dns_mode = kwargs['dnsMode']
        if 'gvcLink' in kwargs:
            gvc_link = kwargs['gvcLink']

        _setter("ports", ports)
        if accept_all_hosts is not None:
            _setter("accept_all_hosts", accept_all_hosts)
        if dns_mode is not None:
            _setter("dns_mode", dns_mode)
        if gvc_link is not None:
            _setter("gvc_link", gvc_link)

    @property
    @pulumi.getter
    def ports(self) -> Sequence['outputs.DomainSpecPort']:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="acceptAllHosts")
    def accept_all_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "accept_all_hosts")

    @property
    @pulumi.getter(name="dnsMode")
    def dns_mode(self) -> Optional[str]:
        return pulumi.get(self, "dns_mode")

    @property
    @pulumi.getter(name="gvcLink")
    def gvc_link(self) -> Optional[str]:
        return pulumi.get(self, "gvc_link")


@pulumi.output_type
class DomainSpecPort(dict):
    def __init__(__self__, *,
                 tls: 'outputs.DomainSpecPortTls',
                 cors: Optional['outputs.DomainSpecPortCors'] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None):
        DomainSpecPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tls=tls,
            cors=cors,
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tls: 'outputs.DomainSpecPortTls',
             cors: Optional['outputs.DomainSpecPortCors'] = None,
             number: Optional[int] = None,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("tls", tls)
        if cors is not None:
            _setter("cors", cors)
        if number is not None:
            _setter("number", number)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def tls(self) -> 'outputs.DomainSpecPortTls':
        return pulumi.get(self, "tls")

    @property
    @pulumi.getter
    def cors(self) -> Optional['outputs.DomainSpecPortCors']:
        return pulumi.get(self, "cors")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class DomainSpecPortCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[str] = None):
        DomainSpecPortCors._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_credentials=allow_credentials,
            allow_headers=allow_headers,
            allow_methods=allow_methods,
            allow_origins=allow_origins,
            expose_headers=expose_headers,
            max_age=max_age,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_credentials: Optional[bool] = None,
             allow_headers: Optional[Sequence[str]] = None,
             allow_methods: Optional[Sequence[str]] = None,
             allow_origins: Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']] = None,
             expose_headers: Optional[Sequence[str]] = None,
             max_age: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'allowCredentials' in kwargs:
            allow_credentials = kwargs['allowCredentials']
        if 'allowHeaders' in kwargs:
            allow_headers = kwargs['allowHeaders']
        if 'allowMethods' in kwargs:
            allow_methods = kwargs['allowMethods']
        if 'allowOrigins' in kwargs:
            allow_origins = kwargs['allowOrigins']
        if 'exposeHeaders' in kwargs:
            expose_headers = kwargs['exposeHeaders']
        if 'maxAge' in kwargs:
            max_age = kwargs['maxAge']

        if allow_credentials is not None:
            _setter("allow_credentials", allow_credentials)
        if allow_headers is not None:
            _setter("allow_headers", allow_headers)
        if allow_methods is not None:
            _setter("allow_methods", allow_methods)
        if allow_origins is not None:
            _setter("allow_origins", allow_origins)
        if expose_headers is not None:
            _setter("expose_headers", expose_headers)
        if max_age is not None:
            _setter("max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence['outputs.DomainSpecPortCorsAllowOrigin']]:
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[str]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class DomainSpecPortCorsAllowOrigin(dict):
    def __init__(__self__, *,
                 exact: str):
        DomainSpecPortCorsAllowOrigin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("exact", exact)

    @property
    @pulumi.getter
    def exact(self) -> str:
        return pulumi.get(self, "exact")


@pulumi.output_type
class DomainSpecPortTls(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "serverCertificate":
            suggest = "server_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cipher_suites: Optional[Sequence[str]] = None,
                 client_certificate: Optional['outputs.DomainSpecPortTlsClientCertificate'] = None,
                 min_protocol_version: Optional[str] = None,
                 server_certificate: Optional['outputs.DomainSpecPortTlsServerCertificate'] = None):
        DomainSpecPortTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cipher_suites=cipher_suites,
            client_certificate=client_certificate,
            min_protocol_version=min_protocol_version,
            server_certificate=server_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cipher_suites: Optional[Sequence[str]] = None,
             client_certificate: Optional['outputs.DomainSpecPortTlsClientCertificate'] = None,
             min_protocol_version: Optional[str] = None,
             server_certificate: Optional['outputs.DomainSpecPortTlsServerCertificate'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cipherSuites' in kwargs:
            cipher_suites = kwargs['cipherSuites']
        if 'clientCertificate' in kwargs:
            client_certificate = kwargs['clientCertificate']
        if 'minProtocolVersion' in kwargs:
            min_protocol_version = kwargs['minProtocolVersion']
        if 'serverCertificate' in kwargs:
            server_certificate = kwargs['serverCertificate']

        if cipher_suites is not None:
            _setter("cipher_suites", cipher_suites)
        if client_certificate is not None:
            _setter("client_certificate", client_certificate)
        if min_protocol_version is not None:
            _setter("min_protocol_version", min_protocol_version)
        if server_certificate is not None:
            _setter("server_certificate", server_certificate)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional['outputs.DomainSpecPortTlsClientCertificate']:
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional['outputs.DomainSpecPortTlsServerCertificate']:
        return pulumi.get(self, "server_certificate")


@pulumi.output_type
class DomainSpecPortTlsClientCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsClientCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsClientCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        DomainSpecPortTlsClientCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        if secret_link is not None:
            _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainSpecPortTlsServerCertificate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretLink":
            suggest = "secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainSpecPortTlsServerCertificate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainSpecPortTlsServerCertificate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_link: Optional[str] = None):
        DomainSpecPortTlsServerCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_link=secret_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretLink' in kwargs:
            secret_link = kwargs['secretLink']

        if secret_link is not None:
            _setter("secret_link", secret_link)

    @property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[str]:
        return pulumi.get(self, "secret_link")


@pulumi.output_type
class DomainStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsConfigs":
            suggest = "dns_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_configs: Optional[Sequence['outputs.DomainStatusDnsConfig']] = None,
                 endpoints: Optional[Sequence['outputs.DomainStatusEndpoint']] = None,
                 fingerprint: Optional[str] = None,
                 locations: Optional[Sequence['outputs.DomainStatusLocation']] = None,
                 status: Optional[str] = None,
                 warning: Optional[str] = None):
        DomainStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_configs=dns_configs,
            endpoints=endpoints,
            fingerprint=fingerprint,
            locations=locations,
            status=status,
            warning=warning,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_configs: Optional[Sequence['outputs.DomainStatusDnsConfig']] = None,
             endpoints: Optional[Sequence['outputs.DomainStatusEndpoint']] = None,
             fingerprint: Optional[str] = None,
             locations: Optional[Sequence['outputs.DomainStatusLocation']] = None,
             status: Optional[str] = None,
             warning: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dnsConfigs' in kwargs:
            dns_configs = kwargs['dnsConfigs']

        if dns_configs is not None:
            _setter("dns_configs", dns_configs)
        if endpoints is not None:
            _setter("endpoints", endpoints)
        if fingerprint is not None:
            _setter("fingerprint", fingerprint)
        if locations is not None:
            _setter("locations", locations)
        if status is not None:
            _setter("status", status)
        if warning is not None:
            _setter("warning", warning)

    @property
    @pulumi.getter(name="dnsConfigs")
    def dns_configs(self) -> Optional[Sequence['outputs.DomainStatusDnsConfig']]:
        return pulumi.get(self, "dns_configs")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.DomainStatusEndpoint']]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence['outputs.DomainStatusLocation']]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        return pulumi.get(self, "warning")


@pulumi.output_type
class DomainStatusDnsConfig(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 ttl: Optional[int] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        DomainStatusDnsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            ttl=ttl,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: Optional[str] = None,
             ttl: Optional[int] = None,
             type: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if host is not None:
            _setter("host", host)
        if ttl is not None:
            _setter("ttl", ttl)
        if type is not None:
            _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[int]:
        return pulumi.get(self, "ttl")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DomainStatusEndpoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workloadLink":
            suggest = "workload_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusEndpoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusEndpoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: Optional[str] = None,
                 workload_link: Optional[str] = None):
        DomainStatusEndpoint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            workload_link=workload_link,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             workload_link: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'workloadLink' in kwargs:
            workload_link = kwargs['workloadLink']

        if url is not None:
            _setter("url", url)
        if workload_link is not None:
            _setter("workload_link", workload_link)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="workloadLink")
    def workload_link(self) -> Optional[str]:
        return pulumi.get(self, "workload_link")


@pulumi.output_type
class DomainStatusLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateStatus":
            suggest = "certificate_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DomainStatusLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DomainStatusLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_status: Optional[str] = None,
                 name: Optional[str] = None):
        DomainStatusLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            certificate_status=certificate_status,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             certificate_status: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'certificateStatus' in kwargs:
            certificate_status = kwargs['certificateStatus']

        if certificate_status is not None:
            _setter("certificate_status", certificate_status)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[str]:
        return pulumi.get(self, "certificate_status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GroupIdentityMatcher(dict):
    def __init__(__self__, *,
                 expression: str,
                 language: Optional[str] = None):
        GroupIdentityMatcher._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            language=language,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             language: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("expression", expression)
        if language is not None:
            _setter("language", language)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        return pulumi.get(self, "language")


@pulumi.output_type
class GroupMemberQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.GroupMemberQuerySpec'] = None):
        GroupMemberQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fetch=fetch,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fetch: Optional[str] = None,
             spec: Optional['outputs.GroupMemberQuerySpec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if fetch is not None:
            _setter("fetch", fetch)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GroupMemberQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GroupMemberQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.GroupMemberQuerySpecTerm']] = None):
        GroupMemberQuerySpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
            terms=terms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional[str] = None,
             terms: Optional[Sequence['outputs.GroupMemberQuerySpecTerm']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if match is not None:
            _setter("match", match)
        if terms is not None:
            _setter("terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GroupMemberQuerySpecTerm']]:
        return pulumi.get(self, "terms")


@pulumi.output_type
class GroupMemberQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        GroupMemberQuerySpecTerm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            op=op,
            property=property,
            rel=rel,
            tag=tag,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             op: Optional[str] = None,
             property: Optional[str] = None,
             rel: Optional[str] = None,
             tag: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if op is not None:
            _setter("op", op)
        if property is not None:
            _setter("property", property)
        if rel is not None:
            _setter("rel", rel)
        if tag is not None:
            _setter("tag", tag)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class GvcControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcControlplaneTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcLightstepTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustedProxies":
            suggest = "trusted_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dedicated: Optional[bool] = None,
                 redirect: Optional['outputs.GvcLoadBalancerRedirect'] = None,
                 trusted_proxies: Optional[int] = None):
        GvcLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated=dedicated,
            redirect=redirect,
            trusted_proxies=trusted_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated: Optional[bool] = None,
             redirect: Optional['outputs.GvcLoadBalancerRedirect'] = None,
             trusted_proxies: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustedProxies' in kwargs:
            trusted_proxies = kwargs['trustedProxies']

        if dedicated is not None:
            _setter("dedicated", dedicated)
        if redirect is not None:
            _setter("redirect", redirect)
        if trusted_proxies is not None:
            _setter("trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[bool]:
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.GvcLoadBalancerRedirect']:
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GvcLoadBalancerRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "class":
            suggest = "class_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcLoadBalancerRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcLoadBalancerRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcLoadBalancerRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 class_: Optional['outputs.GvcLoadBalancerRedirectClass'] = None):
        GvcLoadBalancerRedirect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            class_=class_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             class_: Optional['outputs.GvcLoadBalancerRedirectClass'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'class' in kwargs:
            class_ = kwargs['class']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if class_ is not None:
            _setter("class_", class_)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.GvcLoadBalancerRedirectClass']:
        return pulumi.get(self, "class_")


@pulumi.output_type
class GvcLoadBalancerRedirectClass(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 status5xx: Optional[str] = None):
        GvcLoadBalancerRedirectClass._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            status5xx=status5xx,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             status5xx: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if status5xx is not None:
            _setter("status5xx", status5xx)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def status5xx(self) -> Optional[str]:
        return pulumi.get(self, "status5xx")


@pulumi.output_type
class GvcOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GvcOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GvcOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GvcOtelTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GvcSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        GvcSidecar._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class IdentityAwsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "policyRefs":
            suggest = "policy_refs"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAwsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAwsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 policy_refs: Optional[Sequence[str]] = None,
                 role_name: Optional[str] = None):
        IdentityAwsAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            policy_refs=policy_refs,
            role_name=role_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             policy_refs: Optional[Sequence[str]] = None,
             role_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'policyRefs' in kwargs:
            policy_refs = kwargs['policyRefs']
        if 'roleName' in kwargs:
            role_name = kwargs['roleName']

        _setter("cloud_account_link", cloud_account_link)
        if policy_refs is not None:
            _setter("policy_refs", policy_refs)
        if role_name is not None:
            _setter("role_name", role_name)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="policyRefs")
    def policy_refs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "policy_refs")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class IdentityAzureAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "roleAssignments":
            suggest = "role_assignments"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityAzureAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityAzureAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 role_assignments: Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']] = None):
        IdentityAzureAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            role_assignments=role_assignments,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             role_assignments: Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'roleAssignments' in kwargs:
            role_assignments = kwargs['roleAssignments']

        _setter("cloud_account_link", cloud_account_link)
        if role_assignments is not None:
            _setter("role_assignments", role_assignments)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Optional[Sequence['outputs.IdentityAzureAccessPolicyRoleAssignment']]:
        return pulumi.get(self, "role_assignments")


@pulumi.output_type
class IdentityAzureAccessPolicyRoleAssignment(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 roles: Optional[Sequence[str]] = None,
                 scope: Optional[str] = None):
        IdentityAzureAccessPolicyRoleAssignment._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            roles=roles,
            scope=scope,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             roles: Optional[Sequence[str]] = None,
             scope: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if roles is not None:
            _setter("roles", roles)
        if scope is not None:
            _setter("scope", scope)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        return pulumi.get(self, "scope")


@pulumi.output_type
class IdentityGcpAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"
        elif key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityGcpAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityGcpAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 bindings: Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']] = None,
                 scopes: Optional[str] = None,
                 service_account: Optional[str] = None):
        IdentityGcpAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            bindings=bindings,
            scopes=scopes,
            service_account=service_account,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             bindings: Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']] = None,
             scopes: Optional[str] = None,
             service_account: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']
        if 'serviceAccount' in kwargs:
            service_account = kwargs['serviceAccount']

        _setter("cloud_account_link", cloud_account_link)
        if bindings is not None:
            _setter("bindings", bindings)
        if scopes is not None:
            _setter("scopes", scopes)
        if service_account is not None:
            _setter("service_account", service_account)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def bindings(self) -> Optional[Sequence['outputs.IdentityGcpAccessPolicyBinding']]:
        return pulumi.get(self, "bindings")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[str]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        return pulumi.get(self, "service_account")


@pulumi.output_type
class IdentityGcpAccessPolicyBinding(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 resource: Optional[str] = None,
                 roles: Optional[Sequence[str]] = None):
        IdentityGcpAccessPolicyBinding._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            resource=resource,
            roles=roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             resource: Optional[str] = None,
             roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if resource is not None:
            _setter("resource", resource)
        if roles is not None:
            _setter("roles", roles)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "roles")


@pulumi.output_type
class IdentityNativeNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsPrivateLink":
            suggest = "aws_private_link"
        elif key == "gcpServiceConnect":
            suggest = "gcp_service_connect"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: str,
                 name: str,
                 ports: Sequence[int],
                 aws_private_link: Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink'] = None,
                 gcp_service_connect: Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect'] = None):
        IdentityNativeNetworkResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fqdn=fqdn,
            name=name,
            ports=ports,
            aws_private_link=aws_private_link,
            gcp_service_connect=gcp_service_connect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fqdn: str,
             name: str,
             ports: Sequence[int],
             aws_private_link: Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink'] = None,
             gcp_service_connect: Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'awsPrivateLink' in kwargs:
            aws_private_link = kwargs['awsPrivateLink']
        if 'gcpServiceConnect' in kwargs:
            gcp_service_connect = kwargs['gcpServiceConnect']

        _setter("fqdn", fqdn)
        _setter("name", name)
        _setter("ports", ports)
        if aws_private_link is not None:
            _setter("aws_private_link", aws_private_link)
        if gcp_service_connect is not None:
            _setter("gcp_service_connect", gcp_service_connect)

    @property
    @pulumi.getter
    def fqdn(self) -> str:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional['outputs.IdentityNativeNetworkResourceAwsPrivateLink']:
        return pulumi.get(self, "aws_private_link")

    @property
    @pulumi.getter(name="gcpServiceConnect")
    def gcp_service_connect(self) -> Optional['outputs.IdentityNativeNetworkResourceGcpServiceConnect']:
        return pulumi.get(self, "gcp_service_connect")


@pulumi.output_type
class IdentityNativeNetworkResourceAwsPrivateLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointServiceName":
            suggest = "endpoint_service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceAwsPrivateLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceAwsPrivateLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_service_name: str):
        IdentityNativeNetworkResourceAwsPrivateLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint_service_name=endpoint_service_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint_service_name: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'endpointServiceName' in kwargs:
            endpoint_service_name = kwargs['endpointServiceName']

        _setter("endpoint_service_name", endpoint_service_name)

    @property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> str:
        return pulumi.get(self, "endpoint_service_name")


@pulumi.output_type
class IdentityNativeNetworkResourceGcpServiceConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetService":
            suggest = "target_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNativeNetworkResourceGcpServiceConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNativeNetworkResourceGcpServiceConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_service: str):
        IdentityNativeNetworkResourceGcpServiceConnect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target_service=target_service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target_service: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'targetService' in kwargs:
            target_service = kwargs['targetService']

        _setter("target_service", target_service)

    @property
    @pulumi.getter(name="targetService")
    def target_service(self) -> str:
        return pulumi.get(self, "target_service")


@pulumi.output_type
class IdentityNetworkResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentLink":
            suggest = "agent_link"
        elif key == "resolverIp":
            suggest = "resolver_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNetworkResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNetworkResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 ports: Sequence[int],
                 agent_link: Optional[str] = None,
                 fqdn: Optional[str] = None,
                 ips: Optional[Sequence[str]] = None,
                 resolver_ip: Optional[str] = None):
        IdentityNetworkResource._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            ports=ports,
            agent_link=agent_link,
            fqdn=fqdn,
            ips=ips,
            resolver_ip=resolver_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             ports: Sequence[int],
             agent_link: Optional[str] = None,
             fqdn: Optional[str] = None,
             ips: Optional[Sequence[str]] = None,
             resolver_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'agentLink' in kwargs:
            agent_link = kwargs['agentLink']
        if 'resolverIp' in kwargs:
            resolver_ip = kwargs['resolverIp']

        _setter("name", name)
        _setter("ports", ports)
        if agent_link is not None:
            _setter("agent_link", agent_link)
        if fqdn is not None:
            _setter("fqdn", fqdn)
        if ips is not None:
            _setter("ips", ips)
        if resolver_ip is not None:
            _setter("resolver_ip", resolver_ip)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def ports(self) -> Sequence[int]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="agentLink")
    def agent_link(self) -> Optional[str]:
        return pulumi.get(self, "agent_link")

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[str]:
        return pulumi.get(self, "fqdn")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter(name="resolverIp")
    def resolver_ip(self) -> Optional[str]:
        return pulumi.get(self, "resolver_ip")


@pulumi.output_type
class IdentityNgsAccessPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudAccountLink":
            suggest = "cloud_account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IdentityNgsAccessPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IdentityNgsAccessPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_account_link: str,
                 data: Optional[int] = None,
                 payload: Optional[int] = None,
                 pub: Optional['outputs.IdentityNgsAccessPolicyPub'] = None,
                 resp: Optional['outputs.IdentityNgsAccessPolicyResp'] = None,
                 sub: Optional['outputs.IdentityNgsAccessPolicySub'] = None,
                 subs: Optional[int] = None):
        IdentityNgsAccessPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_account_link=cloud_account_link,
            data=data,
            payload=payload,
            pub=pub,
            resp=resp,
            sub=sub,
            subs=subs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_account_link: str,
             data: Optional[int] = None,
             payload: Optional[int] = None,
             pub: Optional['outputs.IdentityNgsAccessPolicyPub'] = None,
             resp: Optional['outputs.IdentityNgsAccessPolicyResp'] = None,
             sub: Optional['outputs.IdentityNgsAccessPolicySub'] = None,
             subs: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudAccountLink' in kwargs:
            cloud_account_link = kwargs['cloudAccountLink']

        _setter("cloud_account_link", cloud_account_link)
        if data is not None:
            _setter("data", data)
        if payload is not None:
            _setter("payload", payload)
        if pub is not None:
            _setter("pub", pub)
        if resp is not None:
            _setter("resp", resp)
        if sub is not None:
            _setter("sub", sub)
        if subs is not None:
            _setter("subs", subs)

    @property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> str:
        return pulumi.get(self, "cloud_account_link")

    @property
    @pulumi.getter
    def data(self) -> Optional[int]:
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def payload(self) -> Optional[int]:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def pub(self) -> Optional['outputs.IdentityNgsAccessPolicyPub']:
        return pulumi.get(self, "pub")

    @property
    @pulumi.getter
    def resp(self) -> Optional['outputs.IdentityNgsAccessPolicyResp']:
        return pulumi.get(self, "resp")

    @property
    @pulumi.getter
    def sub(self) -> Optional['outputs.IdentityNgsAccessPolicySub']:
        return pulumi.get(self, "sub")

    @property
    @pulumi.getter
    def subs(self) -> Optional[int]:
        return pulumi.get(self, "subs")


@pulumi.output_type
class IdentityNgsAccessPolicyPub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        IdentityNgsAccessPolicyPub._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allows=allows,
            denies=denies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allows: Optional[Sequence[str]] = None,
             denies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if allows is not None:
            _setter("allows", allows)
        if denies is not None:
            _setter("denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "denies")


@pulumi.output_type
class IdentityNgsAccessPolicyResp(dict):
    def __init__(__self__, *,
                 max: Optional[int] = None,
                 ttl: Optional[str] = None):
        IdentityNgsAccessPolicyResp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max=max,
            ttl=ttl,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max: Optional[int] = None,
             ttl: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if max is not None:
            _setter("max", max)
        if ttl is not None:
            _setter("ttl", ttl)

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def ttl(self) -> Optional[str]:
        return pulumi.get(self, "ttl")


@pulumi.output_type
class IdentityNgsAccessPolicySub(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[str]] = None,
                 denies: Optional[Sequence[str]] = None):
        IdentityNgsAccessPolicySub._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allows=allows,
            denies=denies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allows: Optional[Sequence[str]] = None,
             denies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if allows is not None:
            _setter("allows", allows)
        if denies is not None:
            _setter("denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allows")

    @property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "denies")


@pulumi.output_type
class IpSetLocation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "retentionPolicy":
            suggest = "retention_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSetLocation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSetLocation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSetLocation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 retention_policy: str):
        IpSetLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            retention_policy=retention_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             retention_policy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'retentionPolicy' in kwargs:
            retention_policy = kwargs['retentionPolicy']

        _setter("name", name)
        _setter("retention_policy", retention_policy)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> str:
        return pulumi.get(self, "retention_policy")


@pulumi.output_type
class IpSetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddresses":
            suggest = "ip_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: Optional[str] = None,
                 ip_addresses: Optional[Sequence['outputs.IpSetStatusIpAddress']] = None):
        IpSetStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            error=error,
            ip_addresses=ip_addresses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             error: Optional[str] = None,
             ip_addresses: Optional[Sequence['outputs.IpSetStatusIpAddress']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'ipAddresses' in kwargs:
            ip_addresses = kwargs['ipAddresses']

        if error is not None:
            _setter("error", error)
        if ip_addresses is not None:
            _setter("ip_addresses", ip_addresses)

    @property
    @pulumi.getter
    def error(self) -> Optional[str]:
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[Sequence['outputs.IpSetStatusIpAddress']]:
        return pulumi.get(self, "ip_addresses")


@pulumi.output_type
class IpSetStatusIpAddress(dict):
    def __init__(__self__, *,
                 created: Optional[str] = None,
                 id: Optional[str] = None,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 state: Optional[str] = None):
        IpSetStatusIpAddress._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            created=created,
            id=id,
            ip=ip,
            name=name,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             created: Optional[str] = None,
             id: Optional[str] = None,
             ip: Optional[str] = None,
             name: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if created is not None:
            _setter("created", created)
        if id is not None:
            _setter("id", id)
        if ip is not None:
            _setter("ip", ip)
        if name is not None:
            _setter("name", name)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def created(self) -> Optional[str]:
        return pulumi.get(self, "created")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class LocationGeo(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        LocationGeo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            continent=continent,
            country=country,
            lat=lat,
            lon=lon,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             continent: Optional[str] = None,
             country: Optional[str] = None,
             lat: Optional[float] = None,
             lon: Optional[float] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if city is not None:
            _setter("city", city)
        if continent is not None:
            _setter("continent", continent)
        if country is not None:
            _setter("country", country)
        if lat is not None:
            _setter("lat", lat)
        if lon is not None:
            _setter("lon", lon)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class Mk8sAddOns(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEcr":
            suggest = "aws_ecr"
        elif key == "awsEfs":
            suggest = "aws_efs"
        elif key == "awsElb":
            suggest = "aws_elb"
        elif key == "awsWorkloadIdentity":
            suggest = "aws_workload_identity"
        elif key == "azureAcr":
            suggest = "azure_acr"
        elif key == "azureWorkloadIdentity":
            suggest = "azure_workload_identity"
        elif key == "localPathStorage":
            suggest = "local_path_storage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOns. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOns.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOns.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_ecr: Optional['outputs.Mk8sAddOnsAwsEcr'] = None,
                 aws_efs: Optional['outputs.Mk8sAddOnsAwsEfs'] = None,
                 aws_elb: Optional['outputs.Mk8sAddOnsAwsElb'] = None,
                 aws_workload_identity: Optional[bool] = None,
                 azure_acr: Optional['outputs.Mk8sAddOnsAzureAcr'] = None,
                 azure_workload_identity: Optional['outputs.Mk8sAddOnsAzureWorkloadIdentity'] = None,
                 dashboard: Optional[bool] = None,
                 local_path_storage: Optional[bool] = None,
                 logs: Optional['outputs.Mk8sAddOnsLogs'] = None,
                 metrics: Optional['outputs.Mk8sAddOnsMetrics'] = None,
                 nvidia: Optional['outputs.Mk8sAddOnsNvidia'] = None,
                 sysbox: Optional[bool] = None):
        Mk8sAddOns._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_ecr=aws_ecr,
            aws_efs=aws_efs,
            aws_elb=aws_elb,
            aws_workload_identity=aws_workload_identity,
            azure_acr=azure_acr,
            azure_workload_identity=azure_workload_identity,
            dashboard=dashboard,
            local_path_storage=local_path_storage,
            logs=logs,
            metrics=metrics,
            nvidia=nvidia,
            sysbox=sysbox,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_ecr: Optional['outputs.Mk8sAddOnsAwsEcr'] = None,
             aws_efs: Optional['outputs.Mk8sAddOnsAwsEfs'] = None,
             aws_elb: Optional['outputs.Mk8sAddOnsAwsElb'] = None,
             aws_workload_identity: Optional[bool] = None,
             azure_acr: Optional['outputs.Mk8sAddOnsAzureAcr'] = None,
             azure_workload_identity: Optional['outputs.Mk8sAddOnsAzureWorkloadIdentity'] = None,
             dashboard: Optional[bool] = None,
             local_path_storage: Optional[bool] = None,
             logs: Optional['outputs.Mk8sAddOnsLogs'] = None,
             metrics: Optional['outputs.Mk8sAddOnsMetrics'] = None,
             nvidia: Optional['outputs.Mk8sAddOnsNvidia'] = None,
             sysbox: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'awsEcr' in kwargs:
            aws_ecr = kwargs['awsEcr']
        if 'awsEfs' in kwargs:
            aws_efs = kwargs['awsEfs']
        if 'awsElb' in kwargs:
            aws_elb = kwargs['awsElb']
        if 'awsWorkloadIdentity' in kwargs:
            aws_workload_identity = kwargs['awsWorkloadIdentity']
        if 'azureAcr' in kwargs:
            azure_acr = kwargs['azureAcr']
        if 'azureWorkloadIdentity' in kwargs:
            azure_workload_identity = kwargs['azureWorkloadIdentity']
        if 'localPathStorage' in kwargs:
            local_path_storage = kwargs['localPathStorage']

        if aws_ecr is not None:
            _setter("aws_ecr", aws_ecr)
        if aws_efs is not None:
            _setter("aws_efs", aws_efs)
        if aws_elb is not None:
            _setter("aws_elb", aws_elb)
        if aws_workload_identity is not None:
            _setter("aws_workload_identity", aws_workload_identity)
        if azure_acr is not None:
            _setter("azure_acr", azure_acr)
        if azure_workload_identity is not None:
            _setter("azure_workload_identity", azure_workload_identity)
        if dashboard is not None:
            _setter("dashboard", dashboard)
        if local_path_storage is not None:
            _setter("local_path_storage", local_path_storage)
        if logs is not None:
            _setter("logs", logs)
        if metrics is not None:
            _setter("metrics", metrics)
        if nvidia is not None:
            _setter("nvidia", nvidia)
        if sysbox is not None:
            _setter("sysbox", sysbox)

    @property
    @pulumi.getter(name="awsEcr")
    def aws_ecr(self) -> Optional['outputs.Mk8sAddOnsAwsEcr']:
        return pulumi.get(self, "aws_ecr")

    @property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional['outputs.Mk8sAddOnsAwsEfs']:
        return pulumi.get(self, "aws_efs")

    @property
    @pulumi.getter(name="awsElb")
    def aws_elb(self) -> Optional['outputs.Mk8sAddOnsAwsElb']:
        return pulumi.get(self, "aws_elb")

    @property
    @pulumi.getter(name="awsWorkloadIdentity")
    def aws_workload_identity(self) -> Optional[bool]:
        return pulumi.get(self, "aws_workload_identity")

    @property
    @pulumi.getter(name="azureAcr")
    def azure_acr(self) -> Optional['outputs.Mk8sAddOnsAzureAcr']:
        return pulumi.get(self, "azure_acr")

    @property
    @pulumi.getter(name="azureWorkloadIdentity")
    def azure_workload_identity(self) -> Optional['outputs.Mk8sAddOnsAzureWorkloadIdentity']:
        return pulumi.get(self, "azure_workload_identity")

    @property
    @pulumi.getter
    def dashboard(self) -> Optional[bool]:
        return pulumi.get(self, "dashboard")

    @property
    @pulumi.getter(name="localPathStorage")
    def local_path_storage(self) -> Optional[bool]:
        return pulumi.get(self, "local_path_storage")

    @property
    @pulumi.getter
    def logs(self) -> Optional['outputs.Mk8sAddOnsLogs']:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.Mk8sAddOnsMetrics']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def nvidia(self) -> Optional['outputs.Mk8sAddOnsNvidia']:
        return pulumi.get(self, "nvidia")

    @property
    @pulumi.getter
    def sysbox(self) -> Optional[bool]:
        return pulumi.get(self, "sysbox")


@pulumi.output_type
class Mk8sAddOnsAwsEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        Mk8sAddOnsAwsEcr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAwsEfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsEfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsEfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsEfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        Mk8sAddOnsAwsEfs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAwsElb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAwsElb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAwsElb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAwsElb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 role_arn: Optional[str] = None):
        Mk8sAddOnsAwsElb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class Mk8sAddOnsAzureAcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAzureAcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAzureAcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAzureAcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str):
        Mk8sAddOnsAzureAcr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'clientId' in kwargs:
            client_id = kwargs['clientId']

        _setter("client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")


@pulumi.output_type
class Mk8sAddOnsAzureWorkloadIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsAzureWorkloadIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsAzureWorkloadIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsAzureWorkloadIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 tenant_id: Optional[str] = None):
        Mk8sAddOnsAzureWorkloadIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            tenant_id=tenant_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             tenant_id: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'tenantId' in kwargs:
            tenant_id = kwargs['tenantId']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if tenant_id is not None:
            _setter("tenant_id", tenant_id)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class Mk8sAddOnsLogs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "auditEnabled":
            suggest = "audit_enabled"
        elif key == "excludeNamespaces":
            suggest = "exclude_namespaces"
        elif key == "includeNamespaces":
            suggest = "include_namespaces"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsLogs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsLogs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsLogs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 audit_enabled: Optional[bool] = None,
                 exclude_namespaces: Optional[str] = None,
                 include_namespaces: Optional[str] = None):
        Mk8sAddOnsLogs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            audit_enabled=audit_enabled,
            exclude_namespaces=exclude_namespaces,
            include_namespaces=include_namespaces,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             audit_enabled: Optional[bool] = None,
             exclude_namespaces: Optional[str] = None,
             include_namespaces: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'auditEnabled' in kwargs:
            audit_enabled = kwargs['auditEnabled']
        if 'excludeNamespaces' in kwargs:
            exclude_namespaces = kwargs['excludeNamespaces']
        if 'includeNamespaces' in kwargs:
            include_namespaces = kwargs['includeNamespaces']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if audit_enabled is not None:
            _setter("audit_enabled", audit_enabled)
        if exclude_namespaces is not None:
            _setter("exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            _setter("include_namespaces", include_namespaces)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "audit_enabled")

    @property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "exclude_namespaces")

    @property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "include_namespaces")


@pulumi.output_type
class Mk8sAddOnsMetrics(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiServer":
            suggest = "api_server"
        elif key == "coreDns":
            suggest = "core_dns"
        elif key == "kubeState":
            suggest = "kube_state"
        elif key == "nodeExporter":
            suggest = "node_exporter"
        elif key == "scrapeAnnotated":
            suggest = "scrape_annotated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsMetrics. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsMetrics.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsMetrics.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 api_server: Optional[bool] = None,
                 cadvisor: Optional[bool] = None,
                 core_dns: Optional[bool] = None,
                 kube_state: Optional[bool] = None,
                 kubelet: Optional[bool] = None,
                 node_exporter: Optional[bool] = None,
                 scrape_annotated: Optional['outputs.Mk8sAddOnsMetricsScrapeAnnotated'] = None):
        Mk8sAddOnsMetrics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            api_server=api_server,
            cadvisor=cadvisor,
            core_dns=core_dns,
            kube_state=kube_state,
            kubelet=kubelet,
            node_exporter=node_exporter,
            scrape_annotated=scrape_annotated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             api_server: Optional[bool] = None,
             cadvisor: Optional[bool] = None,
             core_dns: Optional[bool] = None,
             kube_state: Optional[bool] = None,
             kubelet: Optional[bool] = None,
             node_exporter: Optional[bool] = None,
             scrape_annotated: Optional['outputs.Mk8sAddOnsMetricsScrapeAnnotated'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'apiServer' in kwargs:
            api_server = kwargs['apiServer']
        if 'coreDns' in kwargs:
            core_dns = kwargs['coreDns']
        if 'kubeState' in kwargs:
            kube_state = kwargs['kubeState']
        if 'nodeExporter' in kwargs:
            node_exporter = kwargs['nodeExporter']
        if 'scrapeAnnotated' in kwargs:
            scrape_annotated = kwargs['scrapeAnnotated']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if api_server is not None:
            _setter("api_server", api_server)
        if cadvisor is not None:
            _setter("cadvisor", cadvisor)
        if core_dns is not None:
            _setter("core_dns", core_dns)
        if kube_state is not None:
            _setter("kube_state", kube_state)
        if kubelet is not None:
            _setter("kubelet", kubelet)
        if node_exporter is not None:
            _setter("node_exporter", node_exporter)
        if scrape_annotated is not None:
            _setter("scrape_annotated", scrape_annotated)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> Optional[bool]:
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter
    def cadvisor(self) -> Optional[bool]:
        return pulumi.get(self, "cadvisor")

    @property
    @pulumi.getter(name="coreDns")
    def core_dns(self) -> Optional[bool]:
        return pulumi.get(self, "core_dns")

    @property
    @pulumi.getter(name="kubeState")
    def kube_state(self) -> Optional[bool]:
        return pulumi.get(self, "kube_state")

    @property
    @pulumi.getter
    def kubelet(self) -> Optional[bool]:
        return pulumi.get(self, "kubelet")

    @property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[bool]:
        return pulumi.get(self, "node_exporter")

    @property
    @pulumi.getter(name="scrapeAnnotated")
    def scrape_annotated(self) -> Optional['outputs.Mk8sAddOnsMetricsScrapeAnnotated']:
        return pulumi.get(self, "scrape_annotated")


@pulumi.output_type
class Mk8sAddOnsMetricsScrapeAnnotated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeNamespaces":
            suggest = "exclude_namespaces"
        elif key == "includeNamespaces":
            suggest = "include_namespaces"
        elif key == "intervalSeconds":
            suggest = "interval_seconds"
        elif key == "retainLabels":
            suggest = "retain_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsMetricsScrapeAnnotated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsMetricsScrapeAnnotated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsMetricsScrapeAnnotated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 exclude_namespaces: Optional[str] = None,
                 include_namespaces: Optional[str] = None,
                 interval_seconds: Optional[int] = None,
                 retain_labels: Optional[str] = None):
        Mk8sAddOnsMetricsScrapeAnnotated._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            exclude_namespaces=exclude_namespaces,
            include_namespaces=include_namespaces,
            interval_seconds=interval_seconds,
            retain_labels=retain_labels,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             exclude_namespaces: Optional[str] = None,
             include_namespaces: Optional[str] = None,
             interval_seconds: Optional[int] = None,
             retain_labels: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'excludeNamespaces' in kwargs:
            exclude_namespaces = kwargs['excludeNamespaces']
        if 'includeNamespaces' in kwargs:
            include_namespaces = kwargs['includeNamespaces']
        if 'intervalSeconds' in kwargs:
            interval_seconds = kwargs['intervalSeconds']
        if 'retainLabels' in kwargs:
            retain_labels = kwargs['retainLabels']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if exclude_namespaces is not None:
            _setter("exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            _setter("include_namespaces", include_namespaces)
        if interval_seconds is not None:
            _setter("interval_seconds", interval_seconds)
        if retain_labels is not None:
            _setter("retain_labels", retain_labels)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "exclude_namespaces")

    @property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[str]:
        return pulumi.get(self, "include_namespaces")

    @property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[int]:
        return pulumi.get(self, "interval_seconds")

    @property
    @pulumi.getter(name="retainLabels")
    def retain_labels(self) -> Optional[str]:
        return pulumi.get(self, "retain_labels")


@pulumi.output_type
class Mk8sAddOnsNvidia(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "taintGpuNodes":
            suggest = "taint_gpu_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAddOnsNvidia. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAddOnsNvidia.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAddOnsNvidia.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 taint_gpu_nodes: Optional[bool] = None):
        Mk8sAddOnsNvidia._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            taint_gpu_nodes=taint_gpu_nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             taint_gpu_nodes: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'taintGpuNodes' in kwargs:
            taint_gpu_nodes = kwargs['taintGpuNodes']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if taint_gpu_nodes is not None:
            _setter("taint_gpu_nodes", taint_gpu_nodes)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="taintGpuNodes")
    def taint_gpu_nodes(self) -> Optional[bool]:
        return pulumi.get(self, "taint_gpu_nodes")


@pulumi.output_type
class Mk8sAwsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployRoleArn":
            suggest = "deploy_role_arn"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "awsTags":
            suggest = "aws_tags"
        elif key == "deployRoleChains":
            suggest = "deploy_role_chains"
        elif key == "diskEncryptionKeyArn":
            suggest = "disk_encryption_key_arn"
        elif key == "extraNodePolicies":
            suggest = "extra_node_policies"
        elif key == "keyPair":
            suggest = "key_pair"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "securityGroupIds":
            suggest = "security_group_ids"
        elif key == "skipCreateRoles":
            suggest = "skip_create_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deploy_role_arn: str,
                 image: 'outputs.Mk8sAwsProviderImage',
                 networking: 'outputs.Mk8sAwsProviderNetworking',
                 region: str,
                 vpc_id: str,
                 autoscaler: Optional['outputs.Mk8sAwsProviderAutoscaler'] = None,
                 aws_tags: Optional[Mapping[str, str]] = None,
                 deploy_role_chains: Optional[Sequence['outputs.Mk8sAwsProviderDeployRoleChain']] = None,
                 disk_encryption_key_arn: Optional[str] = None,
                 extra_node_policies: Optional[Sequence[str]] = None,
                 key_pair: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sAwsProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 security_group_ids: Optional[Sequence[str]] = None,
                 skip_create_roles: Optional[bool] = None):
        Mk8sAwsProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            deploy_role_arn=deploy_role_arn,
            image=image,
            networking=networking,
            region=region,
            vpc_id=vpc_id,
            autoscaler=autoscaler,
            aws_tags=aws_tags,
            deploy_role_chains=deploy_role_chains,
            disk_encryption_key_arn=disk_encryption_key_arn,
            extra_node_policies=extra_node_policies,
            key_pair=key_pair,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            security_group_ids=security_group_ids,
            skip_create_roles=skip_create_roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             deploy_role_arn: str,
             image: 'outputs.Mk8sAwsProviderImage',
             networking: 'outputs.Mk8sAwsProviderNetworking',
             region: str,
             vpc_id: str,
             autoscaler: Optional['outputs.Mk8sAwsProviderAutoscaler'] = None,
             aws_tags: Optional[Mapping[str, str]] = None,
             deploy_role_chains: Optional[Sequence['outputs.Mk8sAwsProviderDeployRoleChain']] = None,
             disk_encryption_key_arn: Optional[str] = None,
             extra_node_policies: Optional[Sequence[str]] = None,
             key_pair: Optional[str] = None,
             node_pools: Optional[Sequence['outputs.Mk8sAwsProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             security_group_ids: Optional[Sequence[str]] = None,
             skip_create_roles: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'deployRoleArn' in kwargs:
            deploy_role_arn = kwargs['deployRoleArn']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if 'awsTags' in kwargs:
            aws_tags = kwargs['awsTags']
        if 'deployRoleChains' in kwargs:
            deploy_role_chains = kwargs['deployRoleChains']
        if 'diskEncryptionKeyArn' in kwargs:
            disk_encryption_key_arn = kwargs['diskEncryptionKeyArn']
        if 'extraNodePolicies' in kwargs:
            extra_node_policies = kwargs['extraNodePolicies']
        if 'keyPair' in kwargs:
            key_pair = kwargs['keyPair']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'securityGroupIds' in kwargs:
            security_group_ids = kwargs['securityGroupIds']
        if 'skipCreateRoles' in kwargs:
            skip_create_roles = kwargs['skipCreateRoles']

        _setter("deploy_role_arn", deploy_role_arn)
        _setter("image", image)
        _setter("networking", networking)
        _setter("region", region)
        _setter("vpc_id", vpc_id)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if aws_tags is not None:
            _setter("aws_tags", aws_tags)
        if deploy_role_chains is not None:
            _setter("deploy_role_chains", deploy_role_chains)
        if disk_encryption_key_arn is not None:
            _setter("disk_encryption_key_arn", disk_encryption_key_arn)
        if extra_node_policies is not None:
            _setter("extra_node_policies", extra_node_policies)
        if key_pair is not None:
            _setter("key_pair", key_pair)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if security_group_ids is not None:
            _setter("security_group_ids", security_group_ids)
        if skip_create_roles is not None:
            _setter("skip_create_roles", skip_create_roles)

    @property
    @pulumi.getter(name="deployRoleArn")
    def deploy_role_arn(self) -> str:
        return pulumi.get(self, "deploy_role_arn")

    @property
    @pulumi.getter
    def image(self) -> 'outputs.Mk8sAwsProviderImage':
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sAwsProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sAwsProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "aws_tags")

    @property
    @pulumi.getter(name="deployRoleChains")
    def deploy_role_chains(self) -> Optional[Sequence['outputs.Mk8sAwsProviderDeployRoleChain']]:
        return pulumi.get(self, "deploy_role_chains")

    @property
    @pulumi.getter(name="diskEncryptionKeyArn")
    def disk_encryption_key_arn(self) -> Optional[str]:
        return pulumi.get(self, "disk_encryption_key_arn")

    @property
    @pulumi.getter(name="extraNodePolicies")
    def extra_node_policies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extra_node_policies")

    @property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> Optional[str]:
        return pulumi.get(self, "key_pair")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sAwsProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "security_group_ids")

    @property
    @pulumi.getter(name="skipCreateRoles")
    def skip_create_roles(self) -> Optional[bool]:
        return pulumi.get(self, "skip_create_roles")


@pulumi.output_type
class Mk8sAwsProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sAwsProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sAwsProviderDeployRoleChain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "sessionNamePrefix":
            suggest = "session_name_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderDeployRoleChain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderDeployRoleChain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderDeployRoleChain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 external_id: Optional[str] = None,
                 session_name_prefix: Optional[str] = None):
        Mk8sAwsProviderDeployRoleChain._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            role_arn=role_arn,
            external_id=external_id,
            session_name_prefix=session_name_prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             role_arn: str,
             external_id: Optional[str] = None,
             session_name_prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'sessionNamePrefix' in kwargs:
            session_name_prefix = kwargs['sessionNamePrefix']

        _setter("role_arn", role_arn)
        if external_id is not None:
            _setter("external_id", external_id)
        if session_name_prefix is not None:
            _setter("session_name_prefix", session_name_prefix)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="sessionNamePrefix")
    def session_name_prefix(self) -> Optional[str]:
        return pulumi.get(self, "session_name_prefix")


@pulumi.output_type
class Mk8sAwsProviderImage(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 recommended: Optional[str] = None):
        Mk8sAwsProviderImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            recommended=recommended,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             recommended: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if recommended is not None:
            _setter("recommended", recommended)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def recommended(self) -> Optional[str]:
        return pulumi.get(self, "recommended")


@pulumi.output_type
class Mk8sAwsProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sAwsProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sAwsProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceTypes":
            suggest = "instance_types"
        elif key == "overrideImage":
            suggest = "override_image"
        elif key == "subnetIds":
            suggest = "subnet_ids"
        elif key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "extraSecurityGroupIds":
            suggest = "extra_security_group_ids"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "onDemandBaseCapacity":
            suggest = "on_demand_base_capacity"
        elif key == "onDemandPercentageAboveBaseCapacity":
            suggest = "on_demand_percentage_above_base_capacity"
        elif key == "spotAllocationStrategy":
            suggest = "spot_allocation_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sAwsProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sAwsProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sAwsProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_types: Sequence[str],
                 name: str,
                 override_image: 'outputs.Mk8sAwsProviderNodePoolOverrideImage',
                 subnet_ids: Sequence[str],
                 boot_disk_size: Optional[int] = None,
                 extra_security_group_ids: Optional[Sequence[str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 on_demand_base_capacity: Optional[int] = None,
                 on_demand_percentage_above_base_capacity: Optional[int] = None,
                 spot_allocation_strategy: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sAwsProviderNodePoolTaint']] = None):
        Mk8sAwsProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_types=instance_types,
            name=name,
            override_image=override_image,
            subnet_ids=subnet_ids,
            boot_disk_size=boot_disk_size,
            extra_security_group_ids=extra_security_group_ids,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            on_demand_base_capacity=on_demand_base_capacity,
            on_demand_percentage_above_base_capacity=on_demand_percentage_above_base_capacity,
            spot_allocation_strategy=spot_allocation_strategy,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_types: Sequence[str],
             name: str,
             override_image: 'outputs.Mk8sAwsProviderNodePoolOverrideImage',
             subnet_ids: Sequence[str],
             boot_disk_size: Optional[int] = None,
             extra_security_group_ids: Optional[Sequence[str]] = None,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             on_demand_base_capacity: Optional[int] = None,
             on_demand_percentage_above_base_capacity: Optional[int] = None,
             spot_allocation_strategy: Optional[str] = None,
             taints: Optional[Sequence['outputs.Mk8sAwsProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'instanceTypes' in kwargs:
            instance_types = kwargs['instanceTypes']
        if 'overrideImage' in kwargs:
            override_image = kwargs['overrideImage']
        if 'subnetIds' in kwargs:
            subnet_ids = kwargs['subnetIds']
        if 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if 'extraSecurityGroupIds' in kwargs:
            extra_security_group_ids = kwargs['extraSecurityGroupIds']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'onDemandBaseCapacity' in kwargs:
            on_demand_base_capacity = kwargs['onDemandBaseCapacity']
        if 'onDemandPercentageAboveBaseCapacity' in kwargs:
            on_demand_percentage_above_base_capacity = kwargs['onDemandPercentageAboveBaseCapacity']
        if 'spotAllocationStrategy' in kwargs:
            spot_allocation_strategy = kwargs['spotAllocationStrategy']

        _setter("instance_types", instance_types)
        _setter("name", name)
        _setter("override_image", override_image)
        _setter("subnet_ids", subnet_ids)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if extra_security_group_ids is not None:
            _setter("extra_security_group_ids", extra_security_group_ids)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if on_demand_base_capacity is not None:
            _setter("on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            _setter("on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if spot_allocation_strategy is not None:
            _setter("spot_allocation_strategy", spot_allocation_strategy)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> Sequence[str]:
        return pulumi.get(self, "instance_types")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> 'outputs.Mk8sAwsProviderNodePoolOverrideImage':
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Sequence[str]:
        return pulumi.get(self, "subnet_ids")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter(name="extraSecurityGroupIds")
    def extra_security_group_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extra_security_group_ids")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_base_capacity")

    @property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[int]:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[str]:
        return pulumi.get(self, "spot_allocation_strategy")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sAwsProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sAwsProviderNodePoolOverrideImage(dict):
    def __init__(__self__, *,
                 exact: Optional[str] = None,
                 recommended: Optional[str] = None):
        Mk8sAwsProviderNodePoolOverrideImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exact=exact,
            recommended=recommended,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exact: Optional[str] = None,
             recommended: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if exact is not None:
            _setter("exact", exact)
        if recommended is not None:
            _setter("recommended", recommended)

    @property
    @pulumi.getter
    def exact(self) -> Optional[str]:
        return pulumi.get(self, "exact")

    @property
    @pulumi.getter
    def recommended(self) -> Optional[str]:
        return pulumi.get(self, "recommended")


@pulumi.output_type
class Mk8sAwsProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sAwsProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sDigitalOceanProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "digitalOceanTags":
            suggest = "digital_ocean_tags"
        elif key == "extraSshKeys":
            suggest = "extra_ssh_keys"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "reservedIps":
            suggest = "reserved_ips"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 networking: 'outputs.Mk8sDigitalOceanProviderNetworking',
                 region: str,
                 ssh_keys: Sequence[str],
                 token_secret_link: str,
                 vpc_id: str,
                 autoscaler: Optional['outputs.Mk8sDigitalOceanProviderAutoscaler'] = None,
                 digital_ocean_tags: Optional[Sequence[str]] = None,
                 extra_ssh_keys: Optional[Sequence[str]] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 reserved_ips: Optional[Sequence[str]] = None):
        Mk8sDigitalOceanProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image=image,
            networking=networking,
            region=region,
            ssh_keys=ssh_keys,
            token_secret_link=token_secret_link,
            vpc_id=vpc_id,
            autoscaler=autoscaler,
            digital_ocean_tags=digital_ocean_tags,
            extra_ssh_keys=extra_ssh_keys,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            reserved_ips=reserved_ips,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image: str,
             networking: 'outputs.Mk8sDigitalOceanProviderNetworking',
             region: str,
             ssh_keys: Sequence[str],
             token_secret_link: str,
             vpc_id: str,
             autoscaler: Optional['outputs.Mk8sDigitalOceanProviderAutoscaler'] = None,
             digital_ocean_tags: Optional[Sequence[str]] = None,
             extra_ssh_keys: Optional[Sequence[str]] = None,
             node_pools: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             reserved_ips: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sshKeys' in kwargs:
            ssh_keys = kwargs['sshKeys']
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if 'digitalOceanTags' in kwargs:
            digital_ocean_tags = kwargs['digitalOceanTags']
        if 'extraSshKeys' in kwargs:
            extra_ssh_keys = kwargs['extraSshKeys']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'reservedIps' in kwargs:
            reserved_ips = kwargs['reservedIps']

        _setter("image", image)
        _setter("networking", networking)
        _setter("region", region)
        _setter("ssh_keys", ssh_keys)
        _setter("token_secret_link", token_secret_link)
        _setter("vpc_id", vpc_id)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if digital_ocean_tags is not None:
            _setter("digital_ocean_tags", digital_ocean_tags)
        if extra_ssh_keys is not None:
            _setter("extra_ssh_keys", extra_ssh_keys)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if reserved_ips is not None:
            _setter("reserved_ips", reserved_ips)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sDigitalOceanProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[str]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sDigitalOceanProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="digitalOceanTags")
    def digital_ocean_tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "digital_ocean_tags")

    @property
    @pulumi.getter(name="extraSshKeys")
    def extra_ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "extra_ssh_keys")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="reservedIps")
    def reserved_ips(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "reserved_ips")


@pulumi.output_type
class Mk8sDigitalOceanProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sDigitalOceanProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sDigitalOceanProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sDigitalOceanProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sDigitalOceanProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropletSize":
            suggest = "droplet_size"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sDigitalOceanProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sDigitalOceanProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sDigitalOceanProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 droplet_size: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePoolTaint']] = None):
        Mk8sDigitalOceanProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            droplet_size=droplet_size,
            name=name,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            override_image=override_image,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             droplet_size: str,
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             override_image: Optional[str] = None,
             taints: Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'dropletSize' in kwargs:
            droplet_size = kwargs['dropletSize']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'overrideImage' in kwargs:
            override_image = kwargs['overrideImage']

        _setter("droplet_size", droplet_size)
        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if override_image is not None:
            _setter("override_image", override_image)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="dropletSize")
    def droplet_size(self) -> str:
        return pulumi.get(self, "droplet_size")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sDigitalOceanProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sDigitalOceanProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sDigitalOceanProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sEphemeralProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePools":
            suggest = "node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sEphemeralProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sEphemeralProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sEphemeralProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 node_pools: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePool']] = None):
        Mk8sEphemeralProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            node_pools=node_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: str,
             node_pools: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePool']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']

        _setter("location", location)
        if node_pools is not None:
            _setter("node_pools", node_pools)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sEphemeralProviderNodePool']]:
        return pulumi.get(self, "node_pools")


@pulumi.output_type
class Mk8sEphemeralProviderNodePool(dict):
    def __init__(__self__, *,
                 arch: str,
                 count: int,
                 cpu: str,
                 flavor: str,
                 memory: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePoolTaint']] = None):
        Mk8sEphemeralProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arch=arch,
            count=count,
            cpu=cpu,
            flavor=flavor,
            memory=memory,
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arch: str,
             count: int,
             cpu: str,
             flavor: str,
             memory: str,
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sEphemeralProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("arch", arch)
        _setter("count", count)
        _setter("cpu", cpu)
        _setter("flavor", flavor)
        _setter("memory", memory)
        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def arch(self) -> str:
        return pulumi.get(self, "arch")

    @property
    @pulumi.getter
    def count(self) -> int:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def cpu(self) -> str:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def flavor(self) -> str:
        return pulumi.get(self, "flavor")

    @property
    @pulumi.getter
    def memory(self) -> str:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sEphemeralProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sEphemeralProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sEphemeralProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceCidr":
            suggest = "source_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_cidr: str,
                 description: Optional[str] = None):
        Mk8sFirewall._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_cidr=source_cidr,
            description=description,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_cidr: str,
             description: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sourceCidr' in kwargs:
            source_cidr = kwargs['sourceCidr']

        _setter("source_cidr", source_cidr)
        if description is not None:
            _setter("description", description)

    @property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> str:
        return pulumi.get(self, "source_cidr")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        return pulumi.get(self, "description")


@pulumi.output_type
class Mk8sGenericProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePools":
            suggest = "node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sGenericProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sGenericProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sGenericProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 networking: 'outputs.Mk8sGenericProviderNetworking',
                 node_pools: Optional[Sequence['outputs.Mk8sGenericProviderNodePool']] = None):
        Mk8sGenericProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            networking=networking,
            node_pools=node_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: str,
             networking: 'outputs.Mk8sGenericProviderNetworking',
             node_pools: Optional[Sequence['outputs.Mk8sGenericProviderNodePool']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']

        _setter("location", location)
        _setter("networking", networking)
        if node_pools is not None:
            _setter("node_pools", node_pools)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sGenericProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sGenericProviderNodePool']]:
        return pulumi.get(self, "node_pools")


@pulumi.output_type
class Mk8sGenericProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sGenericProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sGenericProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sGenericProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sGenericProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sGenericProviderNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sGenericProviderNodePoolTaint']] = None):
        Mk8sGenericProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sGenericProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sGenericProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sGenericProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sGenericProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sHetznerProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "dedicatedServerNodePools":
            suggest = "dedicated_server_node_pools"
        elif key == "firewallId":
            suggest = "firewall_id"
        elif key == "floatingIpSelector":
            suggest = "floating_ip_selector"
        elif key == "hetznerLabels":
            suggest = "hetzner_labels"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKey":
            suggest = "ssh_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 networking: 'outputs.Mk8sHetznerProviderNetworking',
                 region: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sHetznerProviderAutoscaler'] = None,
                 dedicated_server_node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePool']] = None,
                 firewall_id: Optional[str] = None,
                 floating_ip_selector: Optional[Mapping[str, str]] = None,
                 hetzner_labels: Optional[Mapping[str, str]] = None,
                 image: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_key: Optional[str] = None):
        Mk8sHetznerProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            networking=networking,
            region=region,
            token_secret_link=token_secret_link,
            autoscaler=autoscaler,
            dedicated_server_node_pools=dedicated_server_node_pools,
            firewall_id=firewall_id,
            floating_ip_selector=floating_ip_selector,
            hetzner_labels=hetzner_labels,
            image=image,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            ssh_key=ssh_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: str,
             networking: 'outputs.Mk8sHetznerProviderNetworking',
             region: str,
             token_secret_link: str,
             autoscaler: Optional['outputs.Mk8sHetznerProviderAutoscaler'] = None,
             dedicated_server_node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePool']] = None,
             firewall_id: Optional[str] = None,
             floating_ip_selector: Optional[Mapping[str, str]] = None,
             hetzner_labels: Optional[Mapping[str, str]] = None,
             image: Optional[str] = None,
             node_pools: Optional[Sequence['outputs.Mk8sHetznerProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             ssh_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'dedicatedServerNodePools' in kwargs:
            dedicated_server_node_pools = kwargs['dedicatedServerNodePools']
        if 'firewallId' in kwargs:
            firewall_id = kwargs['firewallId']
        if 'floatingIpSelector' in kwargs:
            floating_ip_selector = kwargs['floatingIpSelector']
        if 'hetznerLabels' in kwargs:
            hetzner_labels = kwargs['hetznerLabels']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']

        _setter("network_id", network_id)
        _setter("networking", networking)
        _setter("region", region)
        _setter("token_secret_link", token_secret_link)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if dedicated_server_node_pools is not None:
            _setter("dedicated_server_node_pools", dedicated_server_node_pools)
        if firewall_id is not None:
            _setter("firewall_id", firewall_id)
        if floating_ip_selector is not None:
            _setter("floating_ip_selector", floating_ip_selector)
        if hetzner_labels is not None:
            _setter("hetzner_labels", hetzner_labels)
        if image is not None:
            _setter("image", image)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if ssh_key is not None:
            _setter("ssh_key", ssh_key)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sHetznerProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sHetznerProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="dedicatedServerNodePools")
    def dedicated_server_node_pools(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePool']]:
        return pulumi.get(self, "dedicated_server_node_pools")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[str]:
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter(name="floatingIpSelector")
    def floating_ip_selector(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "floating_ip_selector")

    @property
    @pulumi.getter(name="hetznerLabels")
    def hetzner_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "hetzner_labels")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[str]:
        return pulumi.get(self, "ssh_key")


@pulumi.output_type
class Mk8sHetznerProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sHetznerProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sHetznerProviderDedicatedServerNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePoolTaint']] = None):
        Mk8sHetznerProviderDedicatedServerNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderDedicatedServerNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sHetznerProviderDedicatedServerNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sHetznerProviderDedicatedServerNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sHetznerProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sHetznerProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sHetznerProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverType":
            suggest = "server_type"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sHetznerProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sHetznerProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sHetznerProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_type: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sHetznerProviderNodePoolTaint']] = None):
        Mk8sHetznerProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            server_type=server_type,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            override_image=override_image,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             server_type: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             override_image: Optional[str] = None,
             taints: Optional[Sequence['outputs.Mk8sHetznerProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'overrideImage' in kwargs:
            override_image = kwargs['overrideImage']

        _setter("name", name)
        _setter("server_type", server_type)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if override_image is not None:
            _setter("override_image", override_image)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sHetznerProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sHetznerProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sHetznerProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLambdalabsProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKey":
            suggest = "ssh_key"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 region: str,
                 ssh_key: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sLambdalabsProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePool']] = None):
        Mk8sLambdalabsProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            region=region,
            ssh_key=ssh_key,
            token_secret_link=token_secret_link,
            autoscaler=autoscaler,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            unmanaged_node_pools=unmanaged_node_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             region: str,
             ssh_key: str,
             token_secret_link: str,
             autoscaler: Optional['outputs.Mk8sLambdalabsProviderAutoscaler'] = None,
             node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             unmanaged_node_pools: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePool']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'sshKey' in kwargs:
            ssh_key = kwargs['sshKey']
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'unmanagedNodePools' in kwargs:
            unmanaged_node_pools = kwargs['unmanagedNodePools']

        _setter("region", region)
        _setter("ssh_key", ssh_key)
        _setter("token_secret_link", token_secret_link)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if unmanaged_node_pools is not None:
            _setter("unmanaged_node_pools", unmanaged_node_pools)

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> str:
        return pulumi.get(self, "ssh_key")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sLambdalabsProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")


@pulumi.output_type
class Mk8sLambdalabsProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sLambdalabsProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sLambdalabsProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "instanceType":
            suggest = "instance_type"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLambdalabsProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLambdalabsProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLambdalabsProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instance_type: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePoolTaint']] = None):
        Mk8sLambdalabsProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instance_type=instance_type,
            name=name,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instance_type: str,
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'instanceType' in kwargs:
            instance_type = kwargs['instanceType']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']

        _setter("instance_type", instance_type)
        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> str:
        return pulumi.get(self, "instance_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLambdalabsProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sLambdalabsProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLambdalabsProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePoolTaint']] = None):
        Mk8sLambdalabsProviderUnmanagedNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLambdalabsProviderUnmanagedNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLambdalabsProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sLambdalabsProviderUnmanagedNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sLinodeProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "vpcId":
            suggest = "vpc_id"
        elif key == "authorizedKeys":
            suggest = "authorized_keys"
        elif key == "authorizedUsers":
            suggest = "authorized_users"
        elif key == "firewallId":
            suggest = "firewall_id"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 networking: 'outputs.Mk8sLinodeProviderNetworking',
                 region: str,
                 token_secret_link: str,
                 vpc_id: str,
                 authorized_keys: Optional[Sequence[str]] = None,
                 authorized_users: Optional[Sequence[str]] = None,
                 autoscaler: Optional['outputs.Mk8sLinodeProviderAutoscaler'] = None,
                 firewall_id: Optional[str] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sLinodeProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None):
        Mk8sLinodeProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image=image,
            networking=networking,
            region=region,
            token_secret_link=token_secret_link,
            vpc_id=vpc_id,
            authorized_keys=authorized_keys,
            authorized_users=authorized_users,
            autoscaler=autoscaler,
            firewall_id=firewall_id,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image: str,
             networking: 'outputs.Mk8sLinodeProviderNetworking',
             region: str,
             token_secret_link: str,
             vpc_id: str,
             authorized_keys: Optional[Sequence[str]] = None,
             authorized_users: Optional[Sequence[str]] = None,
             autoscaler: Optional['outputs.Mk8sLinodeProviderAutoscaler'] = None,
             firewall_id: Optional[str] = None,
             node_pools: Optional[Sequence['outputs.Mk8sLinodeProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'vpcId' in kwargs:
            vpc_id = kwargs['vpcId']
        if 'authorizedKeys' in kwargs:
            authorized_keys = kwargs['authorizedKeys']
        if 'authorizedUsers' in kwargs:
            authorized_users = kwargs['authorizedUsers']
        if 'firewallId' in kwargs:
            firewall_id = kwargs['firewallId']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']

        _setter("image", image)
        _setter("networking", networking)
        _setter("region", region)
        _setter("token_secret_link", token_secret_link)
        _setter("vpc_id", vpc_id)
        if authorized_keys is not None:
            _setter("authorized_keys", authorized_keys)
        if authorized_users is not None:
            _setter("authorized_users", authorized_users)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if firewall_id is not None:
            _setter("firewall_id", firewall_id)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sLinodeProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> str:
        return pulumi.get(self, "vpc_id")

    @property
    @pulumi.getter(name="authorizedKeys")
    def authorized_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorized_keys")

    @property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "authorized_users")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sLinodeProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[str]:
        return pulumi.get(self, "firewall_id")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sLinodeProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")


@pulumi.output_type
class Mk8sLinodeProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sLinodeProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sLinodeProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sLinodeProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sLinodeProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serverType":
            suggest = "server_type"
        elif key == "subnetId":
            suggest = "subnet_id"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImage":
            suggest = "override_image"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sLinodeProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sLinodeProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sLinodeProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 server_type: str,
                 subnet_id: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sLinodeProviderNodePoolTaint']] = None):
        Mk8sLinodeProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            server_type=server_type,
            subnet_id=subnet_id,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            override_image=override_image,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             server_type: str,
             subnet_id: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             override_image: Optional[str] = None,
             taints: Optional[Sequence['outputs.Mk8sLinodeProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'serverType' in kwargs:
            server_type = kwargs['serverType']
        if 'subnetId' in kwargs:
            subnet_id = kwargs['subnetId']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'overrideImage' in kwargs:
            override_image = kwargs['overrideImage']

        _setter("name", name)
        _setter("server_type", server_type)
        _setter("subnet_id", subnet_id)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if override_image is not None:
            _setter("override_image", override_image)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serverType")
    def server_type(self) -> str:
        return pulumi.get(self, "server_type")

    @property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> str:
        return pulumi.get(self, "subnet_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[str]:
        return pulumi.get(self, "override_image")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sLinodeProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sLinodeProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sLinodeProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sOblivusProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datacenter: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sOblivusProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_keys: Optional[Sequence[str]] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePool']] = None):
        Mk8sOblivusProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datacenter=datacenter,
            token_secret_link=token_secret_link,
            autoscaler=autoscaler,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            ssh_keys=ssh_keys,
            unmanaged_node_pools=unmanaged_node_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datacenter: str,
             token_secret_link: str,
             autoscaler: Optional['outputs.Mk8sOblivusProviderAutoscaler'] = None,
             node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             unmanaged_node_pools: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePool']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'sshKeys' in kwargs:
            ssh_keys = kwargs['sshKeys']
        if 'unmanagedNodePools' in kwargs:
            unmanaged_node_pools = kwargs['unmanagedNodePools']

        _setter("datacenter", datacenter)
        _setter("token_secret_link", token_secret_link)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)
        if unmanaged_node_pools is not None:
            _setter("unmanaged_node_pools", unmanaged_node_pools)

    @property
    @pulumi.getter
    def datacenter(self) -> str:
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sOblivusProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_keys")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")


@pulumi.output_type
class Mk8sOblivusProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sOblivusProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sOblivusProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sOblivusProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sOblivusProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sOblivusProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 flavor: str,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sOblivusProviderNodePoolTaint']] = None):
        Mk8sOblivusProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            flavor=flavor,
            name=name,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             flavor: str,
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             taints: Optional[Sequence['outputs.Mk8sOblivusProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']

        _setter("flavor", flavor)
        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def flavor(self) -> str:
        return pulumi.get(self, "flavor")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sOblivusProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sOblivusProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sOblivusProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePoolTaint']] = None):
        Mk8sOblivusProviderUnmanagedNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sOblivusProviderUnmanagedNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sOblivusProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sOblivusProviderUnmanagedNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sPaperspaceProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkId":
            suggest = "network_id"
        elif key == "tokenSecretLink":
            suggest = "token_secret_link"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sharedDrives":
            suggest = "shared_drives"
        elif key == "unmanagedNodePools":
            suggest = "unmanaged_node_pools"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_id: str,
                 region: str,
                 token_secret_link: str,
                 autoscaler: Optional['outputs.Mk8sPaperspaceProviderAutoscaler'] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 shared_drives: Optional[Sequence[str]] = None,
                 unmanaged_node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePool']] = None,
                 user_ids: Optional[Sequence[str]] = None):
        Mk8sPaperspaceProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            network_id=network_id,
            region=region,
            token_secret_link=token_secret_link,
            autoscaler=autoscaler,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            shared_drives=shared_drives,
            unmanaged_node_pools=unmanaged_node_pools,
            user_ids=user_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             network_id: str,
             region: str,
             token_secret_link: str,
             autoscaler: Optional['outputs.Mk8sPaperspaceProviderAutoscaler'] = None,
             node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             shared_drives: Optional[Sequence[str]] = None,
             unmanaged_node_pools: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePool']] = None,
             user_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'networkId' in kwargs:
            network_id = kwargs['networkId']
        if 'tokenSecretLink' in kwargs:
            token_secret_link = kwargs['tokenSecretLink']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'sharedDrives' in kwargs:
            shared_drives = kwargs['sharedDrives']
        if 'unmanagedNodePools' in kwargs:
            unmanaged_node_pools = kwargs['unmanagedNodePools']
        if 'userIds' in kwargs:
            user_ids = kwargs['userIds']

        _setter("network_id", network_id)
        _setter("region", region)
        _setter("token_secret_link", token_secret_link)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if shared_drives is not None:
            _setter("shared_drives", shared_drives)
        if unmanaged_node_pools is not None:
            _setter("unmanaged_node_pools", unmanaged_node_pools)
        if user_ids is not None:
            _setter("user_ids", user_ids)

    @property
    @pulumi.getter(name="networkId")
    def network_id(self) -> str:
        return pulumi.get(self, "network_id")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> str:
        return pulumi.get(self, "token_secret_link")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sPaperspaceProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sharedDrives")
    def shared_drives(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "shared_drives")

    @property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePool']]:
        return pulumi.get(self, "unmanaged_node_pools")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class Mk8sPaperspaceProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sPaperspaceProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sPaperspaceProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "machineType":
            suggest = "machine_type"
        elif key == "publicIpType":
            suggest = "public_ip_type"
        elif key == "bootDiskSize":
            suggest = "boot_disk_size"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sPaperspaceProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sPaperspaceProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sPaperspaceProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 machine_type: str,
                 name: str,
                 public_ip_type: str,
                 boot_disk_size: Optional[int] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePoolTaint']] = None):
        Mk8sPaperspaceProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            machine_type=machine_type,
            name=name,
            public_ip_type=public_ip_type,
            boot_disk_size=boot_disk_size,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             machine_type: str,
             name: str,
             public_ip_type: str,
             boot_disk_size: Optional[int] = None,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'machineType' in kwargs:
            machine_type = kwargs['machineType']
        if 'publicIpType' in kwargs:
            public_ip_type = kwargs['publicIpType']
        if 'bootDiskSize' in kwargs:
            boot_disk_size = kwargs['bootDiskSize']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']

        _setter("machine_type", machine_type)
        _setter("name", name)
        _setter("public_ip_type", public_ip_type)
        if boot_disk_size is not None:
            _setter("boot_disk_size", boot_disk_size)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> str:
        return pulumi.get(self, "machine_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="publicIpType")
    def public_ip_type(self) -> str:
        return pulumi.get(self, "public_ip_type")

    @property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[int]:
        return pulumi.get(self, "boot_disk_size")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sPaperspaceProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sPaperspaceProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sPaperspaceProviderUnmanagedNodePool(dict):
    def __init__(__self__, *,
                 name: str,
                 labels: Optional[Mapping[str, str]] = None,
                 taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePoolTaint']] = None):
        Mk8sPaperspaceProviderUnmanagedNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            labels=labels,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             labels: Optional[Mapping[str, str]] = None,
             taints: Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePoolTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("name", name)
        if labels is not None:
            _setter("labels", labels)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sPaperspaceProviderUnmanagedNodePoolTaint']]:
        return pulumi.get(self, "taints")


@pulumi.output_type
class Mk8sPaperspaceProviderUnmanagedNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sPaperspaceProviderUnmanagedNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class Mk8sStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addOns":
            suggest = "add_ons"
        elif key == "homeLocation":
            suggest = "home_location"
        elif key == "oidcProviderUrl":
            suggest = "oidc_provider_url"
        elif key == "serverUrl":
            suggest = "server_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 add_ons: Optional[Sequence['outputs.Mk8sStatusAddOn']] = None,
                 home_location: Optional[str] = None,
                 oidc_provider_url: Optional[str] = None,
                 server_url: Optional[str] = None):
        Mk8sStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            add_ons=add_ons,
            home_location=home_location,
            oidc_provider_url=oidc_provider_url,
            server_url=server_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             add_ons: Optional[Sequence['outputs.Mk8sStatusAddOn']] = None,
             home_location: Optional[str] = None,
             oidc_provider_url: Optional[str] = None,
             server_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'addOns' in kwargs:
            add_ons = kwargs['addOns']
        if 'homeLocation' in kwargs:
            home_location = kwargs['homeLocation']
        if 'oidcProviderUrl' in kwargs:
            oidc_provider_url = kwargs['oidcProviderUrl']
        if 'serverUrl' in kwargs:
            server_url = kwargs['serverUrl']

        if add_ons is not None:
            _setter("add_ons", add_ons)
        if home_location is not None:
            _setter("home_location", home_location)
        if oidc_provider_url is not None:
            _setter("oidc_provider_url", oidc_provider_url)
        if server_url is not None:
            _setter("server_url", server_url)

    @property
    @pulumi.getter(name="addOns")
    def add_ons(self) -> Optional[Sequence['outputs.Mk8sStatusAddOn']]:
        return pulumi.get(self, "add_ons")

    @property
    @pulumi.getter(name="homeLocation")
    def home_location(self) -> Optional[str]:
        return pulumi.get(self, "home_location")

    @property
    @pulumi.getter(name="oidcProviderUrl")
    def oidc_provider_url(self) -> Optional[str]:
        return pulumi.get(self, "oidc_provider_url")

    @property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[str]:
        return pulumi.get(self, "server_url")


@pulumi.output_type
class Mk8sStatusAddOn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsEcrs":
            suggest = "aws_ecrs"
        elif key == "awsEfs":
            suggest = "aws_efs"
        elif key == "awsElbs":
            suggest = "aws_elbs"
        elif key == "awsWorkloadIdentities":
            suggest = "aws_workload_identities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_ecrs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEcr']] = None,
                 aws_efs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEf']] = None,
                 aws_elbs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsElb']] = None,
                 aws_workload_identities: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentity']] = None,
                 dashboards: Optional[Sequence['outputs.Mk8sStatusAddOnDashboard']] = None,
                 logs: Optional[Sequence['outputs.Mk8sStatusAddOnLog']] = None,
                 metrics: Optional[Sequence['outputs.Mk8sStatusAddOnMetric']] = None):
        Mk8sStatusAddOn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aws_ecrs=aws_ecrs,
            aws_efs=aws_efs,
            aws_elbs=aws_elbs,
            aws_workload_identities=aws_workload_identities,
            dashboards=dashboards,
            logs=logs,
            metrics=metrics,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aws_ecrs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEcr']] = None,
             aws_efs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsEf']] = None,
             aws_elbs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsElb']] = None,
             aws_workload_identities: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentity']] = None,
             dashboards: Optional[Sequence['outputs.Mk8sStatusAddOnDashboard']] = None,
             logs: Optional[Sequence['outputs.Mk8sStatusAddOnLog']] = None,
             metrics: Optional[Sequence['outputs.Mk8sStatusAddOnMetric']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'awsEcrs' in kwargs:
            aws_ecrs = kwargs['awsEcrs']
        if 'awsEfs' in kwargs:
            aws_efs = kwargs['awsEfs']
        if 'awsElbs' in kwargs:
            aws_elbs = kwargs['awsElbs']
        if 'awsWorkloadIdentities' in kwargs:
            aws_workload_identities = kwargs['awsWorkloadIdentities']

        if aws_ecrs is not None:
            _setter("aws_ecrs", aws_ecrs)
        if aws_efs is not None:
            _setter("aws_efs", aws_efs)
        if aws_elbs is not None:
            _setter("aws_elbs", aws_elbs)
        if aws_workload_identities is not None:
            _setter("aws_workload_identities", aws_workload_identities)
        if dashboards is not None:
            _setter("dashboards", dashboards)
        if logs is not None:
            _setter("logs", logs)
        if metrics is not None:
            _setter("metrics", metrics)

    @property
    @pulumi.getter(name="awsEcrs")
    def aws_ecrs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsEcr']]:
        return pulumi.get(self, "aws_ecrs")

    @property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsEf']]:
        return pulumi.get(self, "aws_efs")

    @property
    @pulumi.getter(name="awsElbs")
    def aws_elbs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsElb']]:
        return pulumi.get(self, "aws_elbs")

    @property
    @pulumi.getter(name="awsWorkloadIdentities")
    def aws_workload_identities(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentity']]:
        return pulumi.get(self, "aws_workload_identities")

    @property
    @pulumi.getter
    def dashboards(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnDashboard']]:
        return pulumi.get(self, "dashboards")

    @property
    @pulumi.getter
    def logs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnLog']]:
        return pulumi.get(self, "logs")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnMetric']]:
        return pulumi.get(self, "metrics")


@pulumi.output_type
class Mk8sStatusAddOnAwsEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        Mk8sStatusAddOnAwsEcr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust_policy=trust_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustPolicy' in kwargs:
            trust_policy = kwargs['trustPolicy']

        if trust_policy is not None:
            _setter("trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsEf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsEf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsEf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsEf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        Mk8sStatusAddOnAwsEf._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust_policy=trust_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustPolicy' in kwargs:
            trust_policy = kwargs['trustPolicy']

        if trust_policy is not None:
            _setter("trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsElb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsElb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsElb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsElb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trust_policy: Optional[str] = None):
        Mk8sStatusAddOnAwsElb._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            trust_policy=trust_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             trust_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustPolicy' in kwargs:
            trust_policy = kwargs['trustPolicy']

        if trust_policy is not None:
            _setter("trust_policy", trust_policy)

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsWorkloadIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oidcProviderConfigs":
            suggest = "oidc_provider_configs"
        elif key == "trustPolicy":
            suggest = "trust_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsWorkloadIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oidc_provider_configs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig']] = None,
                 trust_policy: Optional[str] = None):
        Mk8sStatusAddOnAwsWorkloadIdentity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            oidc_provider_configs=oidc_provider_configs,
            trust_policy=trust_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             oidc_provider_configs: Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig']] = None,
             trust_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'oidcProviderConfigs' in kwargs:
            oidc_provider_configs = kwargs['oidcProviderConfigs']
        if 'trustPolicy' in kwargs:
            trust_policy = kwargs['trustPolicy']

        if oidc_provider_configs is not None:
            _setter("oidc_provider_configs", oidc_provider_configs)
        if trust_policy is not None:
            _setter("trust_policy", trust_policy)

    @property
    @pulumi.getter(name="oidcProviderConfigs")
    def oidc_provider_configs(self) -> Optional[Sequence['outputs.Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig']]:
        return pulumi.get(self, "oidc_provider_configs")

    @property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[str]:
        return pulumi.get(self, "trust_policy")


@pulumi.output_type
class Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "providerUrl":
            suggest = "provider_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audience: Optional[str] = None,
                 provider_url: Optional[str] = None):
        Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            audience=audience,
            provider_url=provider_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             audience: Optional[str] = None,
             provider_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'providerUrl' in kwargs:
            provider_url = kwargs['providerUrl']

        if audience is not None:
            _setter("audience", audience)
        if provider_url is not None:
            _setter("provider_url", provider_url)

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="providerUrl")
    def provider_url(self) -> Optional[str]:
        return pulumi.get(self, "provider_url")


@pulumi.output_type
class Mk8sStatusAddOnDashboard(dict):
    def __init__(__self__, *,
                 url: Optional[str] = None):
        Mk8sStatusAddOnDashboard._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class Mk8sStatusAddOnLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lokiAddress":
            suggest = "loki_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 loki_address: Optional[str] = None):
        Mk8sStatusAddOnLog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            loki_address=loki_address,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             loki_address: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'lokiAddress' in kwargs:
            loki_address = kwargs['lokiAddress']

        if loki_address is not None:
            _setter("loki_address", loki_address)

    @property
    @pulumi.getter(name="lokiAddress")
    def loki_address(self) -> Optional[str]:
        return pulumi.get(self, "loki_address")


@pulumi.output_type
class Mk8sStatusAddOnMetric(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "prometheusEndpoint":
            suggest = "prometheus_endpoint"
        elif key == "remoteWriteConfig":
            suggest = "remote_write_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sStatusAddOnMetric. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sStatusAddOnMetric.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sStatusAddOnMetric.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prometheus_endpoint: Optional[str] = None,
                 remote_write_config: Optional[str] = None):
        Mk8sStatusAddOnMetric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            prometheus_endpoint=prometheus_endpoint,
            remote_write_config=remote_write_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             prometheus_endpoint: Optional[str] = None,
             remote_write_config: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'prometheusEndpoint' in kwargs:
            prometheus_endpoint = kwargs['prometheusEndpoint']
        if 'remoteWriteConfig' in kwargs:
            remote_write_config = kwargs['remoteWriteConfig']

        if prometheus_endpoint is not None:
            _setter("prometheus_endpoint", prometheus_endpoint)
        if remote_write_config is not None:
            _setter("remote_write_config", remote_write_config)

    @property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "prometheus_endpoint")

    @property
    @pulumi.getter(name="remoteWriteConfig")
    def remote_write_config(self) -> Optional[str]:
        return pulumi.get(self, "remote_write_config")


@pulumi.output_type
class Mk8sTritonProvider(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageId":
            suggest = "image_id"
        elif key == "privateNetworkId":
            suggest = "private_network_id"
        elif key == "firewallEnabled":
            suggest = "firewall_enabled"
        elif key == "nodePools":
            suggest = "node_pools"
        elif key == "preInstallScript":
            suggest = "pre_install_script"
        elif key == "sshKeys":
            suggest = "ssh_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProvider. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProvider.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProvider.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection: 'outputs.Mk8sTritonProviderConnection',
                 image_id: str,
                 location: str,
                 networking: 'outputs.Mk8sTritonProviderNetworking',
                 private_network_id: str,
                 autoscaler: Optional['outputs.Mk8sTritonProviderAutoscaler'] = None,
                 firewall_enabled: Optional[bool] = None,
                 node_pools: Optional[Sequence['outputs.Mk8sTritonProviderNodePool']] = None,
                 pre_install_script: Optional[str] = None,
                 ssh_keys: Optional[Sequence[str]] = None):
        Mk8sTritonProvider._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            connection=connection,
            image_id=image_id,
            location=location,
            networking=networking,
            private_network_id=private_network_id,
            autoscaler=autoscaler,
            firewall_enabled=firewall_enabled,
            node_pools=node_pools,
            pre_install_script=pre_install_script,
            ssh_keys=ssh_keys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             connection: 'outputs.Mk8sTritonProviderConnection',
             image_id: str,
             location: str,
             networking: 'outputs.Mk8sTritonProviderNetworking',
             private_network_id: str,
             autoscaler: Optional['outputs.Mk8sTritonProviderAutoscaler'] = None,
             firewall_enabled: Optional[bool] = None,
             node_pools: Optional[Sequence['outputs.Mk8sTritonProviderNodePool']] = None,
             pre_install_script: Optional[str] = None,
             ssh_keys: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'imageId' in kwargs:
            image_id = kwargs['imageId']
        if 'privateNetworkId' in kwargs:
            private_network_id = kwargs['privateNetworkId']
        if 'firewallEnabled' in kwargs:
            firewall_enabled = kwargs['firewallEnabled']
        if 'nodePools' in kwargs:
            node_pools = kwargs['nodePools']
        if 'preInstallScript' in kwargs:
            pre_install_script = kwargs['preInstallScript']
        if 'sshKeys' in kwargs:
            ssh_keys = kwargs['sshKeys']

        _setter("connection", connection)
        _setter("image_id", image_id)
        _setter("location", location)
        _setter("networking", networking)
        _setter("private_network_id", private_network_id)
        if autoscaler is not None:
            _setter("autoscaler", autoscaler)
        if firewall_enabled is not None:
            _setter("firewall_enabled", firewall_enabled)
        if node_pools is not None:
            _setter("node_pools", node_pools)
        if pre_install_script is not None:
            _setter("pre_install_script", pre_install_script)
        if ssh_keys is not None:
            _setter("ssh_keys", ssh_keys)

    @property
    @pulumi.getter
    def connection(self) -> 'outputs.Mk8sTritonProviderConnection':
        return pulumi.get(self, "connection")

    @property
    @pulumi.getter(name="imageId")
    def image_id(self) -> str:
        return pulumi.get(self, "image_id")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def networking(self) -> 'outputs.Mk8sTritonProviderNetworking':
        return pulumi.get(self, "networking")

    @property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> str:
        return pulumi.get(self, "private_network_id")

    @property
    @pulumi.getter
    def autoscaler(self) -> Optional['outputs.Mk8sTritonProviderAutoscaler']:
        return pulumi.get(self, "autoscaler")

    @property
    @pulumi.getter(name="firewallEnabled")
    def firewall_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "firewall_enabled")

    @property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[Sequence['outputs.Mk8sTritonProviderNodePool']]:
        return pulumi.get(self, "node_pools")

    @property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[str]:
        return pulumi.get(self, "pre_install_script")

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "ssh_keys")


@pulumi.output_type
class Mk8sTritonProviderAutoscaler(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "unneededTime":
            suggest = "unneeded_time"
        elif key == "unreadyTime":
            suggest = "unready_time"
        elif key == "utilizationThreshold":
            suggest = "utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderAutoscaler. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderAutoscaler.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderAutoscaler.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Sequence[str],
                 unneeded_time: Optional[str] = None,
                 unready_time: Optional[str] = None,
                 utilization_threshold: Optional[float] = None):
        Mk8sTritonProviderAutoscaler._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expanders=expanders,
            unneeded_time=unneeded_time,
            unready_time=unready_time,
            utilization_threshold=utilization_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expanders: Sequence[str],
             unneeded_time: Optional[str] = None,
             unready_time: Optional[str] = None,
             utilization_threshold: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'unneededTime' in kwargs:
            unneeded_time = kwargs['unneededTime']
        if 'unreadyTime' in kwargs:
            unready_time = kwargs['unreadyTime']
        if 'utilizationThreshold' in kwargs:
            utilization_threshold = kwargs['utilizationThreshold']

        _setter("expanders", expanders)
        if unneeded_time is not None:
            _setter("unneeded_time", unneeded_time)
        if unready_time is not None:
            _setter("unready_time", unready_time)
        if utilization_threshold is not None:
            _setter("utilization_threshold", utilization_threshold)

    @property
    @pulumi.getter
    def expanders(self) -> Sequence[str]:
        return pulumi.get(self, "expanders")

    @property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[str]:
        return pulumi.get(self, "unneeded_time")

    @property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[str]:
        return pulumi.get(self, "unready_time")

    @property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[float]:
        return pulumi.get(self, "utilization_threshold")


@pulumi.output_type
class Mk8sTritonProviderConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeySecretLink":
            suggest = "private_key_secret_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account: str,
                 private_key_secret_link: str,
                 url: str,
                 user: Optional[str] = None):
        Mk8sTritonProviderConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account=account,
            private_key_secret_link=private_key_secret_link,
            url=url,
            user=user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account: str,
             private_key_secret_link: str,
             url: str,
             user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'privateKeySecretLink' in kwargs:
            private_key_secret_link = kwargs['privateKeySecretLink']

        _setter("account", account)
        _setter("private_key_secret_link", private_key_secret_link)
        _setter("url", url)
        if user is not None:
            _setter("user", user)

    @property
    @pulumi.getter
    def account(self) -> str:
        return pulumi.get(self, "account")

    @property
    @pulumi.getter(name="privateKeySecretLink")
    def private_key_secret_link(self) -> str:
        return pulumi.get(self, "private_key_secret_link")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def user(self) -> Optional[str]:
        return pulumi.get(self, "user")


@pulumi.output_type
class Mk8sTritonProviderNetworking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podNetwork":
            suggest = "pod_network"
        elif key == "serviceNetwork":
            suggest = "service_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderNetworking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderNetworking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderNetworking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_network: Optional[str] = None,
                 service_network: Optional[str] = None):
        Mk8sTritonProviderNetworking._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_network=pod_network,
            service_network=service_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_network: Optional[str] = None,
             service_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'podNetwork' in kwargs:
            pod_network = kwargs['podNetwork']
        if 'serviceNetwork' in kwargs:
            service_network = kwargs['serviceNetwork']

        if pod_network is not None:
            _setter("pod_network", pod_network)
        if service_network is not None:
            _setter("service_network", service_network)

    @property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[str]:
        return pulumi.get(self, "pod_network")

    @property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[str]:
        return pulumi.get(self, "service_network")


@pulumi.output_type
class Mk8sTritonProviderNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageId":
            suggest = "package_id"
        elif key == "maxSize":
            suggest = "max_size"
        elif key == "minSize":
            suggest = "min_size"
        elif key == "overrideImageId":
            suggest = "override_image_id"
        elif key == "privateNetworkIds":
            suggest = "private_network_ids"
        elif key == "publicNetworkId":
            suggest = "public_network_id"
        elif key == "tritonTags":
            suggest = "triton_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Mk8sTritonProviderNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Mk8sTritonProviderNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Mk8sTritonProviderNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 package_id: str,
                 labels: Optional[Mapping[str, str]] = None,
                 max_size: Optional[int] = None,
                 min_size: Optional[int] = None,
                 override_image_id: Optional[str] = None,
                 private_network_ids: Optional[Sequence[str]] = None,
                 public_network_id: Optional[str] = None,
                 taints: Optional[Sequence['outputs.Mk8sTritonProviderNodePoolTaint']] = None,
                 triton_tags: Optional[Mapping[str, str]] = None):
        Mk8sTritonProviderNodePool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            package_id=package_id,
            labels=labels,
            max_size=max_size,
            min_size=min_size,
            override_image_id=override_image_id,
            private_network_ids=private_network_ids,
            public_network_id=public_network_id,
            taints=taints,
            triton_tags=triton_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             package_id: str,
             labels: Optional[Mapping[str, str]] = None,
             max_size: Optional[int] = None,
             min_size: Optional[int] = None,
             override_image_id: Optional[str] = None,
             private_network_ids: Optional[Sequence[str]] = None,
             public_network_id: Optional[str] = None,
             taints: Optional[Sequence['outputs.Mk8sTritonProviderNodePoolTaint']] = None,
             triton_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'packageId' in kwargs:
            package_id = kwargs['packageId']
        if 'maxSize' in kwargs:
            max_size = kwargs['maxSize']
        if 'minSize' in kwargs:
            min_size = kwargs['minSize']
        if 'overrideImageId' in kwargs:
            override_image_id = kwargs['overrideImageId']
        if 'privateNetworkIds' in kwargs:
            private_network_ids = kwargs['privateNetworkIds']
        if 'publicNetworkId' in kwargs:
            public_network_id = kwargs['publicNetworkId']
        if 'tritonTags' in kwargs:
            triton_tags = kwargs['tritonTags']

        _setter("name", name)
        _setter("package_id", package_id)
        if labels is not None:
            _setter("labels", labels)
        if max_size is not None:
            _setter("max_size", max_size)
        if min_size is not None:
            _setter("min_size", min_size)
        if override_image_id is not None:
            _setter("override_image_id", override_image_id)
        if private_network_ids is not None:
            _setter("private_network_ids", private_network_ids)
        if public_network_id is not None:
            _setter("public_network_id", public_network_id)
        if taints is not None:
            _setter("taints", taints)
        if triton_tags is not None:
            _setter("triton_tags", triton_tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="packageId")
    def package_id(self) -> str:
        return pulumi.get(self, "package_id")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[int]:
        return pulumi.get(self, "max_size")

    @property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[int]:
        return pulumi.get(self, "min_size")

    @property
    @pulumi.getter(name="overrideImageId")
    def override_image_id(self) -> Optional[str]:
        return pulumi.get(self, "override_image_id")

    @property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "private_network_ids")

    @property
    @pulumi.getter(name="publicNetworkId")
    def public_network_id(self) -> Optional[str]:
        return pulumi.get(self, "public_network_id")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.Mk8sTritonProviderNodePoolTaint']]:
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="tritonTags")
    def triton_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "triton_tags")


@pulumi.output_type
class Mk8sTritonProviderNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        Mk8sTritonProviderNodePoolTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class OrgAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainAutoMembers":
            suggest = "domain_auto_members"
        elif key == "samlOnly":
            suggest = "saml_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_auto_members: Sequence[str],
                 saml_only: Optional[bool] = None):
        OrgAuthConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain_auto_members=domain_auto_members,
            saml_only=saml_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain_auto_members: Sequence[str],
             saml_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'domainAutoMembers' in kwargs:
            domain_auto_members = kwargs['domainAutoMembers']
        if 'samlOnly' in kwargs:
            saml_only = kwargs['samlOnly']

        _setter("domain_auto_members", domain_auto_members)
        if saml_only is not None:
            _setter("saml_only", saml_only)

    @property
    @pulumi.getter(name="domainAutoMembers")
    def domain_auto_members(self) -> Sequence[str]:
        return pulumi.get(self, "domain_auto_members")

    @property
    @pulumi.getter(name="samlOnly")
    def saml_only(self) -> Optional[bool]:
        return pulumi.get(self, "saml_only")


@pulumi.output_type
class OrgLoggingCloudWatchLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupName":
            suggest = "group_name"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "extractFields":
            suggest = "extract_fields"
        elif key == "retentionDays":
            suggest = "retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingCloudWatchLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingCloudWatchLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingCloudWatchLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 group_name: str,
                 region: str,
                 stream_name: str,
                 extract_fields: Optional[Mapping[str, str]] = None,
                 retention_days: Optional[int] = None):
        OrgLoggingCloudWatchLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            group_name=group_name,
            region=region,
            stream_name=stream_name,
            extract_fields=extract_fields,
            retention_days=retention_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             group_name: str,
             region: str,
             stream_name: str,
             extract_fields: Optional[Mapping[str, str]] = None,
             retention_days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'groupName' in kwargs:
            group_name = kwargs['groupName']
        if 'streamName' in kwargs:
            stream_name = kwargs['streamName']
        if 'extractFields' in kwargs:
            extract_fields = kwargs['extractFields']
        if 'retentionDays' in kwargs:
            retention_days = kwargs['retentionDays']

        _setter("credentials", credentials)
        _setter("group_name", group_name)
        _setter("region", region)
        _setter("stream_name", stream_name)
        if extract_fields is not None:
            _setter("extract_fields", extract_fields)
        if retention_days is not None:
            _setter("retention_days", retention_days)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> str:
        return pulumi.get(self, "group_name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="extractFields")
    def extract_fields(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "extract_fields")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[int]:
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class OrgLoggingCoralogixLogging(dict):
    def __init__(__self__, *,
                 app: str,
                 cluster: str,
                 credentials: str,
                 subsystem: str):
        OrgLoggingCoralogixLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            app=app,
            cluster=cluster,
            credentials=credentials,
            subsystem=subsystem,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             app: str,
             cluster: str,
             credentials: str,
             subsystem: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("app", app)
        _setter("cluster", cluster)
        _setter("credentials", credentials)
        _setter("subsystem", subsystem)

    @property
    @pulumi.getter
    def app(self) -> str:
        return pulumi.get(self, "app")

    @property
    @pulumi.getter
    def cluster(self) -> str:
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def subsystem(self) -> str:
        return pulumi.get(self, "subsystem")


@pulumi.output_type
class OrgLoggingDatadogLogging(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str):
        OrgLoggingDatadogLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")


@pulumi.output_type
class OrgLoggingElasticLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elasticCloud":
            suggest = "elastic_cloud"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 aws: Optional['outputs.OrgLoggingElasticLoggingAws'] = None,
                 elastic_cloud: Optional['outputs.OrgLoggingElasticLoggingElasticCloud'] = None,
                 generic: Optional['outputs.OrgLoggingElasticLoggingGeneric'] = None):
        OrgLoggingElasticLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            aws=aws,
            elastic_cloud=elastic_cloud,
            generic=generic,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             aws: Optional['outputs.OrgLoggingElasticLoggingAws'] = None,
             elastic_cloud: Optional['outputs.OrgLoggingElasticLoggingElasticCloud'] = None,
             generic: Optional['outputs.OrgLoggingElasticLoggingGeneric'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'elasticCloud' in kwargs:
            elastic_cloud = kwargs['elasticCloud']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if aws is not None:
            _setter("aws", aws)
        if elastic_cloud is not None:
            _setter("elastic_cloud", elastic_cloud)
        if generic is not None:
            _setter("generic", generic)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def aws(self) -> Optional['outputs.OrgLoggingElasticLoggingAws']:
        return pulumi.get(self, "aws")

    @property
    @pulumi.getter(name="elasticCloud")
    def elastic_cloud(self) -> Optional['outputs.OrgLoggingElasticLoggingElasticCloud']:
        return pulumi.get(self, "elastic_cloud")

    @property
    @pulumi.getter
    def generic(self) -> Optional['outputs.OrgLoggingElasticLoggingGeneric']:
        return pulumi.get(self, "generic")


@pulumi.output_type
class OrgLoggingElasticLoggingAws(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 port: int,
                 region: str,
                 type: str):
        OrgLoggingElasticLoggingAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
            index=index,
            port=port,
            region=region,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             index: str,
             port: int,
             region: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)
        _setter("index", index)
        _setter("port", port)
        _setter("region", region)
        _setter("type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingElasticCloud(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cloudId":
            suggest = "cloud_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingElasticLoggingElasticCloud. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingElasticLoggingElasticCloud.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cloud_id: str,
                 credentials: str,
                 index: str,
                 type: str):
        OrgLoggingElasticLoggingElasticCloud._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_id=cloud_id,
            credentials=credentials,
            index=index,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_id: str,
             credentials: str,
             index: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudId' in kwargs:
            cloud_id = kwargs['cloudId']

        _setter("cloud_id", cloud_id)
        _setter("credentials", credentials)
        _setter("index", index)
        _setter("type", type)

    @property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> str:
        return pulumi.get(self, "cloud_id")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingElasticLoggingGeneric(dict):
    def __init__(__self__, *,
                 credentials: str,
                 host: str,
                 index: str,
                 path: str,
                 port: int,
                 type: str):
        OrgLoggingElasticLoggingGeneric._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            host=host,
            index=index,
            path=path,
            port=port,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             host: str,
             index: str,
             path: str,
             port: int,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("host", host)
        _setter("index", index)
        _setter("path", path)
        _setter("port", port)
        _setter("type", type)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class OrgLoggingFluentdLogging(dict):
    def __init__(__self__, *,
                 host: str,
                 port: Optional[int] = None):
        OrgLoggingFluentdLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: str,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("host", host)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class OrgLoggingLogzioLogging(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "listenerHost":
            suggest = "listener_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgLoggingLogzioLogging. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgLoggingLogzioLogging.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 listener_host: str):
        OrgLoggingLogzioLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            listener_host=listener_host,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             listener_host: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'listenerHost' in kwargs:
            listener_host = kwargs['listenerHost']

        _setter("credentials", credentials)
        _setter("listener_host", listener_host)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="listenerHost")
    def listener_host(self) -> str:
        return pulumi.get(self, "listener_host")


@pulumi.output_type
class OrgLoggingS3Logging(dict):
    def __init__(__self__, *,
                 bucket: str,
                 credentials: str,
                 region: str,
                 prefix: Optional[str] = None):
        OrgLoggingS3Logging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            credentials=credentials,
            region=region,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             credentials: str,
             region: str,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("bucket", bucket)
        _setter("credentials", credentials)
        _setter("region", region)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class OrgLoggingStackdriverLogging(dict):
    def __init__(__self__, *,
                 credentials: str,
                 location: str):
        OrgLoggingStackdriverLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            credentials=credentials,
            location=location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             credentials: str,
             location: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("credentials", credentials)
        _setter("location", location)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")


@pulumi.output_type
class OrgLoggingSyslogLogging(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 format: Optional[str] = None,
                 mode: Optional[str] = None,
                 severity: Optional[int] = None):
        OrgLoggingSyslogLogging._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
            format=format,
            mode=mode,
            severity=severity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: str,
             port: int,
             format: Optional[str] = None,
             mode: Optional[str] = None,
             severity: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("host", host)
        _setter("port", port)
        if format is not None:
            _setter("format", format)
        if mode is not None:
            _setter("mode", mode)
        if severity is not None:
            _setter("severity", severity)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def severity(self) -> Optional[int]:
        return pulumi.get(self, "severity")


@pulumi.output_type
class OrgObservability(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsRetentionDays":
            suggest = "logs_retention_days"
        elif key == "metricsRetentionDays":
            suggest = "metrics_retention_days"
        elif key == "tracesRetentionDays":
            suggest = "traces_retention_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgObservability. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgObservability.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgObservability.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_retention_days: Optional[int] = None,
                 metrics_retention_days: Optional[int] = None,
                 traces_retention_days: Optional[int] = None):
        OrgObservability._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            logs_retention_days=logs_retention_days,
            metrics_retention_days=metrics_retention_days,
            traces_retention_days=traces_retention_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             logs_retention_days: Optional[int] = None,
             metrics_retention_days: Optional[int] = None,
             traces_retention_days: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'logsRetentionDays' in kwargs:
            logs_retention_days = kwargs['logsRetentionDays']
        if 'metricsRetentionDays' in kwargs:
            metrics_retention_days = kwargs['metricsRetentionDays']
        if 'tracesRetentionDays' in kwargs:
            traces_retention_days = kwargs['tracesRetentionDays']

        if logs_retention_days is not None:
            _setter("logs_retention_days", logs_retention_days)
        if metrics_retention_days is not None:
            _setter("metrics_retention_days", metrics_retention_days)
        if traces_retention_days is not None:
            _setter("traces_retention_days", traces_retention_days)

    @property
    @pulumi.getter(name="logsRetentionDays")
    def logs_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "logs_retention_days")

    @property
    @pulumi.getter(name="metricsRetentionDays")
    def metrics_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "metrics_retention_days")

    @property
    @pulumi.getter(name="tracesRetentionDays")
    def traces_retention_days(self) -> Optional[int]:
        return pulumi.get(self, "traces_retention_days")


@pulumi.output_type
class OrgSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "threatDetection":
            suggest = "threat_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 threat_detection: Optional['outputs.OrgSecurityThreatDetection'] = None):
        OrgSecurity._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            threat_detection=threat_detection,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             threat_detection: Optional['outputs.OrgSecurityThreatDetection'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'threatDetection' in kwargs:
            threat_detection = kwargs['threatDetection']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if threat_detection is not None:
            _setter("threat_detection", threat_detection)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="threatDetection")
    def threat_detection(self) -> Optional['outputs.OrgSecurityThreatDetection']:
        return pulumi.get(self, "threat_detection")


@pulumi.output_type
class OrgSecurityThreatDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minimumSeverity":
            suggest = "minimum_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgSecurityThreatDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgSecurityThreatDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgSecurityThreatDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 minimum_severity: Optional[str] = None,
                 syslog: Optional['outputs.OrgSecurityThreatDetectionSyslog'] = None):
        OrgSecurityThreatDetection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            minimum_severity=minimum_severity,
            syslog=syslog,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             minimum_severity: Optional[str] = None,
             syslog: Optional['outputs.OrgSecurityThreatDetectionSyslog'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'minimumSeverity' in kwargs:
            minimum_severity = kwargs['minimumSeverity']

        _setter("enabled", enabled)
        if minimum_severity is not None:
            _setter("minimum_severity", minimum_severity)
        if syslog is not None:
            _setter("syslog", syslog)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="minimumSeverity")
    def minimum_severity(self) -> Optional[str]:
        return pulumi.get(self, "minimum_severity")

    @property
    @pulumi.getter
    def syslog(self) -> Optional['outputs.OrgSecurityThreatDetectionSyslog']:
        return pulumi.get(self, "syslog")


@pulumi.output_type
class OrgSecurityThreatDetectionSyslog(dict):
    def __init__(__self__, *,
                 host: str,
                 port: int,
                 transport: Optional[str] = None):
        OrgSecurityThreatDetectionSyslog._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            host=host,
            port=port,
            transport=transport,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             host: str,
             port: int,
             transport: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("host", host)
        _setter("port", port)
        if transport is not None:
            _setter("transport", transport)

    @property
    @pulumi.getter
    def host(self) -> str:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def transport(self) -> Optional[str]:
        return pulumi.get(self, "transport")


@pulumi.output_type
class OrgStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountLink":
            suggest = "account_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_link: Optional[str] = None,
                 active: Optional[bool] = None):
        OrgStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_link=account_link,
            active=active,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_link: Optional[str] = None,
             active: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountLink' in kwargs:
            account_link = kwargs['accountLink']

        if account_link is not None:
            _setter("account_link", account_link)
        if active is not None:
            _setter("active", active)

    @property
    @pulumi.getter(name="accountLink")
    def account_link(self) -> Optional[str]:
        return pulumi.get(self, "account_link")

    @property
    @pulumi.getter
    def active(self) -> Optional[bool]:
        return pulumi.get(self, "active")


@pulumi.output_type
class OrgTracingControlplaneTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingControlplaneTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingControlplaneTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingControlplaneTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingLightstepTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingLightstepTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingLightstepTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingLightstepTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class OrgTracingOtelTracing(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customTags":
            suggest = "custom_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrgTracingOtelTracing. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrgTracingOtelTracing.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        OrgTracingOtelTracing._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class PolicyBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "principalLinks":
            suggest = "principal_links"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions: Sequence[str],
                 principal_links: Sequence[str]):
        PolicyBinding._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            permissions=permissions,
            principal_links=principal_links,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             permissions: Sequence[str],
             principal_links: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'principalLinks' in kwargs:
            principal_links = kwargs['principalLinks']

        _setter("permissions", permissions)
        _setter("principal_links", principal_links)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[str]:
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="principalLinks")
    def principal_links(self) -> Sequence[str]:
        return pulumi.get(self, "principal_links")


@pulumi.output_type
class PolicyTargetQuery(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.PolicyTargetQuerySpec'] = None):
        PolicyTargetQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fetch=fetch,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fetch: Optional[str] = None,
             spec: Optional['outputs.PolicyTargetQuerySpec'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if fetch is not None:
            _setter("fetch", fetch)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.PolicyTargetQuerySpec']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class PolicyTargetQuerySpec(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']] = None):
        PolicyTargetQuerySpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
            terms=terms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional[str] = None,
             terms: Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if match is not None:
            _setter("match", match)
        if terms is not None:
            _setter("terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.PolicyTargetQuerySpecTerm']]:
        return pulumi.get(self, "terms")


@pulumi.output_type
class PolicyTargetQuerySpecTerm(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        PolicyTargetQuerySpecTerm._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            op=op,
            property=property,
            rel=rel,
            tag=tag,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             op: Optional[str] = None,
             property: Optional[str] = None,
             rel: Optional[str] = None,
             tag: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if op is not None:
            _setter("op", op)
        if property is not None:
            _setter("property", property)
        if rel is not None:
            _setter("rel", rel)
        if tag is not None:
            _setter("tag", tag)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class SecretAws(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        SecretAws._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretAzureConnector(dict):
    def __init__(__self__, *,
                 code: str,
                 url: str):
        SecretAzureConnector._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: str,
             url: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("code", code)
        _setter("url", url)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class SecretEcr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretEcr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretEcr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretEcr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: str,
                 repos: Sequence[str],
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        SecretEcr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            repos=repos,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             repos: Sequence[str],
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("repos", repos)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def repos(self) -> Sequence[str]:
        return pulumi.get(self, "repos")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class SecretKeypair(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKey":
            suggest = "secret_key"
        elif key == "publicKey":
            suggest = "public_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretKeypair. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretKeypair.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretKeypair.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key: str,
                 passphrase: Optional[str] = None,
                 public_key: Optional[str] = None):
        SecretKeypair._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_key=secret_key,
            passphrase=passphrase,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_key: str,
             passphrase: Optional[str] = None,
             public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'publicKey' in kwargs:
            public_key = kwargs['publicKey']

        _setter("secret_key", secret_key)
        if passphrase is not None:
            _setter("passphrase", passphrase)
        if public_key is not None:
            _setter("public_key", public_key)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class SecretNatsAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretNatsAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretNatsAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 private_key: str):
        SecretNatsAccount._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: str,
             private_key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'privateKey' in kwargs:
            private_key = kwargs['privateKey']

        _setter("account_id", account_id)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class SecretOpaque(dict):
    def __init__(__self__, *,
                 payload: str,
                 encoding: Optional[str] = None):
        SecretOpaque._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload=payload,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("payload", payload)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def payload(self) -> str:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


@pulumi.output_type
class SecretTls(dict):
    def __init__(__self__, *,
                 cert: str,
                 key: str,
                 chain: Optional[str] = None):
        SecretTls._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            key=key,
            chain=chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: str,
             key: str,
             chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cert", cert)
        _setter("key", key)
        if chain is not None:
            _setter("chain", chain)

    @property
    @pulumi.getter
    def cert(self) -> str:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        return pulumi.get(self, "chain")


@pulumi.output_type
class SecretUserpass(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 encoding: Optional[str] = None):
        SecretUserpass._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("password", password)
        _setter("username", username)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


@pulumi.output_type
class VolumeSetAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxCapacity":
            suggest = "max_capacity"
        elif key == "minFreePercentage":
            suggest = "min_free_percentage"
        elif key == "scalingFactor":
            suggest = "scaling_factor"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_capacity: Optional[int] = None,
                 min_free_percentage: Optional[int] = None,
                 scaling_factor: Optional[float] = None):
        VolumeSetAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_capacity=max_capacity,
            min_free_percentage=min_free_percentage,
            scaling_factor=scaling_factor,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_capacity: Optional[int] = None,
             min_free_percentage: Optional[int] = None,
             scaling_factor: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxCapacity' in kwargs:
            max_capacity = kwargs['maxCapacity']
        if 'minFreePercentage' in kwargs:
            min_free_percentage = kwargs['minFreePercentage']
        if 'scalingFactor' in kwargs:
            scaling_factor = kwargs['scalingFactor']

        if max_capacity is not None:
            _setter("max_capacity", max_capacity)
        if min_free_percentage is not None:
            _setter("min_free_percentage", min_free_percentage)
        if scaling_factor is not None:
            _setter("scaling_factor", scaling_factor)

    @property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[int]:
        return pulumi.get(self, "max_capacity")

    @property
    @pulumi.getter(name="minFreePercentage")
    def min_free_percentage(self) -> Optional[int]:
        return pulumi.get(self, "min_free_percentage")

    @property
    @pulumi.getter(name="scalingFactor")
    def scaling_factor(self) -> Optional[float]:
        return pulumi.get(self, "scaling_factor")


@pulumi.output_type
class VolumeSetSnapshots(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createFinalSnapshot":
            suggest = "create_final_snapshot"
        elif key == "retentionDuration":
            suggest = "retention_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetSnapshots. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetSnapshots.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_final_snapshot: Optional[bool] = None,
                 retention_duration: Optional[str] = None,
                 schedule: Optional[str] = None):
        VolumeSetSnapshots._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            create_final_snapshot=create_final_snapshot,
            retention_duration=retention_duration,
            schedule=schedule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             create_final_snapshot: Optional[bool] = None,
             retention_duration: Optional[str] = None,
             schedule: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'createFinalSnapshot' in kwargs:
            create_final_snapshot = kwargs['createFinalSnapshot']
        if 'retentionDuration' in kwargs:
            retention_duration = kwargs['retentionDuration']

        if create_final_snapshot is not None:
            _setter("create_final_snapshot", create_final_snapshot)
        if retention_duration is not None:
            _setter("retention_duration", retention_duration)
        if schedule is not None:
            _setter("schedule", schedule)

    @property
    @pulumi.getter(name="createFinalSnapshot")
    def create_final_snapshot(self) -> Optional[bool]:
        return pulumi.get(self, "create_final_snapshot")

    @property
    @pulumi.getter(name="retentionDuration")
    def retention_duration(self) -> Optional[str]:
        return pulumi.get(self, "retention_duration")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        return pulumi.get(self, "schedule")


@pulumi.output_type
class VolumeSetStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingId":
            suggest = "binding_id"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "usedByWorkload":
            suggest = "used_by_workload"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VolumeSetStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VolumeSetStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binding_id: Optional[str] = None,
                 locations: Optional[Sequence[str]] = None,
                 parent_id: Optional[str] = None,
                 used_by_workload: Optional[str] = None):
        VolumeSetStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            binding_id=binding_id,
            locations=locations,
            parent_id=parent_id,
            used_by_workload=used_by_workload,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             binding_id: Optional[str] = None,
             locations: Optional[Sequence[str]] = None,
             parent_id: Optional[str] = None,
             used_by_workload: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'bindingId' in kwargs:
            binding_id = kwargs['bindingId']
        if 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if 'usedByWorkload' in kwargs:
            used_by_workload = kwargs['usedByWorkload']

        if binding_id is not None:
            _setter("binding_id", binding_id)
        if locations is not None:
            _setter("locations", locations)
        if parent_id is not None:
            _setter("parent_id", parent_id)
        if used_by_workload is not None:
            _setter("used_by_workload", used_by_workload)

    @property
    @pulumi.getter(name="bindingId")
    def binding_id(self) -> Optional[str]:
        return pulumi.get(self, "binding_id")

    @property
    @pulumi.getter
    def locations(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "locations")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="usedByWorkload")
    def used_by_workload(self) -> Optional[str]:
        return pulumi.get(self, "used_by_workload")


@pulumi.output_type
class WorkloadContainer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gpuNvidia":
            suggest = "gpu_nvidia"
        elif key == "inheritEnv":
            suggest = "inherit_env"
        elif key == "livenessProbe":
            suggest = "liveness_probe"
        elif key == "minCpu":
            suggest = "min_cpu"
        elif key == "minMemory":
            suggest = "min_memory"
        elif key == "readinessProbe":
            suggest = "readiness_probe"
        elif key == "workingDirectory":
            suggest = "working_directory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: str,
                 name: str,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[str] = None,
                 cpu: Optional[str] = None,
                 env: Optional[Mapping[str, str]] = None,
                 gpu_nvidia: Optional['outputs.WorkloadContainerGpuNvidia'] = None,
                 inherit_env: Optional[bool] = None,
                 lifecycle: Optional['outputs.WorkloadContainerLifecycle'] = None,
                 liveness_probe: Optional['outputs.WorkloadContainerLivenessProbe'] = None,
                 memory: Optional[str] = None,
                 metrics: Optional['outputs.WorkloadContainerMetrics'] = None,
                 min_cpu: Optional[str] = None,
                 min_memory: Optional[str] = None,
                 port: Optional[int] = None,
                 ports: Optional[Sequence['outputs.WorkloadContainerPort']] = None,
                 readiness_probe: Optional['outputs.WorkloadContainerReadinessProbe'] = None,
                 volumes: Optional[Sequence['outputs.WorkloadContainerVolume']] = None,
                 working_directory: Optional[str] = None):
        WorkloadContainer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image=image,
            name=name,
            args=args,
            command=command,
            cpu=cpu,
            env=env,
            gpu_nvidia=gpu_nvidia,
            inherit_env=inherit_env,
            lifecycle=lifecycle,
            liveness_probe=liveness_probe,
            memory=memory,
            metrics=metrics,
            min_cpu=min_cpu,
            min_memory=min_memory,
            port=port,
            ports=ports,
            readiness_probe=readiness_probe,
            volumes=volumes,
            working_directory=working_directory,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image: str,
             name: str,
             args: Optional[Sequence[str]] = None,
             command: Optional[str] = None,
             cpu: Optional[str] = None,
             env: Optional[Mapping[str, str]] = None,
             gpu_nvidia: Optional['outputs.WorkloadContainerGpuNvidia'] = None,
             inherit_env: Optional[bool] = None,
             lifecycle: Optional['outputs.WorkloadContainerLifecycle'] = None,
             liveness_probe: Optional['outputs.WorkloadContainerLivenessProbe'] = None,
             memory: Optional[str] = None,
             metrics: Optional['outputs.WorkloadContainerMetrics'] = None,
             min_cpu: Optional[str] = None,
             min_memory: Optional[str] = None,
             port: Optional[int] = None,
             ports: Optional[Sequence['outputs.WorkloadContainerPort']] = None,
             readiness_probe: Optional['outputs.WorkloadContainerReadinessProbe'] = None,
             volumes: Optional[Sequence['outputs.WorkloadContainerVolume']] = None,
             working_directory: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'gpuNvidia' in kwargs:
            gpu_nvidia = kwargs['gpuNvidia']
        if 'inheritEnv' in kwargs:
            inherit_env = kwargs['inheritEnv']
        if 'livenessProbe' in kwargs:
            liveness_probe = kwargs['livenessProbe']
        if 'minCpu' in kwargs:
            min_cpu = kwargs['minCpu']
        if 'minMemory' in kwargs:
            min_memory = kwargs['minMemory']
        if 'readinessProbe' in kwargs:
            readiness_probe = kwargs['readinessProbe']
        if 'workingDirectory' in kwargs:
            working_directory = kwargs['workingDirectory']

        _setter("image", image)
        _setter("name", name)
        if args is not None:
            _setter("args", args)
        if command is not None:
            _setter("command", command)
        if cpu is not None:
            _setter("cpu", cpu)
        if env is not None:
            _setter("env", env)
        if gpu_nvidia is not None:
            _setter("gpu_nvidia", gpu_nvidia)
        if inherit_env is not None:
            _setter("inherit_env", inherit_env)
        if lifecycle is not None:
            _setter("lifecycle", lifecycle)
        if liveness_probe is not None:
            _setter("liveness_probe", liveness_probe)
        if memory is not None:
            _setter("memory", memory)
        if metrics is not None:
            _setter("metrics", metrics)
        if min_cpu is not None:
            _setter("min_cpu", min_cpu)
        if min_memory is not None:
            _setter("min_memory", min_memory)
        if port is not None:
            _setter("port", port)
        if ports is not None:
            _setter("ports", ports)
        if readiness_probe is not None:
            _setter("readiness_probe", readiness_probe)
        if volumes is not None:
            _setter("volumes", volumes)
        if working_directory is not None:
            _setter("working_directory", working_directory)

    @property
    @pulumi.getter
    def image(self) -> str:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[str]:
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def cpu(self) -> Optional[str]:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="gpuNvidia")
    def gpu_nvidia(self) -> Optional['outputs.WorkloadContainerGpuNvidia']:
        return pulumi.get(self, "gpu_nvidia")

    @property
    @pulumi.getter(name="inheritEnv")
    def inherit_env(self) -> Optional[bool]:
        return pulumi.get(self, "inherit_env")

    @property
    @pulumi.getter
    def lifecycle(self) -> Optional['outputs.WorkloadContainerLifecycle']:
        return pulumi.get(self, "lifecycle")

    @property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional['outputs.WorkloadContainerLivenessProbe']:
        return pulumi.get(self, "liveness_probe")

    @property
    @pulumi.getter
    def memory(self) -> Optional[str]:
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def metrics(self) -> Optional['outputs.WorkloadContainerMetrics']:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[str]:
        return pulumi.get(self, "min_cpu")

    @property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[str]:
        return pulumi.get(self, "min_memory")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        warnings.warn("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""", DeprecationWarning)
        pulumi.log.warn("""port is deprecated: The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")

        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.WorkloadContainerPort']]:
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional['outputs.WorkloadContainerReadinessProbe']:
        return pulumi.get(self, "readiness_probe")

    @property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['outputs.WorkloadContainerVolume']]:
        return pulumi.get(self, "volumes")

    @property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[str]:
        return pulumi.get(self, "working_directory")


@pulumi.output_type
class WorkloadContainerGpuNvidia(dict):
    def __init__(__self__, *,
                 model: str,
                 quantity: int):
        WorkloadContainerGpuNvidia._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            model=model,
            quantity=quantity,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             model: str,
             quantity: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("model", model)
        _setter("quantity", quantity)

    @property
    @pulumi.getter
    def model(self) -> str:
        return pulumi.get(self, "model")

    @property
    @pulumi.getter
    def quantity(self) -> int:
        return pulumi.get(self, "quantity")


@pulumi.output_type
class WorkloadContainerLifecycle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postStart":
            suggest = "post_start"
        elif key == "preStop":
            suggest = "pre_stop"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecycle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecycle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 post_start: Optional['outputs.WorkloadContainerLifecyclePostStart'] = None,
                 pre_stop: Optional['outputs.WorkloadContainerLifecyclePreStop'] = None):
        WorkloadContainerLifecycle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            post_start=post_start,
            pre_stop=pre_stop,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             post_start: Optional['outputs.WorkloadContainerLifecyclePostStart'] = None,
             pre_stop: Optional['outputs.WorkloadContainerLifecyclePreStop'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'postStart' in kwargs:
            post_start = kwargs['postStart']
        if 'preStop' in kwargs:
            pre_stop = kwargs['preStop']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if post_start is not None:
            _setter("post_start", post_start)
        if pre_stop is not None:
            _setter("pre_stop", pre_stop)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional['outputs.WorkloadContainerLifecyclePostStart']:
        return pulumi.get(self, "post_start")

    @property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional['outputs.WorkloadContainerLifecyclePreStop']:
        return pulumi.get(self, "pre_stop")


@pulumi.output_type
class WorkloadContainerLifecyclePostStart(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePostStart. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePostStart.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePostStartExec'):
        WorkloadContainerLifecyclePostStart._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: 'outputs.WorkloadContainerLifecyclePostStartExec',
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePostStartExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePostStartExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLifecyclePostStartExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLifecyclePreStop(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLifecyclePreStop. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLifecyclePreStop.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: 'outputs.WorkloadContainerLifecyclePreStopExec'):
        WorkloadContainerLifecyclePreStop._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: 'outputs.WorkloadContainerLifecyclePreStopExec',
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']

        _setter("exec_", exec_)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> 'outputs.WorkloadContainerLifecyclePreStopExec':
        return pulumi.get(self, "exec_")


@pulumi.output_type
class WorkloadContainerLifecyclePreStopExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLifecyclePreStopExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerLivenessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerLivenessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerLivenessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerLivenessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadContainerLivenessProbe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.WorkloadContainerLivenessProbeExec'] = None,
             failure_threshold: Optional[int] = None,
             grpc: Optional['outputs.WorkloadContainerLivenessProbeGrpc'] = None,
             http_get: Optional['outputs.WorkloadContainerLivenessProbeHttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             success_threshold: Optional[int] = None,
             tcp_socket: Optional['outputs.WorkloadContainerLivenessProbeTcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if grpc is not None:
            _setter("grpc", grpc)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerLivenessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerLivenessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerLivenessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerLivenessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerLivenessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerLivenessProbeExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerLivenessProbeGrpc(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 port: Optional[int] = None):
        WorkloadContainerLivenessProbeGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerLivenessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerLivenessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerLivenessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        WorkloadContainerLivenessProbeHttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_headers=http_headers,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_headers: Optional[Mapping[str, str]] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        if http_headers is not None:
            _setter("http_headers", http_headers)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerLivenessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 port: Optional[int] = None):
        WorkloadContainerLivenessProbeTcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerMetrics(dict):
    def __init__(__self__, *,
                 path: str,
                 port: int):
        WorkloadContainerMetrics._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             port: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("path", path)
        _setter("port", port)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> int:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: Optional[str] = None):
        WorkloadContainerPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number: int,
             protocol: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("number", number)
        if protocol is not None:
            _setter("protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadContainerReadinessProbe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exec":
            suggest = "exec_"
        elif key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpGet":
            suggest = "http_get"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "tcpSocket":
            suggest = "tcp_socket"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exec_: Optional['outputs.WorkloadContainerReadinessProbeExec'] = None,
                 failure_threshold: Optional[int] = None,
                 grpc: Optional['outputs.WorkloadContainerReadinessProbeGrpc'] = None,
                 http_get: Optional['outputs.WorkloadContainerReadinessProbeHttpGet'] = None,
                 initial_delay_seconds: Optional[int] = None,
                 period_seconds: Optional[int] = None,
                 success_threshold: Optional[int] = None,
                 tcp_socket: Optional['outputs.WorkloadContainerReadinessProbeTcpSocket'] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadContainerReadinessProbe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            exec_=exec_,
            failure_threshold=failure_threshold,
            grpc=grpc,
            http_get=http_get,
            initial_delay_seconds=initial_delay_seconds,
            period_seconds=period_seconds,
            success_threshold=success_threshold,
            tcp_socket=tcp_socket,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             exec_: Optional['outputs.WorkloadContainerReadinessProbeExec'] = None,
             failure_threshold: Optional[int] = None,
             grpc: Optional['outputs.WorkloadContainerReadinessProbeGrpc'] = None,
             http_get: Optional['outputs.WorkloadContainerReadinessProbeHttpGet'] = None,
             initial_delay_seconds: Optional[int] = None,
             period_seconds: Optional[int] = None,
             success_threshold: Optional[int] = None,
             tcp_socket: Optional['outputs.WorkloadContainerReadinessProbeTcpSocket'] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'exec' in kwargs:
            exec_ = kwargs['exec']
        if 'failureThreshold' in kwargs:
            failure_threshold = kwargs['failureThreshold']
        if 'httpGet' in kwargs:
            http_get = kwargs['httpGet']
        if 'initialDelaySeconds' in kwargs:
            initial_delay_seconds = kwargs['initialDelaySeconds']
        if 'periodSeconds' in kwargs:
            period_seconds = kwargs['periodSeconds']
        if 'successThreshold' in kwargs:
            success_threshold = kwargs['successThreshold']
        if 'tcpSocket' in kwargs:
            tcp_socket = kwargs['tcpSocket']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if exec_ is not None:
            _setter("exec_", exec_)
        if failure_threshold is not None:
            _setter("failure_threshold", failure_threshold)
        if grpc is not None:
            _setter("grpc", grpc)
        if http_get is not None:
            _setter("http_get", http_get)
        if initial_delay_seconds is not None:
            _setter("initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            _setter("period_seconds", period_seconds)
        if success_threshold is not None:
            _setter("success_threshold", success_threshold)
        if tcp_socket is not None:
            _setter("tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional['outputs.WorkloadContainerReadinessProbeExec']:
        return pulumi.get(self, "exec_")

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[int]:
        return pulumi.get(self, "failure_threshold")

    @property
    @pulumi.getter
    def grpc(self) -> Optional['outputs.WorkloadContainerReadinessProbeGrpc']:
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional['outputs.WorkloadContainerReadinessProbeHttpGet']:
        return pulumi.get(self, "http_get")

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[int]:
        return pulumi.get(self, "initial_delay_seconds")

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[int]:
        return pulumi.get(self, "period_seconds")

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[int]:
        return pulumi.get(self, "success_threshold")

    @property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional['outputs.WorkloadContainerReadinessProbeTcpSocket']:
        return pulumi.get(self, "tcp_socket")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadContainerReadinessProbeExec(dict):
    def __init__(__self__, *,
                 commands: Sequence[str]):
        WorkloadContainerReadinessProbeExec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            commands=commands,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             commands: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("commands", commands)

    @property
    @pulumi.getter
    def commands(self) -> Sequence[str]:
        return pulumi.get(self, "commands")


@pulumi.output_type
class WorkloadContainerReadinessProbeGrpc(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 port: Optional[int] = None):
        WorkloadContainerReadinessProbeGrpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerReadinessProbeHttpGet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "httpHeaders":
            suggest = "http_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerReadinessProbeHttpGet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerReadinessProbeHttpGet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 http_headers: Optional[Mapping[str, str]] = None,
                 path: Optional[str] = None,
                 port: Optional[int] = None,
                 scheme: Optional[str] = None):
        WorkloadContainerReadinessProbeHttpGet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            http_headers=http_headers,
            path=path,
            port=port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             http_headers: Optional[Mapping[str, str]] = None,
             path: Optional[str] = None,
             port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'httpHeaders' in kwargs:
            http_headers = kwargs['httpHeaders']

        if http_headers is not None:
            _setter("http_headers", http_headers)
        if path is not None:
            _setter("path", path)
        if port is not None:
            _setter("port", port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "http_headers")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadContainerReadinessProbeTcpSocket(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 port: Optional[int] = None):
        WorkloadContainerReadinessProbeTcpSocket._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            port=port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if port is not None:
            _setter("port", port)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")


@pulumi.output_type
class WorkloadContainerVolume(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryPolicy":
            suggest = "recovery_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadContainerVolume. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadContainerVolume.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 uri: str,
                 recovery_policy: Optional[str] = None):
        WorkloadContainerVolume._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            uri=uri,
            recovery_policy=recovery_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             uri: str,
             recovery_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'recoveryPolicy' in kwargs:
            recovery_policy = kwargs['recoveryPolicy']

        _setter("path", path)
        _setter("uri", uri)
        if recovery_policy is not None:
            _setter("recovery_policy", recovery_policy)

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def uri(self) -> str:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> Optional[str]:
        return pulumi.get(self, "recovery_policy")


@pulumi.output_type
class WorkloadFirewallSpec(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 external: Optional['outputs.WorkloadFirewallSpecExternal'] = None,
                 internal: Optional['outputs.WorkloadFirewallSpecInternal'] = None):
        WorkloadFirewallSpec._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            external=external,
            internal=internal,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             external: Optional['outputs.WorkloadFirewallSpecExternal'] = None,
             internal: Optional['outputs.WorkloadFirewallSpecInternal'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if external is not None:
            _setter("external", external)
        if internal is not None:
            _setter("internal", internal)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def external(self) -> Optional['outputs.WorkloadFirewallSpecExternal']:
        return pulumi.get(self, "external")

    @property
    @pulumi.getter
    def internal(self) -> Optional['outputs.WorkloadFirewallSpecInternal']:
        return pulumi.get(self, "internal")


@pulumi.output_type
class WorkloadFirewallSpecExternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowCidrs":
            suggest = "inbound_allow_cidrs"
        elif key == "outboundAllowCidrs":
            suggest = "outbound_allow_cidrs"
        elif key == "outboundAllowHostnames":
            suggest = "outbound_allow_hostnames"
        elif key == "outboundAllowPorts":
            suggest = "outbound_allow_ports"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecExternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecExternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_cidrs: Optional[Sequence[str]] = None,
                 outbound_allow_hostnames: Optional[Sequence[str]] = None,
                 outbound_allow_ports: Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']] = None):
        WorkloadFirewallSpecExternal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inbound_allow_cidrs=inbound_allow_cidrs,
            outbound_allow_cidrs=outbound_allow_cidrs,
            outbound_allow_hostnames=outbound_allow_hostnames,
            outbound_allow_ports=outbound_allow_ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inbound_allow_cidrs: Optional[Sequence[str]] = None,
             outbound_allow_cidrs: Optional[Sequence[str]] = None,
             outbound_allow_hostnames: Optional[Sequence[str]] = None,
             outbound_allow_ports: Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'inboundAllowCidrs' in kwargs:
            inbound_allow_cidrs = kwargs['inboundAllowCidrs']
        if 'outboundAllowCidrs' in kwargs:
            outbound_allow_cidrs = kwargs['outboundAllowCidrs']
        if 'outboundAllowHostnames' in kwargs:
            outbound_allow_hostnames = kwargs['outboundAllowHostnames']
        if 'outboundAllowPorts' in kwargs:
            outbound_allow_ports = kwargs['outboundAllowPorts']

        if inbound_allow_cidrs is not None:
            _setter("inbound_allow_cidrs", inbound_allow_cidrs)
        if outbound_allow_cidrs is not None:
            _setter("outbound_allow_cidrs", outbound_allow_cidrs)
        if outbound_allow_hostnames is not None:
            _setter("outbound_allow_hostnames", outbound_allow_hostnames)
        if outbound_allow_ports is not None:
            _setter("outbound_allow_ports", outbound_allow_ports)

    @property
    @pulumi.getter(name="inboundAllowCidrs")
    def inbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "inbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowCidrs")
    def outbound_allow_cidrs(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "outbound_allow_cidrs")

    @property
    @pulumi.getter(name="outboundAllowHostnames")
    def outbound_allow_hostnames(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "outbound_allow_hostnames")

    @property
    @pulumi.getter(name="outboundAllowPorts")
    def outbound_allow_ports(self) -> Optional[Sequence['outputs.WorkloadFirewallSpecExternalOutboundAllowPort']]:
        return pulumi.get(self, "outbound_allow_ports")


@pulumi.output_type
class WorkloadFirewallSpecExternalOutboundAllowPort(dict):
    def __init__(__self__, *,
                 number: int,
                 protocol: str):
        WorkloadFirewallSpecExternalOutboundAllowPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            number=number,
            protocol=protocol,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             number: int,
             protocol: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("number", number)
        _setter("protocol", protocol)

    @property
    @pulumi.getter
    def number(self) -> int:
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")


@pulumi.output_type
class WorkloadFirewallSpecInternal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inboundAllowType":
            suggest = "inbound_allow_type"
        elif key == "inboundAllowWorkloads":
            suggest = "inbound_allow_workloads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadFirewallSpecInternal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadFirewallSpecInternal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inbound_allow_type: Optional[str] = None,
                 inbound_allow_workloads: Optional[Sequence[str]] = None):
        WorkloadFirewallSpecInternal._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            inbound_allow_type=inbound_allow_type,
            inbound_allow_workloads=inbound_allow_workloads,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             inbound_allow_type: Optional[str] = None,
             inbound_allow_workloads: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'inboundAllowType' in kwargs:
            inbound_allow_type = kwargs['inboundAllowType']
        if 'inboundAllowWorkloads' in kwargs:
            inbound_allow_workloads = kwargs['inboundAllowWorkloads']

        if inbound_allow_type is not None:
            _setter("inbound_allow_type", inbound_allow_type)
        if inbound_allow_workloads is not None:
            _setter("inbound_allow_workloads", inbound_allow_workloads)

    @property
    @pulumi.getter(name="inboundAllowType")
    def inbound_allow_type(self) -> Optional[str]:
        return pulumi.get(self, "inbound_allow_type")

    @property
    @pulumi.getter(name="inboundAllowWorkloads")
    def inbound_allow_workloads(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "inbound_allow_workloads")


@pulumi.output_type
class WorkloadJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeDeadlineSeconds":
            suggest = "active_deadline_seconds"
        elif key == "concurrencyPolicy":
            suggest = "concurrency_policy"
        elif key == "historyLimit":
            suggest = "history_limit"
        elif key == "restartPolicy":
            suggest = "restart_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schedule: str,
                 active_deadline_seconds: Optional[int] = None,
                 concurrency_policy: Optional[str] = None,
                 history_limit: Optional[int] = None,
                 restart_policy: Optional[str] = None):
        WorkloadJob._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            schedule=schedule,
            active_deadline_seconds=active_deadline_seconds,
            concurrency_policy=concurrency_policy,
            history_limit=history_limit,
            restart_policy=restart_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             schedule: str,
             active_deadline_seconds: Optional[int] = None,
             concurrency_policy: Optional[str] = None,
             history_limit: Optional[int] = None,
             restart_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'activeDeadlineSeconds' in kwargs:
            active_deadline_seconds = kwargs['activeDeadlineSeconds']
        if 'concurrencyPolicy' in kwargs:
            concurrency_policy = kwargs['concurrencyPolicy']
        if 'historyLimit' in kwargs:
            history_limit = kwargs['historyLimit']
        if 'restartPolicy' in kwargs:
            restart_policy = kwargs['restartPolicy']

        _setter("schedule", schedule)
        if active_deadline_seconds is not None:
            _setter("active_deadline_seconds", active_deadline_seconds)
        if concurrency_policy is not None:
            _setter("concurrency_policy", concurrency_policy)
        if history_limit is not None:
            _setter("history_limit", history_limit)
        if restart_policy is not None:
            _setter("restart_policy", restart_policy)

    @property
    @pulumi.getter
    def schedule(self) -> str:
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[int]:
        return pulumi.get(self, "active_deadline_seconds")

    @property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[str]:
        return pulumi.get(self, "concurrency_policy")

    @property
    @pulumi.getter(name="historyLimit")
    def history_limit(self) -> Optional[int]:
        return pulumi.get(self, "history_limit")

    @property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[str]:
        return pulumi.get(self, "restart_policy")


@pulumi.output_type
class WorkloadLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "geoLocation":
            suggest = "geo_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 direct: Optional['outputs.WorkloadLoadBalancerDirect'] = None,
                 geo_location: Optional['outputs.WorkloadLoadBalancerGeoLocation'] = None):
        WorkloadLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            direct=direct,
            geo_location=geo_location,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             direct: Optional['outputs.WorkloadLoadBalancerDirect'] = None,
             geo_location: Optional['outputs.WorkloadLoadBalancerGeoLocation'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'geoLocation' in kwargs:
            geo_location = kwargs['geoLocation']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if direct is not None:
            _setter("direct", direct)
        if geo_location is not None:
            _setter("geo_location", geo_location)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def direct(self) -> Optional['outputs.WorkloadLoadBalancerDirect']:
        return pulumi.get(self, "direct")

    @property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional['outputs.WorkloadLoadBalancerGeoLocation']:
        return pulumi.get(self, "geo_location")


@pulumi.output_type
class WorkloadLoadBalancerDirect(dict):
    def __init__(__self__, *,
                 enabled: bool,
                 ports: Optional[Sequence['outputs.WorkloadLoadBalancerDirectPort']] = None):
        WorkloadLoadBalancerDirect._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            ports=ports,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             ports: Optional[Sequence['outputs.WorkloadLoadBalancerDirectPort']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("enabled", enabled)
        if ports is not None:
            _setter("ports", ports)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.WorkloadLoadBalancerDirectPort']]:
        return pulumi.get(self, "ports")


@pulumi.output_type
class WorkloadLoadBalancerDirectPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalPort":
            suggest = "external_port"
        elif key == "containerPort":
            suggest = "container_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLoadBalancerDirectPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLoadBalancerDirectPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLoadBalancerDirectPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_port: int,
                 protocol: str,
                 container_port: Optional[int] = None,
                 scheme: Optional[str] = None):
        WorkloadLoadBalancerDirectPort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            external_port=external_port,
            protocol=protocol,
            container_port=container_port,
            scheme=scheme,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             external_port: int,
             protocol: str,
             container_port: Optional[int] = None,
             scheme: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'externalPort' in kwargs:
            external_port = kwargs['externalPort']
        if 'containerPort' in kwargs:
            container_port = kwargs['containerPort']

        _setter("external_port", external_port)
        _setter("protocol", protocol)
        if container_port is not None:
            _setter("container_port", container_port)
        if scheme is not None:
            _setter("scheme", scheme)

    @property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> int:
        return pulumi.get(self, "external_port")

    @property
    @pulumi.getter
    def protocol(self) -> str:
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[int]:
        return pulumi.get(self, "container_port")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[str]:
        return pulumi.get(self, "scheme")


@pulumi.output_type
class WorkloadLoadBalancerGeoLocation(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 headers: Optional['outputs.WorkloadLoadBalancerGeoLocationHeaders'] = None):
        WorkloadLoadBalancerGeoLocation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             headers: Optional['outputs.WorkloadLoadBalancerGeoLocationHeaders'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if enabled is not None:
            _setter("enabled", enabled)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.WorkloadLoadBalancerGeoLocationHeaders']:
        return pulumi.get(self, "headers")


@pulumi.output_type
class WorkloadLoadBalancerGeoLocationHeaders(dict):
    def __init__(__self__, *,
                 asn: Optional[str] = None,
                 city: Optional[str] = None,
                 country: Optional[str] = None,
                 region: Optional[str] = None):
        WorkloadLoadBalancerGeoLocationHeaders._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asn=asn,
            city=city,
            country=country,
            region=region,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asn: Optional[str] = None,
             city: Optional[str] = None,
             country: Optional[str] = None,
             region: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if asn is not None:
            _setter("asn", asn)
        if city is not None:
            _setter("city", city)
        if country is not None:
            _setter("country", country)
        if region is not None:
            _setter("region", region)

    @property
    @pulumi.getter
    def asn(self) -> Optional[str]:
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")


@pulumi.output_type
class WorkloadLocalOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 autoscaling: Optional['outputs.WorkloadLocalOptionAutoscaling'] = None,
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadLocalOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            location=location,
            autoscaling=autoscaling,
            capacity_ai=capacity_ai,
            debug=debug,
            suspend=suspend,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             location: str,
             autoscaling: Optional['outputs.WorkloadLocalOptionAutoscaling'] = None,
             capacity_ai: Optional[bool] = None,
             debug: Optional[bool] = None,
             suspend: Optional[bool] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'capacityAi' in kwargs:
            capacity_ai = kwargs['capacityAi']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        _setter("location", location)
        if autoscaling is not None:
            _setter("autoscaling", autoscaling)
        if capacity_ai is not None:
            _setter("capacity_ai", capacity_ai)
        if debug is not None:
            _setter("debug", debug)
        if suspend is not None:
            _setter("suspend", suspend)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def location(self) -> str:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.WorkloadLocalOptionAutoscaling']:
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadLocalOptionAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadLocalOptionAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadLocalOptionAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 multis: Optional[Sequence['outputs.WorkloadLocalOptionAutoscalingMulti']] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        WorkloadLocalOptionAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrency=max_concurrency,
            max_scale=max_scale,
            metric=metric,
            metric_percentile=metric_percentile,
            min_scale=min_scale,
            multis=multis,
            scale_to_zero_delay=scale_to_zero_delay,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrency: Optional[int] = None,
             max_scale: Optional[int] = None,
             metric: Optional[str] = None,
             metric_percentile: Optional[str] = None,
             min_scale: Optional[int] = None,
             multis: Optional[Sequence['outputs.WorkloadLocalOptionAutoscalingMulti']] = None,
             scale_to_zero_delay: Optional[int] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxConcurrency' in kwargs:
            max_concurrency = kwargs['maxConcurrency']
        if 'maxScale' in kwargs:
            max_scale = kwargs['maxScale']
        if 'metricPercentile' in kwargs:
            metric_percentile = kwargs['metricPercentile']
        if 'minScale' in kwargs:
            min_scale = kwargs['minScale']
        if 'scaleToZeroDelay' in kwargs:
            scale_to_zero_delay = kwargs['scaleToZeroDelay']

        if max_concurrency is not None:
            _setter("max_concurrency", max_concurrency)
        if max_scale is not None:
            _setter("max_scale", max_scale)
        if metric is not None:
            _setter("metric", metric)
        if metric_percentile is not None:
            _setter("metric_percentile", metric_percentile)
        if min_scale is not None:
            _setter("min_scale", min_scale)
        if multis is not None:
            _setter("multis", multis)
        if scale_to_zero_delay is not None:
            _setter("scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['outputs.WorkloadLocalOptionAutoscalingMulti']]:
        return pulumi.get(self, "multis")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadLocalOptionAutoscalingMulti(dict):
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 target: Optional[int] = None):
        WorkloadLocalOptionAutoscalingMulti._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[str] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "capacityAi":
            suggest = "capacity_ai"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling: Optional['outputs.WorkloadOptionsAutoscaling'] = None,
                 capacity_ai: Optional[bool] = None,
                 debug: Optional[bool] = None,
                 suspend: Optional[bool] = None,
                 timeout_seconds: Optional[int] = None):
        WorkloadOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscaling=autoscaling,
            capacity_ai=capacity_ai,
            debug=debug,
            suspend=suspend,
            timeout_seconds=timeout_seconds,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscaling: Optional['outputs.WorkloadOptionsAutoscaling'] = None,
             capacity_ai: Optional[bool] = None,
             debug: Optional[bool] = None,
             suspend: Optional[bool] = None,
             timeout_seconds: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'capacityAi' in kwargs:
            capacity_ai = kwargs['capacityAi']
        if 'timeoutSeconds' in kwargs:
            timeout_seconds = kwargs['timeoutSeconds']

        if autoscaling is not None:
            _setter("autoscaling", autoscaling)
        if capacity_ai is not None:
            _setter("capacity_ai", capacity_ai)
        if debug is not None:
            _setter("debug", debug)
        if suspend is not None:
            _setter("suspend", suspend)
        if timeout_seconds is not None:
            _setter("timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.WorkloadOptionsAutoscaling']:
        return pulumi.get(self, "autoscaling")

    @property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[bool]:
        return pulumi.get(self, "capacity_ai")

    @property
    @pulumi.getter
    def debug(self) -> Optional[bool]:
        return pulumi.get(self, "debug")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[bool]:
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[int]:
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class WorkloadOptionsAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrency":
            suggest = "max_concurrency"
        elif key == "maxScale":
            suggest = "max_scale"
        elif key == "metricPercentile":
            suggest = "metric_percentile"
        elif key == "minScale":
            suggest = "min_scale"
        elif key == "scaleToZeroDelay":
            suggest = "scale_to_zero_delay"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadOptionsAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadOptionsAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_concurrency: Optional[int] = None,
                 max_scale: Optional[int] = None,
                 metric: Optional[str] = None,
                 metric_percentile: Optional[str] = None,
                 min_scale: Optional[int] = None,
                 multis: Optional[Sequence['outputs.WorkloadOptionsAutoscalingMulti']] = None,
                 scale_to_zero_delay: Optional[int] = None,
                 target: Optional[int] = None):
        WorkloadOptionsAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_concurrency=max_concurrency,
            max_scale=max_scale,
            metric=metric,
            metric_percentile=metric_percentile,
            min_scale=min_scale,
            multis=multis,
            scale_to_zero_delay=scale_to_zero_delay,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_concurrency: Optional[int] = None,
             max_scale: Optional[int] = None,
             metric: Optional[str] = None,
             metric_percentile: Optional[str] = None,
             min_scale: Optional[int] = None,
             multis: Optional[Sequence['outputs.WorkloadOptionsAutoscalingMulti']] = None,
             scale_to_zero_delay: Optional[int] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxConcurrency' in kwargs:
            max_concurrency = kwargs['maxConcurrency']
        if 'maxScale' in kwargs:
            max_scale = kwargs['maxScale']
        if 'metricPercentile' in kwargs:
            metric_percentile = kwargs['metricPercentile']
        if 'minScale' in kwargs:
            min_scale = kwargs['minScale']
        if 'scaleToZeroDelay' in kwargs:
            scale_to_zero_delay = kwargs['scaleToZeroDelay']

        if max_concurrency is not None:
            _setter("max_concurrency", max_concurrency)
        if max_scale is not None:
            _setter("max_scale", max_scale)
        if metric is not None:
            _setter("metric", metric)
        if metric_percentile is not None:
            _setter("metric_percentile", metric_percentile)
        if min_scale is not None:
            _setter("min_scale", min_scale)
        if multis is not None:
            _setter("multis", multis)
        if scale_to_zero_delay is not None:
            _setter("scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[int]:
        return pulumi.get(self, "max_concurrency")

    @property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[int]:
        return pulumi.get(self, "max_scale")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[str]:
        return pulumi.get(self, "metric_percentile")

    @property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[int]:
        return pulumi.get(self, "min_scale")

    @property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['outputs.WorkloadOptionsAutoscalingMulti']]:
        return pulumi.get(self, "multis")

    @property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[int]:
        return pulumi.get(self, "scale_to_zero_delay")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadOptionsAutoscalingMulti(dict):
    def __init__(__self__, *,
                 metric: Optional[str] = None,
                 target: Optional[int] = None):
        WorkloadOptionsAutoscalingMulti._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            target=target,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: Optional[str] = None,
             target: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if metric is not None:
            _setter("metric", metric)
        if target is not None:
            _setter("target", target)

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def target(self) -> Optional[int]:
        return pulumi.get(self, "target")


@pulumi.output_type
class WorkloadRolloutOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxSurgeReplicas":
            suggest = "max_surge_replicas"
        elif key == "maxUnavailableReplicas":
            suggest = "max_unavailable_replicas"
        elif key == "minReadySeconds":
            suggest = "min_ready_seconds"
        elif key == "scalingPolicy":
            suggest = "scaling_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadRolloutOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadRolloutOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_surge_replicas: Optional[str] = None,
                 max_unavailable_replicas: Optional[str] = None,
                 min_ready_seconds: Optional[int] = None,
                 scaling_policy: Optional[str] = None):
        WorkloadRolloutOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_surge_replicas=max_surge_replicas,
            max_unavailable_replicas=max_unavailable_replicas,
            min_ready_seconds=min_ready_seconds,
            scaling_policy=scaling_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_surge_replicas: Optional[str] = None,
             max_unavailable_replicas: Optional[str] = None,
             min_ready_seconds: Optional[int] = None,
             scaling_policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'maxSurgeReplicas' in kwargs:
            max_surge_replicas = kwargs['maxSurgeReplicas']
        if 'maxUnavailableReplicas' in kwargs:
            max_unavailable_replicas = kwargs['maxUnavailableReplicas']
        if 'minReadySeconds' in kwargs:
            min_ready_seconds = kwargs['minReadySeconds']
        if 'scalingPolicy' in kwargs:
            scaling_policy = kwargs['scalingPolicy']

        if max_surge_replicas is not None:
            _setter("max_surge_replicas", max_surge_replicas)
        if max_unavailable_replicas is not None:
            _setter("max_unavailable_replicas", max_unavailable_replicas)
        if min_ready_seconds is not None:
            _setter("min_ready_seconds", min_ready_seconds)
        if scaling_policy is not None:
            _setter("scaling_policy", scaling_policy)

    @property
    @pulumi.getter(name="maxSurgeReplicas")
    def max_surge_replicas(self) -> Optional[str]:
        return pulumi.get(self, "max_surge_replicas")

    @property
    @pulumi.getter(name="maxUnavailableReplicas")
    def max_unavailable_replicas(self) -> Optional[str]:
        return pulumi.get(self, "max_unavailable_replicas")

    @property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[int]:
        return pulumi.get(self, "min_ready_seconds")

    @property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[str]:
        return pulumi.get(self, "scaling_policy")


@pulumi.output_type
class WorkloadSecurityOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileSystemGroupId":
            suggest = "file_system_group_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadSecurityOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadSecurityOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 file_system_group_id: Optional[int] = None):
        WorkloadSecurityOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            file_system_group_id=file_system_group_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             file_system_group_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'fileSystemGroupId' in kwargs:
            file_system_group_id = kwargs['fileSystemGroupId']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if file_system_group_id is not None:
            _setter("file_system_group_id", file_system_group_id)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="fileSystemGroupId")
    def file_system_group_id(self) -> Optional[int]:
        return pulumi.get(self, "file_system_group_id")


@pulumi.output_type
class WorkloadSidecar(dict):
    def __init__(__self__, *,
                 envoy: str):
        WorkloadSidecar._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class WorkloadStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "canonicalEndpoint":
            suggest = "canonical_endpoint"
        elif key == "currentReplicaCount":
            suggest = "current_replica_count"
        elif key == "healthChecks":
            suggest = "health_checks"
        elif key == "internalName":
            suggest = "internal_name"
        elif key == "loadBalancers":
            suggest = "load_balancers"
        elif key == "parentId":
            suggest = "parent_id"
        elif key == "resolvedImages":
            suggest = "resolved_images"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 canonical_endpoint: Optional[str] = None,
                 current_replica_count: Optional[int] = None,
                 endpoint: Optional[str] = None,
                 health_checks: Optional[Sequence['outputs.WorkloadStatusHealthCheck']] = None,
                 internal_name: Optional[str] = None,
                 load_balancers: Optional[Sequence['outputs.WorkloadStatusLoadBalancer']] = None,
                 parent_id: Optional[str] = None,
                 resolved_images: Optional[Sequence['outputs.WorkloadStatusResolvedImage']] = None):
        WorkloadStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            canonical_endpoint=canonical_endpoint,
            current_replica_count=current_replica_count,
            endpoint=endpoint,
            health_checks=health_checks,
            internal_name=internal_name,
            load_balancers=load_balancers,
            parent_id=parent_id,
            resolved_images=resolved_images,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             canonical_endpoint: Optional[str] = None,
             current_replica_count: Optional[int] = None,
             endpoint: Optional[str] = None,
             health_checks: Optional[Sequence['outputs.WorkloadStatusHealthCheck']] = None,
             internal_name: Optional[str] = None,
             load_balancers: Optional[Sequence['outputs.WorkloadStatusLoadBalancer']] = None,
             parent_id: Optional[str] = None,
             resolved_images: Optional[Sequence['outputs.WorkloadStatusResolvedImage']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'canonicalEndpoint' in kwargs:
            canonical_endpoint = kwargs['canonicalEndpoint']
        if 'currentReplicaCount' in kwargs:
            current_replica_count = kwargs['currentReplicaCount']
        if 'healthChecks' in kwargs:
            health_checks = kwargs['healthChecks']
        if 'internalName' in kwargs:
            internal_name = kwargs['internalName']
        if 'loadBalancers' in kwargs:
            load_balancers = kwargs['loadBalancers']
        if 'parentId' in kwargs:
            parent_id = kwargs['parentId']
        if 'resolvedImages' in kwargs:
            resolved_images = kwargs['resolvedImages']

        if canonical_endpoint is not None:
            _setter("canonical_endpoint", canonical_endpoint)
        if current_replica_count is not None:
            _setter("current_replica_count", current_replica_count)
        if endpoint is not None:
            _setter("endpoint", endpoint)
        if health_checks is not None:
            _setter("health_checks", health_checks)
        if internal_name is not None:
            _setter("internal_name", internal_name)
        if load_balancers is not None:
            _setter("load_balancers", load_balancers)
        if parent_id is not None:
            _setter("parent_id", parent_id)
        if resolved_images is not None:
            _setter("resolved_images", resolved_images)

    @property
    @pulumi.getter(name="canonicalEndpoint")
    def canonical_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "canonical_endpoint")

    @property
    @pulumi.getter(name="currentReplicaCount")
    def current_replica_count(self) -> Optional[int]:
        return pulumi.get(self, "current_replica_count")

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[str]:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[Sequence['outputs.WorkloadStatusHealthCheck']]:
        return pulumi.get(self, "health_checks")

    @property
    @pulumi.getter(name="internalName")
    def internal_name(self) -> Optional[str]:
        return pulumi.get(self, "internal_name")

    @property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[Sequence['outputs.WorkloadStatusLoadBalancer']]:
        return pulumi.get(self, "load_balancers")

    @property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[str]:
        return pulumi.get(self, "parent_id")

    @property
    @pulumi.getter(name="resolvedImages")
    def resolved_images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImage']]:
        return pulumi.get(self, "resolved_images")


@pulumi.output_type
class WorkloadStatusHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastChecked":
            suggest = "last_checked"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active: bool,
                 code: Optional[int] = None,
                 failures: Optional[int] = None,
                 last_checked: Optional[str] = None,
                 message: Optional[str] = None,
                 success: Optional[bool] = None,
                 successes: Optional[int] = None):
        WorkloadStatusHealthCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active=active,
            code=code,
            failures=failures,
            last_checked=last_checked,
            message=message,
            success=success,
            successes=successes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active: bool,
             code: Optional[int] = None,
             failures: Optional[int] = None,
             last_checked: Optional[str] = None,
             message: Optional[str] = None,
             success: Optional[bool] = None,
             successes: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'lastChecked' in kwargs:
            last_checked = kwargs['lastChecked']

        _setter("active", active)
        if code is not None:
            _setter("code", code)
        if failures is not None:
            _setter("failures", failures)
        if last_checked is not None:
            _setter("last_checked", last_checked)
        if message is not None:
            _setter("message", message)
        if success is not None:
            _setter("success", success)
        if successes is not None:
            _setter("successes", successes)

    @property
    @pulumi.getter
    def active(self) -> bool:
        return pulumi.get(self, "active")

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def failures(self) -> Optional[int]:
        return pulumi.get(self, "failures")

    @property
    @pulumi.getter(name="lastChecked")
    def last_checked(self) -> Optional[str]:
        return pulumi.get(self, "last_checked")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def success(self) -> Optional[bool]:
        return pulumi.get(self, "success")

    @property
    @pulumi.getter
    def successes(self) -> Optional[int]:
        return pulumi.get(self, "successes")


@pulumi.output_type
class WorkloadStatusLoadBalancer(dict):
    def __init__(__self__, *,
                 origin: Optional[str] = None,
                 url: Optional[str] = None):
        WorkloadStatusLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            origin=origin,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             origin: Optional[str] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if origin is not None:
            _setter("origin", origin)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def origin(self) -> Optional[str]:
        return pulumi.get(self, "origin")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class WorkloadStatusResolvedImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolvedAt":
            suggest = "resolved_at"
        elif key == "resolvedForVersion":
            suggest = "resolved_for_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 images: Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']] = None,
                 resolved_at: Optional[str] = None,
                 resolved_for_version: Optional[int] = None):
        WorkloadStatusResolvedImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            images=images,
            resolved_at=resolved_at,
            resolved_for_version=resolved_for_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             images: Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']] = None,
             resolved_at: Optional[str] = None,
             resolved_for_version: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'resolvedAt' in kwargs:
            resolved_at = kwargs['resolvedAt']
        if 'resolvedForVersion' in kwargs:
            resolved_for_version = kwargs['resolvedForVersion']

        if images is not None:
            _setter("images", images)
        if resolved_at is not None:
            _setter("resolved_at", resolved_at)
        if resolved_for_version is not None:
            _setter("resolved_for_version", resolved_for_version)

    @property
    @pulumi.getter
    def images(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImage']]:
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="resolvedAt")
    def resolved_at(self) -> Optional[str]:
        return pulumi.get(self, "resolved_at")

    @property
    @pulumi.getter(name="resolvedForVersion")
    def resolved_for_version(self) -> Optional[int]:
        return pulumi.get(self, "resolved_for_version")


@pulumi.output_type
class WorkloadStatusResolvedImageImage(dict):
    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 manifests: Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']] = None):
        WorkloadStatusResolvedImageImage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            manifests=manifests,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: Optional[str] = None,
             manifests: Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if digest is not None:
            _setter("digest", digest)
        if manifests is not None:
            _setter("manifests", manifests)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def manifests(self) -> Optional[Sequence['outputs.WorkloadStatusResolvedImageImageManifest']]:
        return pulumi.get(self, "manifests")


@pulumi.output_type
class WorkloadStatusResolvedImageImageManifest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mediaType":
            suggest = "media_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadStatusResolvedImageImageManifest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadStatusResolvedImageImageManifest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digest: Optional[str] = None,
                 image: Optional[str] = None,
                 media_type: Optional[str] = None,
                 platform: Optional[Mapping[str, str]] = None):
        WorkloadStatusResolvedImageImageManifest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            image=image,
            media_type=media_type,
            platform=platform,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: Optional[str] = None,
             image: Optional[str] = None,
             media_type: Optional[str] = None,
             platform: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        if digest is not None:
            _setter("digest", digest)
        if image is not None:
            _setter("image", image)
        if media_type is not None:
            _setter("media_type", media_type)
        if platform is not None:
            _setter("platform", platform)

    @property
    @pulumi.getter
    def digest(self) -> Optional[str]:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        return pulumi.get(self, "image")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def platform(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "platform")


@pulumi.output_type
class GetGvcControlplaneTracingResult(dict):
    def __init__(__self__, *,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcControlplaneTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLightstepTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 credentials: Optional[str] = None,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcLightstepTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            credentials=credentials,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             credentials: Optional[str] = None,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if credentials is not None:
            _setter("credentials", credentials)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter
    def credentials(self) -> Optional[str]:
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcLoadBalancerResult(dict):
    def __init__(__self__, *,
                 dedicated: Optional[bool] = None,
                 redirect: Optional['outputs.GetGvcLoadBalancerRedirectResult'] = None,
                 trusted_proxies: Optional[int] = None):
        GetGvcLoadBalancerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dedicated=dedicated,
            redirect=redirect,
            trusted_proxies=trusted_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dedicated: Optional[bool] = None,
             redirect: Optional['outputs.GetGvcLoadBalancerRedirectResult'] = None,
             trusted_proxies: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'trustedProxies' in kwargs:
            trusted_proxies = kwargs['trustedProxies']

        if dedicated is not None:
            _setter("dedicated", dedicated)
        if redirect is not None:
            _setter("redirect", redirect)
        if trusted_proxies is not None:
            _setter("trusted_proxies", trusted_proxies)

    @property
    @pulumi.getter
    def dedicated(self) -> Optional[bool]:
        return pulumi.get(self, "dedicated")

    @property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.GetGvcLoadBalancerRedirectResult']:
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[int]:
        return pulumi.get(self, "trusted_proxies")


@pulumi.output_type
class GetGvcLoadBalancerRedirectResult(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 class_: Optional['outputs.GetGvcLoadBalancerRedirectClassResult'] = None):
        GetGvcLoadBalancerRedirectResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            class_=class_,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             class_: Optional['outputs.GetGvcLoadBalancerRedirectClassResult'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'class' in kwargs:
            class_ = kwargs['class']

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if class_ is not None:
            _setter("class_", class_)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['outputs.GetGvcLoadBalancerRedirectClassResult']:
        return pulumi.get(self, "class_")


@pulumi.output_type
class GetGvcLoadBalancerRedirectClassResult(dict):
    def __init__(__self__, *,
                 _sentinel: Optional[bool] = None,
                 status5xx: Optional[str] = None):
        GetGvcLoadBalancerRedirectClassResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            _sentinel=_sentinel,
            status5xx=status5xx,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             _sentinel: Optional[bool] = None,
             status5xx: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if _sentinel is not None:
            _setter("_sentinel", _sentinel)
        if status5xx is not None:
            _setter("status5xx", status5xx)

    @property
    @pulumi.getter
    def _sentinel(self) -> Optional[bool]:
        return pulumi.get(self, "_sentinel")

    @property
    @pulumi.getter
    def status5xx(self) -> Optional[str]:
        return pulumi.get(self, "status5xx")


@pulumi.output_type
class GetGvcOtelTracingResult(dict):
    def __init__(__self__, *,
                 endpoint: str,
                 sampling: float,
                 custom_tags: Optional[Mapping[str, str]] = None):
        GetGvcOtelTracingResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            endpoint=endpoint,
            sampling=sampling,
            custom_tags=custom_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             endpoint: str,
             sampling: float,
             custom_tags: Optional[Mapping[str, str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'customTags' in kwargs:
            custom_tags = kwargs['customTags']

        _setter("endpoint", endpoint)
        _setter("sampling", sampling)
        if custom_tags is not None:
            _setter("custom_tags", custom_tags)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter
    def sampling(self) -> float:
        return pulumi.get(self, "sampling")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "custom_tags")


@pulumi.output_type
class GetGvcSidecarResult(dict):
    def __init__(__self__, *,
                 envoy: str):
        GetGvcSidecarResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            envoy=envoy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             envoy: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("envoy", envoy)

    @property
    @pulumi.getter
    def envoy(self) -> str:
        return pulumi.get(self, "envoy")


@pulumi.output_type
class GetImageManifestResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetImageManifestConfigResult'],
                 layers: Sequence['outputs.GetImageManifestLayerResult'],
                 media_type: str,
                 schema_version: int):
        GetImageManifestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configs=configs,
            layers=layers,
            media_type=media_type,
            schema_version=schema_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configs: Sequence['outputs.GetImageManifestConfigResult'],
             layers: Sequence['outputs.GetImageManifestLayerResult'],
             media_type: str,
             schema_version: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']
        if 'schemaVersion' in kwargs:
            schema_version = kwargs['schemaVersion']

        _setter("configs", configs)
        _setter("layers", layers)
        _setter("media_type", media_type)
        _setter("schema_version", schema_version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetImageManifestConfigResult']:
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def layers(self) -> Sequence['outputs.GetImageManifestLayerResult']:
        return pulumi.get(self, "layers")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> int:
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class GetImageManifestConfigResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        GetImageManifestConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            media_type=media_type,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: str,
             media_type: str,
             size: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        _setter("digest", digest)
        _setter("media_type", media_type)
        _setter("size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImageManifestLayerResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        GetImageManifestLayerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            media_type=media_type,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: str,
             media_type: str,
             size: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        _setter("digest", digest)
        _setter("media_type", media_type)
        _setter("size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 cpln_id: str,
                 digest: str,
                 manifests: Sequence['outputs.GetImagesImageManifestResult'],
                 name: str,
                 repository: str,
                 self_link: str,
                 tag: str,
                 tags: Mapping[str, str]):
        GetImagesImageResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpln_id=cpln_id,
            digest=digest,
            manifests=manifests,
            name=name,
            repository=repository,
            self_link=self_link,
            tag=tag,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpln_id: str,
             digest: str,
             manifests: Sequence['outputs.GetImagesImageManifestResult'],
             name: str,
             repository: str,
             self_link: str,
             tag: str,
             tags: Mapping[str, str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cplnId' in kwargs:
            cpln_id = kwargs['cplnId']
        if 'selfLink' in kwargs:
            self_link = kwargs['selfLink']

        _setter("cpln_id", cpln_id)
        _setter("digest", digest)
        _setter("manifests", manifests)
        _setter("name", name)
        _setter("repository", repository)
        _setter("self_link", self_link)
        _setter("tag", tag)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="cplnId")
    def cpln_id(self) -> str:
        return pulumi.get(self, "cpln_id")

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter
    def manifests(self) -> Sequence['outputs.GetImagesImageManifestResult']:
        return pulumi.get(self, "manifests")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def repository(self) -> str:
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tag(self) -> str:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetImagesImageManifestResult(dict):
    def __init__(__self__, *,
                 configs: Sequence['outputs.GetImagesImageManifestConfigResult'],
                 layers: Sequence['outputs.GetImagesImageManifestLayerResult'],
                 media_type: str,
                 schema_version: int):
        GetImagesImageManifestResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            configs=configs,
            layers=layers,
            media_type=media_type,
            schema_version=schema_version,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             configs: Sequence['outputs.GetImagesImageManifestConfigResult'],
             layers: Sequence['outputs.GetImagesImageManifestLayerResult'],
             media_type: str,
             schema_version: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']
        if 'schemaVersion' in kwargs:
            schema_version = kwargs['schemaVersion']

        _setter("configs", configs)
        _setter("layers", layers)
        _setter("media_type", media_type)
        _setter("schema_version", schema_version)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GetImagesImageManifestConfigResult']:
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def layers(self) -> Sequence['outputs.GetImagesImageManifestLayerResult']:
        return pulumi.get(self, "layers")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> int:
        return pulumi.get(self, "schema_version")


@pulumi.output_type
class GetImagesImageManifestConfigResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        GetImagesImageManifestConfigResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            media_type=media_type,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: str,
             media_type: str,
             size: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        _setter("digest", digest)
        _setter("media_type", media_type)
        _setter("size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesImageManifestLayerResult(dict):
    def __init__(__self__, *,
                 digest: str,
                 media_type: str,
                 size: int):
        GetImagesImageManifestLayerResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digest=digest,
            media_type=media_type,
            size=size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digest: str,
             media_type: str,
             size: int,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'mediaType' in kwargs:
            media_type = kwargs['mediaType']

        _setter("digest", digest)
        _setter("media_type", media_type)
        _setter("size", size)

    @property
    @pulumi.getter
    def digest(self) -> str:
        return pulumi.get(self, "digest")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> str:
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter
    def size(self) -> int:
        return pulumi.get(self, "size")


@pulumi.output_type
class GetImagesQueryResult(dict):
    def __init__(__self__, *,
                 fetch: Optional[str] = None,
                 spec: Optional['outputs.GetImagesQuerySpecResult'] = None):
        GetImagesQueryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fetch=fetch,
            spec=spec,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fetch: Optional[str] = None,
             spec: Optional['outputs.GetImagesQuerySpecResult'] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if fetch is not None:
            _setter("fetch", fetch)
        if spec is not None:
            _setter("spec", spec)

    @property
    @pulumi.getter
    def fetch(self) -> Optional[str]:
        return pulumi.get(self, "fetch")

    @property
    @pulumi.getter
    def spec(self) -> Optional['outputs.GetImagesQuerySpecResult']:
        return pulumi.get(self, "spec")


@pulumi.output_type
class GetImagesQuerySpecResult(dict):
    def __init__(__self__, *,
                 match: Optional[str] = None,
                 terms: Optional[Sequence['outputs.GetImagesQuerySpecTermResult']] = None):
        GetImagesQuerySpecResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match=match,
            terms=terms,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match: Optional[str] = None,
             terms: Optional[Sequence['outputs.GetImagesQuerySpecTermResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if match is not None:
            _setter("match", match)
        if terms is not None:
            _setter("terms", terms)

    @property
    @pulumi.getter
    def match(self) -> Optional[str]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['outputs.GetImagesQuerySpecTermResult']]:
        return pulumi.get(self, "terms")


@pulumi.output_type
class GetImagesQuerySpecTermResult(dict):
    def __init__(__self__, *,
                 op: Optional[str] = None,
                 property: Optional[str] = None,
                 rel: Optional[str] = None,
                 tag: Optional[str] = None,
                 value: Optional[str] = None):
        GetImagesQuerySpecTermResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            op=op,
            property=property,
            rel=rel,
            tag=tag,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             op: Optional[str] = None,
             property: Optional[str] = None,
             rel: Optional[str] = None,
             tag: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if op is not None:
            _setter("op", op)
        if property is not None:
            _setter("property", property)
        if rel is not None:
            _setter("rel", rel)
        if tag is not None:
            _setter("tag", tag)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def rel(self) -> Optional[str]:
        return pulumi.get(self, "rel")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        return pulumi.get(self, "tag")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        return pulumi.get(self, "property")


@pulumi.output_type
class GetLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        GetLocationGeoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            continent=continent,
            country=country,
            lat=lat,
            lon=lon,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             continent: Optional[str] = None,
             country: Optional[str] = None,
             lat: Optional[float] = None,
             lon: Optional[float] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if city is not None:
            _setter("city", city)
        if continent is not None:
            _setter("continent", continent)
        if country is not None:
            _setter("country", country)
        if lat is not None:
            _setter("lat", lat)
        if lon is not None:
            _setter("lon", lon)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetLocationsLocationResult(dict):
    def __init__(__self__, *,
                 cloud_provider: str,
                 cpln_id: str,
                 description: str,
                 enabled: bool,
                 geos: Sequence['outputs.GetLocationsLocationGeoResult'],
                 ip_ranges: Sequence[str],
                 name: str,
                 region: str,
                 self_link: str,
                 tags: Mapping[str, str]):
        GetLocationsLocationResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cloud_provider=cloud_provider,
            cpln_id=cpln_id,
            description=description,
            enabled=enabled,
            geos=geos,
            ip_ranges=ip_ranges,
            name=name,
            region=region,
            self_link=self_link,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cloud_provider: str,
             cpln_id: str,
             description: str,
             enabled: bool,
             geos: Sequence['outputs.GetLocationsLocationGeoResult'],
             ip_ranges: Sequence[str],
             name: str,
             region: str,
             self_link: str,
             tags: Mapping[str, str],
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'cloudProvider' in kwargs:
            cloud_provider = kwargs['cloudProvider']
        if 'cplnId' in kwargs:
            cpln_id = kwargs['cplnId']
        if 'ipRanges' in kwargs:
            ip_ranges = kwargs['ipRanges']
        if 'selfLink' in kwargs:
            self_link = kwargs['selfLink']

        _setter("cloud_provider", cloud_provider)
        _setter("cpln_id", cpln_id)
        _setter("description", description)
        _setter("enabled", enabled)
        _setter("geos", geos)
        _setter("ip_ranges", ip_ranges)
        _setter("name", name)
        _setter("region", region)
        _setter("self_link", self_link)
        _setter("tags", tags)

    @property
    @pulumi.getter(name="cloudProvider")
    def cloud_provider(self) -> str:
        return pulumi.get(self, "cloud_provider")

    @property
    @pulumi.getter(name="cplnId")
    def cpln_id(self) -> str:
        return pulumi.get(self, "cpln_id")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def geos(self) -> Sequence['outputs.GetLocationsLocationGeoResult']:
        return pulumi.get(self, "geos")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence[str]:
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def region(self) -> str:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> str:
        return pulumi.get(self, "self_link")

    @property
    @pulumi.getter
    def tags(self) -> Mapping[str, str]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetLocationsLocationGeoResult(dict):
    def __init__(__self__, *,
                 city: Optional[str] = None,
                 continent: Optional[str] = None,
                 country: Optional[str] = None,
                 lat: Optional[float] = None,
                 lon: Optional[float] = None,
                 state: Optional[str] = None):
        GetLocationsLocationGeoResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            city=city,
            continent=continent,
            country=country,
            lat=lat,
            lon=lon,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             city: Optional[str] = None,
             continent: Optional[str] = None,
             country: Optional[str] = None,
             lat: Optional[float] = None,
             lon: Optional[float] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        if city is not None:
            _setter("city", city)
        if continent is not None:
            _setter("continent", continent)
        if country is not None:
            _setter("country", country)
        if lat is not None:
            _setter("lat", lat)
        if lon is not None:
            _setter("lon", lon)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        return pulumi.get(self, "city")

    @property
    @pulumi.getter
    def continent(self) -> Optional[str]:
        return pulumi.get(self, "continent")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        return pulumi.get(self, "country")

    @property
    @pulumi.getter
    def lat(self) -> Optional[float]:
        return pulumi.get(self, "lat")

    @property
    @pulumi.getter
    def lon(self) -> Optional[float]:
        return pulumi.get(self, "lon")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class GetSecretAwsResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        GetSecretAwsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetSecretAzureConnectorResult(dict):
    def __init__(__self__, *,
                 code: str,
                 url: str):
        GetSecretAzureConnectorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: str,
             url: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("code", code)
        _setter("url", url)

    @property
    @pulumi.getter
    def code(self) -> str:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class GetSecretEcrResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 repos: Sequence[str],
                 secret_key: str,
                 external_id: Optional[str] = None,
                 role_arn: Optional[str] = None):
        GetSecretEcrResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            repos=repos,
            secret_key=secret_key,
            external_id=external_id,
            role_arn=role_arn,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: str,
             repos: Sequence[str],
             secret_key: str,
             external_id: Optional[str] = None,
             role_arn: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accessKey' in kwargs:
            access_key = kwargs['accessKey']
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'externalId' in kwargs:
            external_id = kwargs['externalId']
        if 'roleArn' in kwargs:
            role_arn = kwargs['roleArn']

        _setter("access_key", access_key)
        _setter("repos", repos)
        _setter("secret_key", secret_key)
        if external_id is not None:
            _setter("external_id", external_id)
        if role_arn is not None:
            _setter("role_arn", role_arn)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter
    def repos(self) -> Sequence[str]:
        return pulumi.get(self, "repos")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetSecretKeypairResult(dict):
    def __init__(__self__, *,
                 secret_key: str,
                 passphrase: Optional[str] = None,
                 public_key: Optional[str] = None):
        GetSecretKeypairResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            secret_key=secret_key,
            passphrase=passphrase,
            public_key=public_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             secret_key: str,
             passphrase: Optional[str] = None,
             public_key: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'secretKey' in kwargs:
            secret_key = kwargs['secretKey']
        if 'publicKey' in kwargs:
            public_key = kwargs['publicKey']

        _setter("secret_key", secret_key)
        if passphrase is not None:
            _setter("passphrase", passphrase)
        if public_key is not None:
            _setter("public_key", public_key)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> str:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        return pulumi.get(self, "passphrase")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[str]:
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetSecretNatsAccountResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 private_key: str):
        GetSecretNatsAccountResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            private_key=private_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: str,
             private_key: str,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):
        if 'accountId' in kwargs:
            account_id = kwargs['accountId']
        if 'privateKey' in kwargs:
            private_key = kwargs['privateKey']

        _setter("account_id", account_id)
        _setter("private_key", private_key)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> str:
        return pulumi.get(self, "private_key")


@pulumi.output_type
class GetSecretOpaqueResult(dict):
    def __init__(__self__, *,
                 payload: str,
                 encoding: Optional[str] = None):
        GetSecretOpaqueResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            payload=payload,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             payload: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("payload", payload)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def payload(self) -> str:
        return pulumi.get(self, "payload")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


@pulumi.output_type
class GetSecretTlsResult(dict):
    def __init__(__self__, *,
                 cert: str,
                 key: str,
                 chain: Optional[str] = None):
        GetSecretTlsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            key=key,
            chain=chain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: str,
             key: str,
             chain: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("cert", cert)
        _setter("key", key)
        if chain is not None:
            _setter("chain", chain)

    @property
    @pulumi.getter
    def cert(self) -> str:
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def chain(self) -> Optional[str]:
        return pulumi.get(self, "chain")


@pulumi.output_type
class GetSecretUserpassResult(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str,
                 encoding: Optional[str] = None):
        GetSecretUserpassResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            password=password,
            username=username,
            encoding=encoding,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             password: str,
             username: str,
             encoding: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None,
             **kwargs):

        _setter("password", password)
        _setter("username", username)
        if encoding is not None:
            _setter("encoding", encoding)

    @property
    @pulumi.getter
    def password(self) -> str:
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")


