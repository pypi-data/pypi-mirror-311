# This file was generated by liblab | https://liblab.com/

from typing import Any, List
from .utils.validator import Validator
from .utils.base_service import BaseService
from ..net.transport.serializer import Serializer
from ..models.utils.cast_models import cast_models
from ..models import (
    DirectUploadCompleteArgs,
    DirectUploadListPart,
    DirectUploadResponse,
    DirectUploadStart,
    PartIdResponse,
)


class DirectUploadService(BaseService):

    @cast_models
    def start_direct_upload(
        self, request_body: DirectUploadStart, project_id: str
    ) -> DirectUploadResponse:
        """</br>Start a new video upload using pre-signed S3 multipart uploading.</br>The whole process need to complete in 24 hours otherwise the upload will be marked as expired and</br>the video will fail to encode.</br></br>The process is as follows:</br>1. Initiate a multipart upload by posting to this endpoint. This will be the same as initiating a multipart upload on S3 https://docs.aws.amazon.com/AmazonS3/latest/API/API_CreateMultipartUpload.html.</br>2. Save the `UploadId` and `key` values from the response body.</br>3. Split your file into parts of minimum 5MB.</br>4. For each part, starting with `part_id=1`:</br>   - Get a pre-signed url from `/api/v1/project/{project_id}/direct_upload/s3/multipart/{upload_id}/{part_id}`</br>   - Upload the part directly to the returned pre-signed url.</br>   - Save the `ETag` header on the client.</br>   - Only the last part can be smaller than 5MB.</br>5. After uploading all parts, complete the upload by making a POST request with all the uploaded parts to</br>`/api/v1/project/{project_id}/direct_upload/s3/<upload_id>/complete`

        :param request_body: The request body.
        :type request_body: DirectUploadStart
        :param project_id: The ID of the project.
        :type project_id: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: DirectUploadResponse
        """

        Validator(DirectUploadStart).validate(request_body)
        Validator(str).validate(project_id)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/project/{{project_id}}/direct_upload/s3/multipart",
                self.get_default_headers(),
            )
            .add_path("project_id", project_id)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)
        return DirectUploadResponse._unmap(response)

    @cast_models
    def list_parts(
        self, project_id: str, upload_id: str, key: str
    ) -> List[DirectUploadListPart]:
        """</br>Lists the parts that have been uploaded for a specific multipart upload.

        :param project_id: The ID of the project.
        :type project_id: str
        :param upload_id: The id of the multipart upload.
        :type upload_id: str
        :param key: Key of the S3 object.
        :type key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: List[DirectUploadListPart]
        """

        Validator(str).validate(project_id)
        Validator(str).validate(upload_id)
        Validator(str).min_length(1).validate(key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/project/{{project_id}}/direct_upload/s3/multipart/{{upload_id}}",
                self.get_default_headers(),
            )
            .add_path("project_id", project_id)
            .add_path("upload_id", upload_id)
            .add_query("key", key)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)
        return [DirectUploadListPart._unmap(item) for item in response]

    @cast_models
    def abort_direct_upload(self, project_id: str, upload_id: str, key: str) -> Any:
        """</br>Abort the multipart upload process and delete the file on the server.

        :param project_id: The ID of the project.
        :type project_id: str
        :param upload_id: The id of the multipart upload.
        :type upload_id: str
        :param key: Key of the S3 object.
        :type key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(str).validate(project_id)
        Validator(str).validate(upload_id)
        Validator(str).min_length(1).validate(key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/project/{{project_id}}/direct_upload/s3/multipart/{{upload_id}}",
                self.get_default_headers(),
            )
            .add_path("project_id", project_id)
            .add_path("upload_id", upload_id)
            .add_query("key", key)
            .serialize()
            .set_method("DELETE")
        )

        response = self.send_request(serialized_request)
        return response

    @cast_models
    def complete_direct_upload(
        self,
        request_body: DirectUploadCompleteArgs,
        project_id: str,
        upload_id: str,
        key: str,
    ) -> Any:
        """</br>Complete the multipart upload after uploading all parts.

        :param request_body: The request body.
        :type request_body: DirectUploadCompleteArgs
        :param project_id: The ID of the project.
        :type project_id: str
        :param upload_id: The id of the multipart upload.
        :type upload_id: str
        :param key: Key of the S3 object.
        :type key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        """

        Validator(DirectUploadCompleteArgs).validate(request_body)
        Validator(str).validate(project_id)
        Validator(str).validate(upload_id)
        Validator(str).min_length(1).validate(key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/project/{{project_id}}/direct_upload/s3/multipart/{{upload_id}}/complete",
                self.get_default_headers(),
            )
            .add_path("project_id", project_id)
            .add_path("upload_id", upload_id)
            .add_query("key", key)
            .serialize()
            .set_method("POST")
            .set_body(request_body)
        )

        response = self.send_request(serialized_request)
        return response

    @cast_models
    def upload_part(
        self, project_id: str, upload_id: str, part_id: int, key: str
    ) -> PartIdResponse:
        """</br>Retrieve the pre-signed URL for direct uploading.</br></br>You need to directly POST to it from your client code.</br></br>The response from the S3 endpoint will be the same as in https://docs.aws.amazon.com/AmazonS3/latest/API/API_UploadPart.html.</br></br>You need to save the `eTag` header from the response in your client after directly uploading the part.

        :param project_id: The ID of the project.
        :type project_id: str
        :param upload_id: The id of the multipart upload.
        :type upload_id: str
        :param part_id: The id of the part in the multipart upload process.
        :type part_id: int
        :param key: Key of the S3 object.
        :type key: str
        ...
        :raises RequestError: Raised when a request fails, with optional HTTP status code and details.
        ...
        :return: OK
        :rtype: PartIdResponse
        """

        Validator(str).validate(project_id)
        Validator(str).validate(upload_id)
        Validator(int).min(1).max(10000).validate(part_id)
        Validator(str).min_length(1).validate(key)

        serialized_request = (
            Serializer(
                f"{self.base_url}/api/v1/project/{{project_id}}/direct_upload/s3/multipart/{{upload_id}}/{{part_id}}",
                self.get_default_headers(),
            )
            .add_path("project_id", project_id)
            .add_path("upload_id", upload_id)
            .add_path("part_id", part_id)
            .add_query("key", key)
            .serialize()
            .set_method("GET")
        )

        response = self.send_request(serialized_request)
        return PartIdResponse._unmap(response)
