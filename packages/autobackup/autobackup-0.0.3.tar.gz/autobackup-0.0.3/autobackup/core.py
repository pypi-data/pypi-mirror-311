"""Utility for automating backups of a specific file or directory"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['create_backup', 'clean_dates', 'run_backup']

# %% ../nbs/00_core.ipynb 3
import shutil, os, time, pprint, logging
from pathlib import Path
from fastcore.script import call_parse
from fastcore.xtras import globtastic
from datetime import datetime, timedelta

# %% ../nbs/00_core.ipynb 11
def create_backup(src, dest_dir, dry_run=False,
                 recursive:bool=True, symlinks:bool=True, 
                 file_glob:str=None, file_re:str=None,
                 folder_re:str=None, skip_file_glob:str=None,
                 skip_file_re:str=None, skip_folder_re:str=None):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    src_path = Path(src)
    dest_path = Path(dest_dir) / timestamp
    if not dry_run: dest_path.mkdir(parents=True, exist_ok=True)
    
    if src_path.is_file():
        files_to_copy = [src_path]
    else:
        files_to_copy = globtastic(src_path,recursive=recursive, symlinks=symlinks,
                                   file_glob=file_glob, file_re=file_re,
                                   folder_re=folder_re, skip_file_glob=skip_file_glob,
                                   skip_file_re=skip_file_re, skip_folder_re=skip_folder_re)
        files_to_copy = [Path(f) for f in files_to_copy]
    
    for file in files_to_copy:
        if file.is_file():
            rel_path = file.relative_to(src_path)
            dest_file = dest_path / rel_path
            if not dry_run: dest_file.parent.mkdir(parents=True, exist_ok=True)
            try:
                if dry_run: print(f'Copy from {file} to {dest_file}')
                else: shutil.copy2(file, dest_file)
            except Exception as e:
                logging.warning(f"Failed to copy {file}: {e}")

# %% ../nbs/00_core.ipynb 21
def clean_dates(dates, now=None, max_ages=(2, 14, 60)):
    now = now or datetime.now()
    clean = []
    dates.sort()
    
    for max_age in max_ages:
        lt_max = [d for d in dates if (now - datetime.strptime(d, '%Y%m%d_%H%M%S')).days < max_age]
        if lt_max: clean.append(lt_max[0])

    clean.extend(dates[-5:])  # Keep the newest 5
    return sorted(set(clean))  # Remove duplicates and sort

# %% ../nbs/00_core.ipynb 28
@call_parse
def run_backup(
    src:str, # The source to be backed up
    dest:str, # The destination directory
    max_ages:str="2,14,60", # The max age(s) in days for the different backups
    log_file:str='backup.log',
    dry_run:bool=False, # Dry run?
    recursive:bool=True, 
    symlinks:bool=True, 
    file_glob:str=None, 
    file_re:str=None,
    folder_re:str=None, 
    skip_file_glob:str=None,
    skip_file_re:str=None, 
    skip_folder_re:str=None
):
    "Run backup and cleanup old files. Takes globtastic args."
    
    # Set up logging
    logging.basicConfig(filename=log_file, level=logging.DEBUG,
                        format='%(asctime)s - %(levelname)s - %(message)s')
    try:
        create_backup(src, dest, dry_run=dry_run,
                     recursive=recursive, symlinks=symlinks,
                     file_glob=file_glob, file_re=file_re,
                     folder_re=folder_re, skip_file_glob=skip_file_glob,
                     skip_file_re=skip_file_re, skip_folder_re=skip_folder_re)
        logging.info(f"Backup created: {src} -> {dest}")
    except Exception as e:
        logging.error(f"Backup failed: {str(e)}", exc_info=True)
    finally:
        max_ages = [int(age.strip()) for age in max_ages.split(',')]
        backups = [d.name for d in Path(dest).iterdir() if d.is_dir()]
        to_keep = clean_dates(backups, max_ages=max_ages)
        for backup in backups:
            if backup not in to_keep:
                try:
                    if dry_run:print('Remove', Path(dest) / backup)
                    else: shutil.rmtree(Path(dest) / backup)
                    logging.info(f"Removed old backup: {backup}")
                except Exception as e:
                    logging.error(f"Removing old backup failed: {str(e)}", exc_info=True)
